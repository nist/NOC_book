<div id="preamble">
<div class="sectionbody">
<p>by Daniel Shiffman</p>

<p>The publisher would go here, but there isn&#8217;t one; it’s only me.</p>

<p>version 1.0, generated December 6, 2012</p>

<div id="frontmatter">
</div>
</div>


<section data-type="chapter" id="_welcome">
<h1>Welcome</h1>
<p>Hello!  By browsing the table of contents on your left, you can read the entire text of this book online for free, licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>

<a class="block-link" href="http://natureofcode.com/book/introduction">Start reading the introduction now!</a>

<p>If you like this book, please consider supporting it via the links below:</p>


<div class="image-container two-col" >
  <a href="https://www.createspace.com/4068419">
  <img src="imgs/noc_print.jpg" alt="Nature of Code Image" /></a>
  <p class="caption"><a class="block-link" href="https://www.createspace.com/4068419">Buy print from CreateSpace</a></p>
</div>
<div class="image-container two-col" >
  <a href="http://natureofcode.com">
  <img src="imgs/pdf.png" alt="Nature of Code Image" /></a>
  <p class="caption"><a class="block-link" href="http://natureofcode.com">Buy the e-book bundle (PDF only for now)</a></p>
</div>

<p><h4>(Amazon.com coming soon)</h4></p>

 <p>Please submit corrections to the book <a href="http://github.com/shiffman/The-Nature-of-Code/issues">on my Nature of Code GitHub repo</a>.  Bug reports for the site and online purchasing system can be reported on <a href="http://github.com/shiffman/natureofcode.com/issues">GitHub</a> as well.</p>

<p>Thanks everyone!</p>

<div style="page-break-after:always;"> </div>
<p>Copyright © 2012 by Daniel Shiffman</p>

<p>ISBN-13: 978-0985930806<br/>
ISBN-10: 0985930802</p>

<p>This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 Unported License. To view a copy of this license, visit <a href="http://creativecommons.org/licenses/by-nc/3.0/">creativecommons.org</a> or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California 94041, USA.</p>

<p>All of the book&#8217;s source code is licensed under the <a href="http://creativecommons.org/licenses/LGPL/2.1/">GNU Lesser General Public License</a> as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p>

<p>This book was generated by the <a href="http://magicbookproject.com">Magic Book Project</a>.</p>

<dl>
<dt>Editor</dt>
<dd>
<p>Shannon Fry</p>
</dd>
<dt>Illustrations</dt>
<dd>
<p>Zannah Marsh</p>
</dd>
<dt>Cover Design</dt>
<dd>
<p>David Wilson</p>
</dd>
<dt>Interior Design</dt>
<dd>
<p>David Wilson</p>
</dd>
<dt>Web Site Design</dt>
<dd>
<p>Steve Klise</p>
</dd>
<dt>Editorial and Design Assistant</dt>
<dd>
<p>Evan Emolo</p>
</dd>
<dt>Magic Book Lead Developers</dt>
<dd>
<p>Rune Madsen, Steve Klise</p>
</dd>
<dt>Magic Book Researchers</dt>
<dd>
<p>Evan Emolo, Miguel Bermudez, Luisa Peirera Hors</p>
</dd>
<dt>Index</dt>
<dd>
<p>WordCo Indexing Services</p>
</dd>
</dl>
</section>







<section data-type="dedication" id="_dedication">
<h1>Dedication</h1>
<p>For my grandmother, Bella Manel Greenfield (October 13, 1915 - April 3, 2010)</p>

<figure class="bella">
<img src="imgs/bella.jpg" alt="bella"/>
<figcaption/>
</figure>
<p>Bella Manel was born in New York City. A pioneering woman in mathematics, she earned her PhD in 1939 from New York University under the supervision of Richard Courant.  She worked for Ramo-Wooldridge (now TRW) and at the Rand Corporation with Richard Bellman. Later, she taught mathematics at the College of Notre Dame (now Notre Dame de Namur University) in Belmont, California, and at UCLA.  The Bella Manel Prize for outstanding graduate work by a woman or minority was established at NYU&#8217;s Courant Institute in 1995.</p>

<div style="page-break-after:always;"> </div></section>







<section data-type="chapter" id="_acknowledgments">
<h1>Acknowledgments</h1>
<blockquote class='long-quote'>
  "The world around us moves in complicated and wonderful ways. We spend the earlier parts of our lives learning about our environment through perception and interaction. We expect the physical world around us to behave consistently with our perceptual memory, e.g. if we drop a rock it will fall due to gravity, if a gust of wind blows, lighter objects will be tossed by the wind further. This class focuses on understanding, simulating, and incorporating motion-based elements of our physical world into the digital worlds that we create. Our hope is to create intuitive, rich, and more satisfying experiences by drawing from the perceptual memories of our users."

<span class="attribution">
— James Tu, Dynamic Bodies course description, Spring 2003, ITP
</span>
</blockquote>



<section data-type="sect1" id="_a_1_a_little_bit_of_history">
<h1>A.1  A little bit of history</h1>
<p>In 2003, as a graduate student at the Interactive Telecommunications Program (ITP) in the Tisch School of the Arts at New York University, I enrolled in a course called Dynamic Bodies.  The course was taught by interaction designer and ITP adjunct professor James Tu.    At the time, my work was focused on a series of software experiments that generated real-time “non-photorealistic” imagery.  The applications involved capturing images from a live source and “painting” the colors with elements that moved about the screen according to various rules.  The Dynamic Bodies course—which covered vectors, forces, oscillations, particle systems, recursion, steering, and springs—aligned perfectly with my work.</p>

<p>I had been using these concepts informally in my own projects, but had never taken the time to closely examine the science behind the algorithms or learn object-oriented techniques to formalize their implementation.  That very semester, I also enrolled in Foundations of Generative Art Systems, a course taught by Philip Galanter, that focused on the theory and practice of generative art, covering topics such as chaos, cellular automata, genetic algorithms, neural networks, and fractals.  Both Tu’s course and Galanter’s course opened my eyes to a world of simulation algorithms and techniques that carried me through the next several years of work and teaching, and served as the foundation and inspiration for this book.</p>

<p>But there’s another piece of the puzzle missing from this story.</p>

<p>Galanter’s course was mostly theory-based, while Tu’s was taught using Macromedia Director and the Lingo programming language.  That semester, I learned many of the algorithms by translating them into C++ (the language I was using quite awkwardly at the time, well before C++ creative coding environments like openFrameworks and Cinder had arrived).  Towards the end of the semester, I discovered something called <a href="http://www.processing.org">Processing</a>.  Processing was in alpha then (version 0055) and, having had some experience with Java, it intrigued me enough to ask the question: Could this open-source, artist-friendly programming language and environment be the right place to develop a suite of tutorials and examples about programming and simulation?  With the support of the ITP and Processing communities, I embarked on what has now been an almost eight-year journey of teaching a variety of programming concepts and their applications using Processing.</p>

<p>I’d like to first thank Red Burns, ITP’s founder, who has supported and encouraged me in my work for over ten years.  Dan O’Sullivan, the chair of ITP, has been my teaching mentor and was the first to suggest that I try teaching a course on Processing, giving me a reason to start assembling programming tutorials in the first place.  Shawn Van Every, developer extraordinaire and author of <em>Pro Android Media</em>, has also been a rich source of help and inspiration at ITP over the years.  ITP faculty members Clay Shirky, Danny Rozin, Katherine Dillon, Marianne Petit, Marina Zurkow, and Tom Igoe have provided a great deal of support and feedback throughout the writing of this book.  The rest of the faculty and staff at ITP have also made this possible: Brian Kim, Edward Gordon, George Agudow, John Duane, Marlon Evans, Matt Berger, Megan Demarest, Midori Yasuda, and Rob Ryan.</p>

<p>The students of ITP, too numerous to mention, have been an amazing source of feedback throughout this process. Much of the material in this book comes from my course of the same title, which I’ve now taught for five years.  I have stacks of draft printouts of the book with notes scrawled along the margins as well as a vast archive of student emails with corrections, comments, and generous words of encouragement.</p>

<p>I am also indebted to the energetic and supportive community of Processing programmers and artists.  I wouldn&#8217;t be writing this book if it weren’t for Casey Reas and Ben Fry, who created Processing.  I’ve learned half of what I know simply from reading through the Processing source code; the elegant simplicity of the Processing language, website, and IDE has made programming accessible and fun for all of my students.  I’ve received advice and inspiration from many Processing programmers including Andrés Colubri, Jer Thorp, Marius Watz, Karsten Schmidt, Robert Hodgin, Seb-Lee Delisle, and Ira Greenberg.  Heather Dewey-Hagborg provided a great deal of excellent feedback on Chapter 10 (Neural Networks) and Philip Galanter helped to clarify the definitions of complexity and complex systems. Scott Murray provided some really helpful advice about inline SVGs over e-mail.  Many of the titles in the Further Reading section were suggested by Golan Levin.</p>

<p>I am indebted to Shannon Fry, who edited this book every step of the way.  The knowledge that I would always have her careful and thoughtful feedback on my writing allowed me to plow ahead, aware that everything would come out sounding better after she got her hands on my chapters.</p>

<p>A special mention goes to Zannah Marsh who worked tirelessly to create over a hundred illustrations for this book, developing a friendly and informal look.  I especially want to thank her for her patience and willingness to go with the flow as we changed the illustration requirements several times.  I also want to thank David Wilson, who came to my rescue at the last minute and designed the interior layout and cover for the book.  I am particularly grateful to Steve Klise, who designed and built the book&#8217;s website, helping me to develop a "pay what you want" model for the digital PDF.</p>

<p>As I’ll explain a bit more in the preface, this book was generated with a new open-source system for publishing called “The Magic Book.”  A crack team of ITP programmers, designers, and artists worked over the course of more than a year to develop this system, which generates a  book in a variety of formats (PDF, HTML, and more) from one single ASCIIDOC file, all designed with CSS layout.  Rune Madsen began the project and developed the original Ruby / Sinatra framework.  I am pretty sure I&#8217;d still be struggling with putting the book together well into 2013 if it weren&#8217;t for Rune&#8217;s dedication to seeing the project through to the end. Steve Klise contributed countless bug fixes and engineered the system that allows us to restyle code comments to the side of the code blocks themselves.  Miguel Bermudez, Evan Emolo, and Luisa Pereira Hors contributed in many ways, learning the ins and outs of ASCIIDOC as well as CSS Paged Media.  ITP researcher Greg Borenstein provided a tremendous amount of advice and support along the way regarding the areas of publishing for the Web and print.  <a href="http://princexml.com">Prince</a> is the engine the Magic Book uses to generate a PDF from an HTML document, and I&#8217;d like to thank Michael Day, CEO of PrinceXML, who answered many of our questions (at lightning speed) along the way.</p>

<p>Finally I’d like to thank my family: my wife, Aliki Caloyeras, who supported this project throughout while having her own giant tome to write, and my children, Elias and Olympia, motivation for finishing this up so that I could spend more time hanging out with them.  I’d also like to thank my father, Bernard Shiffman, who generously lent his mathematical expertise and provided feedback along the way, as well as my mother, Doris Yaffe Shiffman, and brother, Jonathan Shiffman, who were always tremendously supportive in asking the question: “How is the book coming along?”</p>
</section>







<section data-type="sect1" id="_a_2_kickstarter">
<h1>A.2 Kickstarter</h1>
<p>There is another organization and community that has made this book possible: Kickstarter.</p>

<p>In 2008, I completed work on my first book, <em>Learning Processing</em>, published by Morgan Kaufmann/Elsevier. <em>Learning Processing</em> took almost three years to finish. I didn’t take a lot of care in choosing a publisher or thinking about the terms. I just thought — “Really? You want to publish a book by me? OK, I’ll do it.” Unfortunately, my experience was not entirely positive. I had five different editors assigned to me throughout the process, and I received little to no feedback on the content itself. The publisher outsourced the typesetting, which resulted in a great deal of mistakes and inconsistencies in production. In addition, I found the pricing of the book to be off the mark. My goal was to write a friendly, inexpensive (black and white), paperback introduction to programming in Processing, and the book ended up retailing for a "textbook" price of $50.</p>

<p>Now, I want to emphasize that my publisher had good intentions. They honestly wanted to produce the best book possible, one that I would be happy with, that they would be happy with, and that readers would enjoy. And they worked hard to make this happen. Unfortunately, they had to work within a very tight budget, and as a result were stretched extremely thin. In addition, I don’t think they were terribly familiar with the world of open-source “creative” coding environments like Processing; their world is computer science textbooks.</p>

<p>As a result, for this Nature of Code book, I felt it was important to try self-publishing. Since I didn’t get editing support from the publisher, why not hire an editor?  I wasn’t happy with the pricing, so why not set the price myself (or, in the case of the PDF, let the buyer set the price)?  Then there’s the question of marketing — does a publisher add value and help you reach an audience? In some cases, the answer is yes. The O’Reilly “Make” series, for example, does a wonderful job of creating a community around their books and products. Still, in the case of learning to program in Processing, reaching the audience is as simple as one URL — processing.org.</p>

<p>Unfortunately, I quickly discovered that there is one thing a publisher offers that I was not getting from my self-publishing path. One very important, highly crucial detail — a deadline. On my own, I floundered for two years, saying I was going to write the Nature of Code book but only drafting a little bit here and there. On my list of things I needed to do, it was always at the bottom. Then along came Kickstarter, and with an audience sitting and waiting (and having spent cash money), I lived in fear of not meeting my deadline. And the fact that you are reading this now is an indication that it worked.</p>

<p>Most importantly, self-publishing the book has allowed me a great deal of flexibility in how I price and distribute the content.  On Elsevier’s website, you can purchase <em>Learning Processing</em> as an e-book for $53.95.  That’s right, fifty-three dollars and ninety-five cents.  Incidentally, for each e-book sold I get a royalty of 5%, which is $2.70.  That’s right, two dollars and seventy cents.  If I self-publish, I can make the book massively cheaper.  Selling a digital copy for $10, I’m reducing the cost to the reader by over eighty percent and tripling the money paid to me.  I&#8217;m taking this even further with the PDF and allowing buyers to set the price themselves.</p>

<p>In addition, by owning all the content, I am able to release the entire book online for free as well as experiment with new digital formats.   The raw text of the book, as well as all the code and illustrations, is licensed under a Creative Commons Attribution-NonCommercial license and is available on GitHub, where readers can submit issues (not to mention pull requests!) with corrections and comments.   Finally, by using more flexible print-on-demand services, I can more easily make changes and keep the book current, releasing new editions as often as I like. (A one-time purchase of a digital copy of the book includes lifetime upgrades for free.)</p>

<p>So thank you to Kickstarter, both the company (especially Fred Benenson, who convinced me to take the plunge in the first place and advised me on how to license the book) as well as all the backers who took a chance on this book. Some of these backers, through generosity beyond the call of duty, earned an extra thank-you as part of their reward:</p>

<ul>
<li>
<p>Alexandre B.</p></li>
<li>
<p>Robert Hodgin</p></li>
<li>
<p>JooYoun Paek</p></li>
<li>
<p>Angela McNamee (Boyhan)</p></li>
<li>
<p>Bob Ippolito</p></li>
</ul>

<p>All of the backers directly contributed to the finishing of this book.  Just the sheer act of signing up to contribute money for draft and final versions lit a fire in me to finish, not to mention provided me with the resources to pay for design and editing work (and some babysitting during Saturday morning writing sessions).</p>

<p>In addition to contributing funds, Kickstarter backers read pre-release versions of the chapters and provided tons of feedback, catching many errors and pointing out confusing sections of the book.   Two such readers that I’d like to thank are Frederik Vanhoutte and Hans de Wolf, whose expert knowledge of Newtonian physics was enormously helpful in the revising of Chapters 2 and 3.</p>

<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_preface">
<h1>Preface</h1>



<section data-type="sect1" id="_p_1_what_is_this_book">
<h1>P.1 What is this book?</h1>
<p>At <a href="http://itp.nyu.edu">ITP</a>, I teach a course entitled Introduction to Computational Media.   In this course, the students learn the basics of programming (variables, conditionals, loops, objects, arrays) as well as a survey of applications related to making interactive projects (images, pixels, computer vision, networking, data, 3D).    The course mostly follows the material found in my intro book <em>Learning Processing</em>; in many ways, <em>The Nature of Code</em> serves as a follow-up.   Once you’ve learned the basics and seen an array of applications, your next step might be to delve deeply into a particular area.  For example, you could focus on computer vision (and read a book like Greg Borenstein’s <em>Making Things See</em>).   In the most basic sense, this book is one possible next step in a world of many.  It picks up exactly where <em>Learning Processing</em> leaves off, demonstrating more advanced programming techniques with Processing that focus on algorithms and simulation.</p>

<p>The goal of this book is simple. We want to take a look at something that naturally occurs in our physical world, then determine how we can write code to simulate that occurrence.</p>

<p>So then what is this book exactly?  Is it a science book?   The answer is a resounding no.  True, we might examine topics that come from physics or biology, but it won’t be our job to investigate these topics with a particularly high level of academic rigor.  Instead, we’re going to glance at scientific concepts and grab the parts that we need in the service of building a particular software example.</p>

<p>Is this an art or design book?  I would also say no; after all, we are going to focus on algorithms and their affiliated programming techniques.  Sure, the results will all be visual in nature (manifested as animated Processing sketches), but they will exist more as demonstrations of the algorithms and programming techniques themselves, drawn only with simple shapes and grayscale.   It is my hope, however, that designers and artists can incorporate all of the material here into their practice to make new, engaging work.</p>

<p>In the end, if this book is anything, it is really just a good old-fashioned programming book.   While a scientific topic may seed a chapter (Newtonian physics, cellular growth, evolution) or the results might inspire an artistic project, the content itself will always boil down to the code implementation, with a particular focus on object-oriented programming.</p>
</section>







<section data-type="sect1" id="_p_2_a_word_about_processing">
<h1>P.2 A word about Processing</h1>
<p>I am using Processing in this book for a number of reasons.  For one, it’s the language and environment with which I am most comfortable, and it’s what I enjoy using for my personal work.   Two, it’s free, open-source, and well suited to beginners.  There is an active, energetic community of people who program with Processing; for many, it’s the first programming language they’ve learned.  In this sense, I hope that I can reach a wide audience and demonstrate the concepts in a friendly manner by using Processing.</p>

<p>All that said, there is nothing that ties what we are doing in this book strictly to Processing.   This book could have been written using ActionScript, JavaScript, Java (without Processing), or any number of other open-source “creative coding” environments like openFrameworks, Cinder, or the newly released pocode.   It is my hope that after I’ve completed this book, I’ll be able to release versions of the examples that run in other environments.  If anyone is interested in helping to port the examples, please feel free to contact me (<code>daniel@shiffman.net</code>).</p>

<p>All of the examples in this book have been tested with Processing 2.0b6, but for the most part, they should also work with earlier versions of Processing.  I’ll be keeping them up-to-date with whatever the latest version is.  The most recent code can always be found on <a href="http://github.com/shiffman/The-Nature-of-Code-Examples">GitHub</a>.</p>
</section>







<section data-type="sect1" id="_p_3_what_do_you_need_to_know">
<h1>P.3 What do you need to know?</h1>
<p>The prerequisite for understanding the material in this book could be stated as: “one semester of programming instruction with Processing (including familiarity with object-oriented programming).”   That said, there’s no reason why you couldn’t read this book having learned programming using a different language or development environment.   The key here is that you have experience with programming.</p>

<p>If you’ve never written any code before, you are going to struggle, because this book assumes knowledge of all the basics.   I would suggest picking up an introductory book on Processing, a number of which are listed on <a href="http://processing.org/learning/books/">the Processing website</a>.</p>

<p>If you are an experienced programmer, but haven’t worked with Processing, you can probably pick it up by <a href="http://processing.org/download/">downloading Processing</a>, poking through the examples, and reading through the <a href="http://processing.org/learning/gettingstarted/">Getting Started</a> page.</p>

<p>I should also point out that experience with object-oriented programming is crucial. We’ll review some of the basics in the book’s introduction, but I would suggest reading the <a href="http://processing.org/learning/objects">Processing tutorial on objects</a> first.</p>
</section>







<section data-type="sect1" id="_p_4_what_are_you_using_to_read_this_book">
<h1>P.4 What are you using to read this book?</h1>
<p>Are you reading this book on a Kindle?  Printed paper?  On your laptop in PDF form?  On a tablet showing an animated HTML5 version?  Are you strapped to a chair, absorbing the content directly into your brain via a series of electrodes, tubes, and cartridges?</p>

<p>The book you are reading right now was generated with the <a href="http://www.magicbookproject.com">Magic Book project</a>.  The Magic Book is an open-source framework for self-publishing developed at <a href="http://itp.nyu.edu">ITP</a>.   The idea here is that you only need to write the book once as a simple text file.  Once you’ve written your content, you press a magic button, and out comes your book in a variety of formats—PDF, HTML5, printed hardcopy, Kindle, etc.  Everything is designed and styled using CSS.   As of the first release, the only versions available will be digital PDF, printed hardcopy, and HTML5 (which will include animated versions of the examples using Processing.js).  Hopefully over the course of the next year, the book will be available in additional formats.  If you’d like to help with this, please contact me (<code>daniel@shiffman.net</code>).</p>
</section>







<section data-type="sect1" id="_p_5_the_story_of_this_book">
<h1>P.5 The “story” of this book</h1>
<p>If you glance over the book’s table of contents, you’ll notice there are ten chapters, each one covering a different topic.  And in one sense, this book is just that—a survey of ten concepts and associated code examples.  Nevertheless, in putting together the material, I had always imagined something of a linear narrative.  Before you begin reading the chapters, I’d like to walk you through this story.</p>





<section data-type="sect2" id="_part_i_inanimate_objects">
<h2>Part I: Inanimate objects</h2>
<p>A soccer ball lies in the grass.  A kick launches it into the air.  Gravity pulls it back down. A heavy gust of wind keeps it afloat a moment longer until it falls and bounces off the head of a jumping player.   The soccer ball is not alive; it makes no choices as to how it will move throughout the world.  Rather, it is an inanimate object waiting to be pushed and pulled by the forces of its environment.</p>

<div style="page-break-after:always;"> </div>
<p>How would we model a soccer ball moving in Processing?   If you’ve ever programmed a circle moving across a window, then you’ve probably written the following line of code.</p>

<pre data-type="programlisting" data-code-language="java">x = x + 1;</pre>

<p>You draw some shape at location <strong var>x</strong>.  With each frame of animation, you increment the value of <strong var>x</strong>, redraw the shape and voila—the illusion of motion!  Maybe you took it a step or two further, and included a <strong var>y</strong> location, as well as variables for speed along the <em>x</em> and <em>y</em> axes.</p>

<pre data-type="programlisting" data-code-language="java">x = x + xspeed;
y = y + yspeed;</pre>

<p>Part I of this story will take us one step further. We’re going to take these variables <strong var>xspeed</strong> and <strong var>yspeed</strong> and learn how together they form a vector (<strong>Chapter 1</strong>), the building block of motion.  We won’t get any new functionality out of this, but it will build a solid foundation for the rest of the book.</p>

<p>Once we know a little something about vectors, we’re going to quickly realize that a force (<strong>Chapter 2</strong>) is a vector.   Kick a soccer ball and you are applying a force.  What does a force cause an object to do?  According to Isaac Newton, force equals mass times acceleration.   That force causes an object to accelerate.   Modeling forces will allow us to create systems with dynamic motion where objects move according to a variety of rules.</p>

<p>Now, that soccer ball to which you applied a force might have also been spinning.    If an object moves according to its acceleration, it can spin according to its angular acceleration (<strong>Chapter 3</strong>).  Understanding the basics of angles and trigonometry will allow us to model rotating objects as well as grasp the principles behind oscillating motion, like a pendulum swinging or a spring bouncing.</p>

<p>Once we’ve tackled the basics of motion and forces for an individual inanimate object, we’ll learn how to make thousands upon thousands of those objects and manage them in a single system called a particle system (<strong>Chapter 4</strong>).   Particle systems will allow us to look at some advanced features of object-oriented programming, namely inheritance and polymorphism.</p>

<p>In Chapters 1 through 4, all of the examples will be written from “scratch”—meaning the code for the algorithms driving the motion of the objects will be written directly in Processing.   We’re certainly not the first programmers ever to consider the idea of simulating physics in animation, so next we’ll examine how physics libraries (<strong>Chapter 5</strong>) can be used to model more advanced and sophisticated behaviors.  We’ll look at <a href="http://www.box2d.org">Box2D</a> and <a href="http://toxiclibs.org/">toxiclibs' Verlet Physics package</a>.</p>
</section>







<section data-type="sect2" id="_part_ii_it_s_alive">
<h2>Part II: It’s alive!</h2>
<p>What does it mean to model life?  Not an easy question to answer, but we can begin by building objects that have an ability to perceive their environment.   Let’s think about this for a moment.  A block that falls off a table moves according to forces, as does a dolphin swimming through the water.  But there is a key difference.  The block cannot decide to leap off that table.  The dolphin can decide to leap out of the water.  The dolphin can have dreams and desires.  It can feel hunger or fear, and those feelings can inform its movements.  By examining techniques behind modeling autonomous agents (<strong>Chapter 6</strong>), we will breathe life into our inanimate objects, allowing them to make decisions about their movements according to their understanding of their environment.</p>

<p>Through combining the concept of autonomous agents with what we learned about modeling systems in Chapter 4, we’ll look at models of group behavior that exhibit the properties of complexity.   A complex system is typically defined as a system that is “more than the sum of its parts.”  While the individual elements of the system may be incredibly simple and easily understood, the behavior of the system as a whole can be highly complex, intelligent, and difficult to predict.   This will lead us away from thinking purely about modeling motion and into the realm of rule-based systems.   What can we model with cellular automata (<strong>Chapter 7</strong>), a system of cells living on a grid?  What types of patterns can we generate with fractals (<strong>Chapter 8</strong>), the geometry of nature?</p>
</section>







<section data-type="sect2" id="_part_iii_intelligence">
<h2>Part III: Intelligence</h2>
<p>We made things move.  Then we gave those things hopes and dreams and fears, along with rules to live by.  The last step in this book will be to make our creations even smarter.  Can we apply the biological process of evolution to computational systems (<strong>Chapter 9</strong>)  in order to evolve our objects?   Taking inspiration from the human brain, can we program an artificial neural network (<strong>Chapter 10</strong>) that can learn from its mistakes and allow our objects to adapt to their environment?</p>
</section>


</section>







<section data-type="sect1" id="_p_6_this_book_as_a_syllabus">
<h1>P.6 This book as a syllabus</h1>
<p>While the content in this book certainly makes for an intense and highly compressed semester, I have designed it to fit into a fourteen-week course.  Nevertheless, it’s worth mentioning that I find that the book chapters sometimes work better expanded across multiple weeks.  For example, the syllabus for my course generally works out as follows:</p>

<div style="page-break-after:always;"> </div>
<div class="list">
<dl class="preface">
<dt>Week 1</dt><dd><p>Introduction and Vectors (Chapter 1)</p></dd>
<dt>Week 2</dt><dd><p>Forces (Chapter 2)</p></dd>
<dt>Week 3</dt><dd><p>Oscillations (Chapter 3)</p></dd>
<dt>Week 4</dt><dd><p>Particle Systems (Chapter 4)</p></dd>
<dt>Week 5</dt><dd><p>Physics Libraries Part I (Chapter 5)</p></dd>
<dt>Week 6</dt><dd><p>Physics Libraries Part II & Steering (Chapters 5-6)</p></dd>
<dt>Week 7</dt><dd><p>Present midterm projects about motion</p></dd>
<dt>Week 8</dt><dd><p>Complex Systems: Flocking and 1D Cellular Automata (Chapters 6-7)</p></dd>
<dt>Week 9</dt><dd><p>Complex Systems: 2D Cellular Automata and Fractals (Chapters 7-8)</p></dd>
<dt>Week 10</dt><dd><p>Genetic Algorithms (Chapter 9)</p></dd>
<dt>Week 11</dt><dd><p>Neural Networks (Chapter 10)</p></dd>
<dt>Weeks 12-13</dt><dd><p>Final project workshop</p></dd>
<dt>Week 14</dt><dd><p>Final project presentation</p></dd></dl></div>
<p>If you are considering using this text for a course or workshop, please feel free to contact me.  I hope to eventually release a companion set of videos and slide presentations as supplementary educational materials.</p>
</section>







<section data-type="sect1" id="_p_7_the_ecosystem_project">
<h1>P.7 The Ecosystem Project</h1>
<p>As much as I’d like to pretend you could learn everything by curling up in a comfy chair and reading some prose about programming, to learn programming, you’re really going to have to do some programming.  You might find it helpful to keep in mind a project idea (or two) to develop as a set of exercises while going from chapter to chapter.  In fact, when teaching the Nature of Code course at ITP, I have often found that students enjoy building a single project, step by step, week by week, over the course of a semester.</p>

<p>At the end of each chapter, you’ll find a series of exercises for one such project—exercises that build on each other, one topic at a time.   Consider the following scenario.   You’ve been asked by a science museum to develop the software for a new exhibit—The Digital Ecosystem, a world of animated, procedural creatures that live on a projection screen for visitors to enjoy as they enter the museum. I don’t mean to suggest that this is a particularly innovative or creative concept.  Rather, we’ll use this example project idea as a literal representation of the content in the book, demonstrating how the elements fit together in a single software project.  I encourage you to develop your own idea, one that is more abstract and creative in its thinking.</p>
</section>







<section data-type="sect1" id="_p_8_where_do_i_find_the_code_online_and_submit_feedback">
<h1>P.8 Where do I find the code online and submit feedback?</h1>
<p>For all things book-related, please visit the <a href="http://www.natureofcode.com">Nature of Code website</a>.    The raw source text of the book and all of the illustrations are on <a href="http://github.com/shiffman/The-Nature-of-Code">GitHub</a>.   Please leave feedback and submit corrections using GitHub issues.</p>

<p>The source code for all of the examples (and exercises) is also available on <a href="http://github.com/shiffman/The-Nature-of-Code-Examples">GitHub</a>.  The chapters themselves include code snippets in-line with the text.  However, I want to mention that in many cases, I have shortened or simplified the code snippets in order to illustrate a specific point.   In all cases, the full code with comments can be found via GitHub.</p>

<p>If you have questions about the code itself, I would suggest posting them on the <a href="http://forum.processing.org">Processing forum</a>.</p>

<div style="page-break-after:always;"> </div>

</div>
<div id="contents"></section>



</section>







<section data-type="chapter" id="_introduction">
<h1>Introduction</h1>
<blockquote data-type="epigraph"><p>“I am two with nature.”</p>
<p data-type="attribution">&#8212; — Woody Allen</p>
</blockquote>

<p>Here we are: the beginning.  Well, almost the beginning. If it’s been a while since you’ve done any programming in Processing (or any math, for that matter), this introduction will get your mind back into computational thinking before we approach some of the more difficult and complex material.</p>

<p>In Chapter 1, we’re going to talk about the concept of a vector and how it will serve as the building block for simulating motion throughout this book.   But before we take that step, let’s think about what it means for something to simply move around the screen.   Let’s begin with one of the best-known and simplest simulations of motion—the random walk.</p>




<section data-type="sect1" id="intro_section1">
<h1>I.1 Random Walks</h1>
<p><a data-type="indexterm" data-primary=""random walks"">&nbsp;</a></p>

<p>Imagine you are standing in the middle of a balance beam.  Every ten seconds, you flip a coin.  Heads, take a step forward.  Tails, take a step backward.   This is a random walk—a path defined as a series of random steps.    Stepping off that balance beam and onto the floor, you could perform a random walk in two dimensions by flipping that same coin twice with the following results:</p>

<table>

<thead>
<tr>
<th>Flip 1</th>
<th>Flip 2</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Heads</p></td>
<td><p>Heads</p></td>
<td><p>Step forward.</p></td>
</tr>
<tr>
<td><p>Heads</p></td>
<td><p>Tails</p></td>
<td><p>Step right.</p></td>
</tr>
<tr>
<td><p>Tails</p></td>
<td><p>Heads</p></td>
<td><p>Step left.</p></td>
</tr>
<tr>
<td><p>Tails</p></td>
<td><p>Tails</p></td>
<td><p>Step backward.</p></td>
</tr>
</tbody>
</table>

<p>Yes, this may seem like a particularly unsophisticated algorithm.  Nevertheless, random walks can be used to model phenomena that occur in the real world, from the movements of molecules in a gas to the behavior of a gambler spending a day at the casino.  As for us, we begin this book studying a random walk with three goals in mind.</p>

<p><a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""modeling with random walks"">&nbsp;</a></p>

<ol>
<li>
<p>We need to review a programming concept central to this book—object-oriented programming.  The random walker will serve as a template for how we will use object-oriented design to make things that move around a Processing window.</p></li>
<li>
<p>The random walk instigates the two questions that we will ask over and over again throughout this book: “How do we define the rules that govern the behavior of our objects?” and then, “How do we implement these rules in Processing?”</p></li>
<li>
<p>Throughout the book, we’ll periodically need a basic understanding of randomness, probability, and Perlin noise.  The random walk will allow us to demonstrate a few key points that will come in handy later.</p></li>
</ol>
</section>







<section data-type="sect1" id="intro_section2">
<h1>I.2 The Random Walker Class</h1>
<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""review of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""review of object-oriented programming with"">&nbsp;</a></p>

<p>Let’s review a bit of object-oriented programming (OOP) first by building a <strong klass>Walker</strong> object.   This will be only a cursory review.  If you have never worked with OOP before, you may want something more comprehensive; I’d suggest stopping here and reviewing the <a href="http://processing.org/learning/objects/">basics on the Processing website</a> before continuing.</p>

<p><a data-type="indexterm" data-primary=""object"" data-secondary=""defined"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""object"">&nbsp;</a></p>

<p>An <strong><em>object</em></strong> in Processing is an entity that has both data and functionality.  We are looking to design a <strong klass>Walker</strong> object that both keeps track of its data (where it exists on the screen) and has the capability to perform certain actions (such as draw itself or take a step).</p>

<p><a data-type="indexterm" data-primary=""class (Processing)"" data-secondary=""defined"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""class"">&nbsp;</a></p>

<p>A <strong><em>class</em></strong> is the template for building actual instances of objects.  Think of a class as the cookie cutter; the objects are the cookies themselves.</p>

<p>Let’s begin by defining the <strong klass>Walker</strong> class—what it means to be a <strong klass>Walker</strong> object.  The <strong klass>Walker</strong> only needs two pieces of data—a number for its x-location and one for its y-location.</p>

<pre data-type="programlisting" data-code-language="java">class Walker {
  //[full] Objects have data.
  int x;
  int y;
  //[end]</pre>

<p><a data-type="indexterm" data-primary=""class (Processing)"" data-secondary=""constructor"">&nbsp;</a>
<a data-type="indexterm" data-primary=""constructor"">&nbsp;</a></p>

<p>Every class must have a constructor, a special function that is called when the object is first created.  You can think of it as the object’s <strong function>setup()</strong>.   There, we’ll initialize the <strong klass>Walker</strong><code>’</code>s starting location (in this case, the center of the window).</p>

<pre data-type="programlisting" data-code-language="java">  //[full] Objects have a constructor where they are initialized.
  Walker() {
    x = width/2;
    y = height/2;
  }
  //[end]</pre>

<p><a data-type="indexterm" data-primary=""class (Processing)"" data-secondary=""functionality"">&nbsp;</a>
<a data-type="indexterm" data-primary=""functionality"">&nbsp;</a></p>

<p>Finally, in addition to data, classes can be defined with functionality.  In this example, a <strong klass>Walker</strong> has two functions.   We first write a function that allows the object to display itself (as a black dot).</p>

<pre data-type="programlisting" data-code-language="java">  //[full] Objects have functions.
  void display() {
    stroke(0);
    point(x,y);
  }
  //[end]</pre>

<p>The second function directs the <strong klass>Walker</strong> object to take a step.   Now, this is where things get a bit more interesting.   Remember that floor on which we were taking random steps?  Well, now we can use a Processing window in that same capacity.  There are four possible steps. A step to the right can be simulated by incrementing <strong var>x</strong> (<strong var>x</strong><code>++</code>); to the left by decrementing <strong var>x</strong> (<strong var>x--</strong>); forward by going down a pixel (<strong var>y++</strong>); and backward by going up a pixel (<strong var>y--</strong>).   How do we pick from these four choices?   Earlier we stated that we could flip two coins.  In Processing, however, when we want to randomly choose from a list of options, we can pick a random number using <strong function>random()</strong>.</p>

<p><a data-type="indexterm" data-primary=""random number generators"" data-secondary=""random() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random() function"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">  void step() {
    // 0, 1, 2, or 3
    int choice = int(random(4));</pre>

<p>The above line of code picks a random floating point number between 0 and 4 and converts it to an integer, with a result of 0, 1, 2, or 3.   Technically speaking, the highest number will never be 4.0, but rather 3.999999999 (with as many 9s as there are decimal places); since the process of converting to an integer lops off the decimal place, the highest <strong var>int</strong> we can get is 3.  Next, we take the appropriate step (left, right, up, or down) depending on which random number was picked.</p>

<pre data-type="programlisting" data-code-language="java">    //[full] The random “choice” determines our step.
    if (choice == 0) {
      x++;
    } else if (choice == 1) {
      x--;
    } else if (choice == 2) {
      y++;
    } else {
      y--;
    }
    //[end]
  }
}</pre>

<p>Now that we’ve written the class, it’s time to make an actual <strong klass>Walker</strong> object in the main part of our sketch—<strong function>setup()</strong> and <strong function>draw()</strong>.   Assuming we are looking to model a single random walk, we declare one global variable of type <strong var>Walker</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// A Walker object
Walker w;</pre>

<p><a data-type="indexterm" data-primary=""new operator (objects)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object"" data-secondary=""new operator"">&nbsp;</a></p>

<p>Then we create the object in <strong function>setup()</strong> by calling the constructor with the <strong function>new</strong> operator.</p>

<p><strong example>Example I.1: Traditional random walk</strong></p>

<p><em>Each time you see the above Example heading in this book, it means there is a corresponding code example available on <a href="http://github.com/shiffman/The-Nature-of-Code-Examples">GitHub</a>.</em></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
  // Create the Walker.
  w = new Walker();  //[bold]
  background(255);
}</pre>

<p>Finally, during each cycle through <strong function>draw()</strong>, we ask the <strong klass>Walker</strong> to take a step and draw a dot.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  //[full] Call functions on the Walker.
  w.step(); //[bold]
  w.display(); //[bold]
  //[end]
}</pre>

<p>Since we only draw the background once in <strong function>setup()</strong>, rather than clearing it continually each time through <strong function>draw()</strong>, we see the trail of the random walk in our Processing window.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_1_RandomWalkTraditional/_I_1_RandomWalkTraditional.pde processingjs/intro/_I_1_RandomWalkTraditional/Walker.pde">
<img src="imgs/intro/intro_ex01.png" alt="intro ex01"/>
<figcaption/>
</figure>
<p>There are a couple improvements we could make to the random walker.  For one, this <strong klass>Walker</strong><code>’</code>s step choices are limited to four options—up, down, left, and right.  But any given pixel in the window has eight possible neighbors, and a ninth possibility is to stay in the same place.</p>

<figure id="intro_figure1">
<img src="imgs/intro/intro_01.png" alt="Figure I.1"/>
<figcaption/>
</figure>
<p>To implement a <strong klass>Walker</strong> object that can step to any neighboring pixel (or stay put), we could pick a number between 0 and 8 (nine possible choices).  However, a more efficient way to write the code would be to simply pick from three possible steps along the x-axis (-1, 0, or 1) and three possible steps along the y-axis.</p>

<pre data-type="programlisting" data-code-language="java">  void step() {
    //[full] Yields -1, 0, or 1
    int stepx = int(random(3))-1;
    int stepy = int(random(3))-1;
    //[end]
    x += stepx;
    y += stepy;
  }</pre>

<p>Taking this further, we could use floating point numbers (i.e. decimal numbers) for <strong var>x</strong> and <strong var>y</strong> instead and move according to an arbitrary random value between -1 and 1.</p>

<pre data-type="programlisting" data-code-language="java">  void step() {
    //[full] Yields any floating point number between -1.0 and 1.0
    float stepx = random(-1, 1);
    float stepy = random(-1, 1);
    //[end]
    x += stepx;
    y += stepy;
  }</pre>

<p>All of these variations on the “traditional” random walk have one thing in common: at any moment in time, the probability that the <strong klass>Walker</strong> will take a step in a given direction is equal to the probability that the <strong klass>Walker</strong> will take a step in any direction.   In other words, if there are four possible steps, there is a 1 in 4 (or 25%) chance the <strong klass>Walker</strong> will take any given step.  With nine possible steps, it’s a 1 in 9 (or 11.1%) chance.</p>

<p><a data-type="indexterm" data-primary=""random number generators"" data-secondary=""uniform number distributions and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""uniform number distributions"">&nbsp;</a></p>

<p>Conveniently, this is how the <strong function>random()</strong> function works.  Processing’s random number generator (which operates behind the scenes) produces what is known as a “uniform” distribution of numbers.   We can test this distribution with a Processing sketch that counts each time a random number is picked and graphs it as the height of a rectangle.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_2_RandomDistribution/_I_2_RandomDistribution.pde">
<img src="imgs/intro/intro_ex02.png" alt="intro ex02"/>
<figcaption/>
</figure>
<p><strong example>Example I.2: Random number distribution</strong></p>

<pre data-type="programlisting" data-code-language="java">// An array to keep track of how often random numbers are picked
int[] randomCounts;

void setup() {
  size(640,240);
  randomCounts = new int[20];
}

void draw() {
  background(255);

  // Pick a random number and increase the count.
  int index = int(random(randomCounts.length));
  randomCounts[index]++;

  stroke(0);
  fill(175);
  int w = width/randomCounts.length;
  //[full] Graphing the results
  for (int x = 0; x &lt; randomCounts.length; x++) {
    rect(x*w,height-randomCounts[x],w-1,randomCounts[x]);
  }
  //[end]
}</pre>

<p>The above screenshot shows the result of the sketch running for a few minutes.   Notice how each bar of the graph differs in height.   Our sample size (i.e. the number of random numbers we’ve picked) is rather small and there are some occasional discrepancies, where certain numbers are picked more often.  Over time, with a good random number generator, this would even out.</p>

<p><a data-type="indexterm" data-primary=""pseudo-random numbers"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random number generators"" data-secondary=""pseudo-random numbers"">&nbsp;</a></p>

<div data-type="note">
<h1>Pseudo-Random Numbers</h1><p>The random numbers we get from the <strong function>random()</strong> function are not truly random; therefore they are known as “pseudo-random.”  They are the result of a mathematical function that simulates randomness.  This function would yield a pattern over time, but that time period is so long that for us, it’s just as good as pure randomness!</p>
</div>
<div id="intro_exercise1" data-type="example">
<h5>Exercise I.1</h5>
<p>Create a random walker that has a tendency to move down and to the right.  (We’ll see the solution to this in the next section.)</p>
</div>
</section>







<section data-type="sect1" id="intro_section3">
<h1>I.3 Probability and Non-Uniform Distributions</h1>
<p><a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""modeling with the random() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""probability and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""probability and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""non-uniform distributions and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random number generators"" data-secondary=""non-uniform distributions" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random() function"" data-secondary=""natural phenomena" data-tertiary="modeling with"">&nbsp;</a></p>

<p>Remember when you first started programming in Processing?  Perhaps you wanted to draw a lot of circles on the screen.  So you said to yourself: “Oh, I know.  I’ll draw all these circles at random locations, with random sizes and random colors.”   In a computer graphics system, it’s often easiest to seed a system with randomness.   In this book, however, we’re looking to build systems modeled on what we see in nature.  Defaulting to randomness is not a particularly thoughtful solution to a design problem—in particular, the kind of problem that involves creating an organic or natural-looking simulation.</p>

<p><a data-type="indexterm" data-primary=""probability of the fittest"">&nbsp;</a></p>

<p>With a few tricks, we can change the way we use <strong function>random()</strong> to produce “non-uniform” distributions of random numbers.    This will come in handy throughout the book as we look at a number of different scenarios.    When we examine genetic algorithms, for example, we’ll need a methodology for performing “selection”—which members of our population should be selected to pass their DNA to the next generation?   Remember the concept of survival of the fittest?    Let’s say we have a population of monkeys evolving.  Not every monkey will have a equal chance of reproducing.  To simulate Darwinian evolution, we can’t simply pick two random monkeys to be parents.  We need the more “fit” ones to be more likely to be chosen.  We need to define the “probability of the fittest.”   For example, a particularly fast and strong monkey might have a 90% chance of procreating, while a weaker one has only a 10% chance.</p>

<p><a data-type="indexterm" data-primary=""probability"">&nbsp;</a></p>

<p>Let&#8217;s pause here and take a look at probability&#8217;s basic principles. First we&#8217;ll examine single event probability, i.e. the likelihood that a given event will occur.</p>

<p>If you have a system with a certain number of possible outcomes, the probability of the occurrence of a given event equals the number of outcomes that qualify as that event divided by the total number of all possible outcomes. A coin toss is a simple example—it has only two possible outcomes, heads or tails. There is only one way to flip heads. The probability that the coin will turn up heads, therefore, is one divided by two: 1/2 or 50%.</p>

<p>Take a deck of fifty-two cards. The probability of drawing an ace from that deck is:</p>

<p><strong formula>number of aces / number of cards = 4 / 52 = 0.077 = ~ 8%</strong></p>

<p>The probability of drawing a diamond is:</p>

<p><strong formula>number of diamonds / number of cards = 13 / 52 = 0.25 = 25%</strong></p>

<p>We can also calculate the probability of multiple events occurring in sequence.  To do this, we simply multiply the individual probabilities of each event.</p>

<p>The probability of a coin turning up heads three times in a row is:</p>

<p><strong formula>(1/2) * (1/2) * (1/2) =  1/8 (or 0.125)</strong></p>

<p>…meaning that a coin will turn up heads three times in a row one out of eight times (each “time” being three tosses).</p>

<div id="intro_exercise2" data-type="example">
<h5>Exercise I.2</h5>
<p>What is the probability of drawing two aces in a row from a deck of fifty-two cards?</p>
</div>

<p><a data-type="indexterm" data-primary=""arrays"" data-secondary=""custom distributions" data-tertiary="creating with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""creating with arrays"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""creating with arrays"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random() function"" data-secondary=""non-uniform distributions" data-tertiary="creating with"">&nbsp;</a></p>

<p>There are a couple of ways in which we can use the <strong function>random()</strong> function with probability in code. One technique is to fill an array with a selection of numbers—some of which are repeated—then choose random numbers from that array and generate events based on those choices.</p>

<pre data-type="programlisting" data-code-language="java">int[] stuff = new int[5];
//[full] 1 is stored in the array twice, making it more likely to be picked.
stuff[0] = 1;
stuff[1] = 1;
//[end]
stuff[2] = 2;
stuff[3] = 3;
stuff[4] = 3;
// Picking a random element from an array
int index = int(random(stuff.length));</pre>

<p>Running this code will produce a 40% chance of printing the value 1, a 20% chance of printing 2, and a 40% chance of printing 3.</p>

<p>We can also ask for a random number (let&#8217;s make it simple and just consider random floating point values between 0 and 1) and allow an event to occur only if our random number is within a certain range.  For example:</p>

<pre data-type="programlisting" data-code-language="java">// A probability of 10%
float prob = 0.10;
// A random floating point value between 0 and 1
float r = random(1);

//[full] If our random number is less than 0.1, try again!
if (r &lt; prob) {
   [inline]// try again!
}
//[end]</pre>

<p>This method can also be applied to multiple outcomes.  Let&#8217;s say that Outcome A has a 60% chance of happening, Outcome B, a 10% chance, and Outcome C, a 30% chance. We implement this in code by picking a random float and seeing into what range it falls.</p>

<ul>
<li>
<p><em>between 0.00 and 0.60 (60%) –&gt; Outcome A</em></p></li>
<li>
<p><em>between 0.60 and 0.70 (10%) –&gt; Outcome B</em></p></li>
<li>
<p><em>between 0.70 and 1.00 (30%) –&gt; Outcome C</em></p></li>
</ul>

<pre data-type="programlisting" data-code-language="java">float num = random(1);

// If random number is less than 0.6
if (num &lt; 0.6) {
  println("Outcome A");
// Between 0.6 and 0.7
} else if (num &lt; 0.7) {
  println("Outcome B");
// Greater than 0.7
} else {
  println("Outcome C");
}</pre>

<p>We could use the above methodology to create a random walker that tends to move to the right.  Here is an example of a <strong klass>Walker</strong> with the following probabilities:</p>

<ul>
<li>
<p><em>chance of moving up:   20%</em></p></li>
<li>
<p><em>chance of moving down:   20%</em></p></li>
<li>
<p><em>chance of moving left:   20%</em></p></li>
<li>
<p><em>chance of moving right:  40%</em></p></li>
</ul>

<figure class="screenshot" data-pde="processingjs/intro/_I_3_RandomWalkTendsToRight/_I_3_RandomWalkTendsToRight.pde processingjs/intro/_I_3_RandomWalkTendsToRight/Walker.pde">
<img src="imgs/intro/intro_ex03.png" alt="intro ex03"/>
<figcaption/>
</figure>
<p><strong example>Example I.3: Walker that tends to move to the right</strong></p>

<pre data-type="programlisting" data-code-language="java">  void step() {

    float r = random(1);
    //[full] A 40% chance of moving to the right!
    if (r &lt; 0.4) {
      x++;
    //[end]
    } else if (r &lt; 0.6) {
      x--;
    } else if (r &lt; 0.8) {
      y++;
    } else {
      y--;
    }
  }</pre>

<div id="intro_exercise3" data-type="example">
<h5>Exercise I.3</h5>
<p>Create a random walker with dynamic probabilities.  For example, can you give it a 50% chance of moving in the direction of the mouse?</p>
</div>
</section>







<section data-type="sect1" id="intro_section4">
<h1>I.4 A Normal Distribution of Random Numbers</h1>
<p>Let’s go back to that population of simulated Processing monkeys.  Your program generates a thousand Monkey objects, each with a height value between 200 and 300 (as this is a world of monkeys that have heights between 200 and 300 pixels).</p>

<pre data-type="programlisting" data-code-language="java">float h = random(200,300);</pre>

<p><a data-type="indexterm" data-primary=""distributions" data-secondary="normal"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""normal distributions"">&nbsp;</a></p>

<p>Does this accurately depict the heights of real-world beings?   Think of a crowded sidewalk in New York City.   Pick any person off the street and it may appear that their height is random.  Nevertheless, it’s not the kind of random that <strong function>random()</strong> produces.   People’s heights are not uniformly distributed; there are a great deal more people of average height than there are very tall or very short ones.   To simulate nature, we may want it to be more likely that our monkeys are of average height (250 pixels), yet still allow them to be, on occasion, very short or very tall.</p>

<p><a data-type="indexterm" data-primary=""bell curve"">&nbsp;</a>
<a data-type="indexterm" data-primary=""bell curve"" data-secondary=""mean and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Gauss" data-secondary="Carl Friedrich"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Gaussian distribution"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Laplace" data-secondary="Pierre-Simon"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Laplacian distribution"">&nbsp;</a>
<a data-type="indexterm" data-primary=""mean"">&nbsp;</a>
<a data-type="indexterm" data-primary=""normal distribution"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""mean"">&nbsp;</a></p>

<p>A distribution of values that cluster around an average (referred to as the “mean”) is known as a “normal” distribution.   It is also called the Gaussian distribution (named for mathematician Carl Friedrich Gauss) or, if you are French, the Laplacian distribution (named for Pierre-Simon Laplace).  Both mathematicians were working concurrently in the early nineteenth century on defining such a distribution.</p>

<p>When you graph the distribution, you get something that looks like the following, informally known as a bell curve:</p>

<figure id="intro_figure2" class="two-col">
<img src="imgs/intro/intro_02.png" alt="Figure I.2"/>
<figcaption/>
</figure>
<figure id="intro_figure3" class="two-col">
<img src="imgs/intro/intro_03.png" alt="Figure I.3"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""mu (μ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""sigma (σ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""standard deviation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""standard deviation"">&nbsp;</a></p>

<p>The curve is generated by a mathematical function that defines the probability of any given value occurring as a function of the mean (often written as μ, the Greek letter <em>mu</em>) and standard deviation (σ, the Greek letter <em>sigma</em>).</p>

<p>The mean is pretty easy to understand.  In the case of our height values between 200 and 300, you probably have an intuitive sense of the mean (i.e. average) as 250. However, what if I were to say that the standard deviation is 3 or 15?   What does this mean for the numbers?  The graphs above should give us a hint. The graph on the left shows us the distribution with a very low standard deviation, where the majority of the values cluster closely around the mean.  The graph on the right shows us a higher standard deviation, where the values are more evenly spread out from the average.</p>

<p>The numbers work out as follows: Given a population, 68% of the members of that population will have values in the range of one standard deviation from the mean, 98% within two standard deviations, and 99.7% within three standard deviations.   Given a standard deviation of 5 pixels, only 0.3% of the monkey heights will be less than 235 pixels (three standard deviations below the mean of 250) or greater than 265 pixels (three standard deviations above the mean of 250).</p>

<div data-type="note">
<h1>Calculating Mean and Standard Deviation</h1><p>Consider a class of ten students who receive the following scores (out of 100) on a test:</p>

<p><em>85, 82, 88, 86, 85, 93, 98, 40, 73, 83</em></p>

<p><strong><em>The mean is the average:  81.3</em></strong></p>

<p><a data-type="indexterm" data-primary=""standard deviation"" data-secondary=""calculating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""standard deviation"" data-secondary=""variance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""variance"">&nbsp;</a></p>

<p>The standard deviation is calculated as the square root of the average of the squares of deviations around the mean. In other words, take the difference from the mean for each person and square it (variance). Calculate the average of all these values and take the square root as the standard deviation.</p>

<table>

<thead>
<tr>
<th>Score</th>
<th>Difference from Mean</th>
<th>Variance</th>
</tr>
</thead>
<tfoot>
<tr>
<td></td>
<td><p><strong>Average Variance:</strong></p></td>
<td><p>254.23</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td><p>85</p></td>
<td><p>85-81.3 = 3.7</p></td>
<td><p>(3.7)<sup>2</sup> = 13.69</p></td>
</tr>
<tr>
<td><p>40</p></td>
<td><p>40-81.3 = -41.3</p></td>
<td><p>(-41.3)<sup>2</sup> = 1705.69</p></td>
</tr>
<tr>
<td><p>etc.</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p><strong><em>The standard deviation is the square root of the average variance:  15.13</em></strong></p>
</div>
<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""Random class"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Random class (Processing)"">&nbsp;</a></p>

<p>Luckily for us, to use a normal distribution of random numbers in a Processing sketch, we don’t have to do any of these calculations ourselves.   Instead, we can make use of a class known as <strong klass>Random</strong>, which we get for free as part of the default Java libraries imported into Processing (see <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Random.html">the JavaDocs</a> for more information).</p>

<p>To use the <strong klass>Random</strong> class, we must first declare a variable of type <strong klass>Random</strong> and create the <strong klass>Random</strong> object in <strong function>setup()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// We use the variable name “generator” because what we
// have here can be thought of as a random number generator.
Random generator;

void setup() {
  size(640,360);
  generator = new Random();
}</pre>

<p><a data-type="indexterm" data-primary=""nextGaussian() function (Random class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Random class (Processing)"" data-secondary=""nextGaussian() function"">&nbsp;</a></p>

<p>If we want to produce a random number with a normal (or Gaussian) distribution each time we run through <strong function>draw()</strong>, it’s as easy as calling the function <strong function>nextGaussian()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  // Asking for a Gaussian random number. (Note nextGaussian() returns a double and must be converted to float.)
  float num = (float) generator.nextGaussian();
}</pre>

<p>Here’s the thing.  What are we supposed to do with this value?  What if we wanted to use it, for example, to assign the x-position of a shape we draw on screen?</p>

<p><a data-type="indexterm" data-primary=""nextGaussian() function (Random class)"" data-secondary=""default mean/standard deviation settings of"">&nbsp;</a></p>

<p>The <strong function>nextGaussian()</strong> function returns a normal distribution of random numbers with the following parameters: <em>a mean of zero</em> and <em>a standard deviation of one</em>.    Let’s say we want a mean of 320 (the center horizontal pixel in a window of width 640) and a standard deviation of 60 pixels.   We can adjust the value to our parameters by multiplying it by the standard deviation and adding the mean.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_4_Gaussian/_I_4_Gaussian.pde">
<img src="imgs/intro/intro_ex04.png" alt="intro ex04"/>
<figcaption/>
</figure>
<p><strong example>Example I.4: Gaussian distribution</strong></p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  // Note that nextGaussian() returns a double.
  float num = (float) generator.nextGaussian();
  float sd = 60;
  float mean = 320;

  // Multiply by the standard deviation and add the mean.
  float x = sd * num + mean;

  noStroke();
  fill(255,10);
  ellipse(x,180,16,16);
}</pre>

<p>By drawing the ellipses on top of each other with some transparency, we can actually see the distribution.  The darkest spot is near the center, where most of the values cluster, but every so often circles are drawn farther to the right or left of the center.</p>

<div id="intro_exercise4" data-type="example">
<h5>Exercise I.4</h5>
<p>Consider a simulation of paint splatter drawn as a collection of colored dots. Most of the paint clusters around a central location, but some dots do splatter out towards the edges.  Can you use a normal distribution of random numbers to generate the locations of the dots?  Can you also use a normal distribution of random numbers to generate a color palette?</p>
</div>

<p><a data-type="indexterm" data-primary=""random walks"" data-secondary=""Gaussian"">&nbsp;</a></p>

<div id="intro_exercise5" data-type="example">
<h5>Exercise I.5</h5>
<p>A Gaussian random walk is defined as one in which the step size (how far the object moves in a given direction) is generated with a normal distribution.  Implement this variation of our random walk.</p>
</div>
</section>







<section data-type="sect1" id="intro_section5">
<h1>I.5 A Custom Distribution of Random Numbers</h1>
<p><a data-type="indexterm" data-primary=""distributions" data-secondary="custom"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Lévy flight"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""custom"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""custom"">&nbsp;</a>
<a data-type="indexterm" data-primary=""oversampling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random number generators"" data-secondary=""custom distributions" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random walks"" data-secondary=""Lévy flight"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random walks"" data-secondary=""oversampling"">&nbsp;</a></p>

<p>There will come a time in your life when you do not want a uniform distribution of random values, or a Gaussian one. Let’s imagine for a moment that you are a random walker in search of food.   Moving randomly around a space seems like a reasonable strategy for finding something to eat.   After all, you don’t know where the food is, so you might as well search randomly until you find it.  The problem, as you may have noticed, is that random walkers return to previously visited locations many times (this is known as “oversampling”).   One strategy to avoid such a problem is to, every so often, take a very large step.   This allows the walker to forage randomly around a specific location while periodically jumping very far away to reduce the amount of oversampling.   This variation on the random walk (known as a Lévy flight) requires a custom set of probabilities.   Though not an exact implementation of a Lévy flight, we could state the probability distribution as follows: the longer the step, the less likely it is to be picked; the shorter the step, the more likely.</p>

<p>Earlier in this prologue, we saw that we could generate custom probability distributions by filling an array with values (some duplicated so that they would be picked more frequently) or by testing the result of <strong function>random()</strong>.  We could implement a Lévy flight by saying that there is a 1% chance of the walker taking a large step.</p>

<p><a data-type="indexterm" data-primary=""arrays"" data-secondary=""Lévy flights" data-tertiary="implementing with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Lévy flight"" data-secondary=""implementing with arrays"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">float r = random(1);
//[full] A 1% chance of taking a large step
if (r &lt; 0.01) {
  xstep = random(-100,100);
  ystep = random(-100,100);
//[end]
} else {
  xstep = random(-1,1);
  ystep = random(-1,1);
}</pre>

<p><a data-type="indexterm" data-primary=""Lévy flight"" data-secondary=""implementing with qualifying random values"">&nbsp;</a></p>

<p>However, this reduces the probabilities to a fixed number of options.  What if we wanted to make a more general rule—the higher a number, the more likely it is to be picked?  3.145 would be more likely to be picked than 3.144, even if that likelihood is just a tiny bit greater.  In other words, if <strong var>x</strong> is the random number, we could map the likelihood on the y-axis with <strong var>y</strong> = <strong var>x</strong>.</p>

<figure id="intro_figure4">
<img src="imgs/intro/intro_04.png" alt="Figure I.4"/>
<figcaption/>
</figure>
<p>If we can figure out how to generate a distribution of random numbers according to the above graph, then we will be able to apply the same methodology to any curve for which we have a formula.</p>

<p><a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""qualifying random values"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""qualifying random values"">&nbsp;</a>
<a data-type="indexterm" data-primary=""qualifying random values"">&nbsp;</a></p>

<p>One solution is to pick two random numbers instead of one.  The first random number is just that, a random number.  The second one, however, is what we’ll call a “qualifying random value.”  It will tell us whether to use the first one or throw it away and pick another one.  Numbers that have an easier time qualifying will be picked more often, and numbers that rarely qualify will be picked infrequently.   Here are the steps (for now, let’s consider only random values between 0 and 1):</p>

<div style="page-break-after:always;"> </div>
<ol>
<li>
<p>Pick a random number: R1</p></li>
<li>
<p>Compute a probability P that R1 should qualify.  Let’s try: P = R1.</p></li>
<li>
<p>Pick another random number: R2</p></li>
<li>
<p>If R2 is less than P, then we have found our number—R1!</p></li>
<li>
<p>If R2 is not less than P, go back to step 1 and start over.</p></li>
</ol>

<p>Here we are saying that the likelihood that a random value will qualify is equal to the random number itself.  Let’s say we pick 0.1 for R1.  This means that R1 will have a 10% chance of qualifying.  If we pick 0.83 for R1 then it will have a 83% chance of qualifying.  The higher the number, the greater the likelihood that we will actually use it.</p>

<p><a data-type="indexterm" data-primary=""Monte Carlo method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""Monte Carlo method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""Monte Carlo method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""qualifying random values"" data-secondary=""Monte Carlo method"">&nbsp;</a></p>

<p>Here is a function (named for the Monte Carlo method, which was named for the Monte Carlo casino) that implements the above algorithm, returning a random value between 0 and 1.</p>

<pre data-type="programlisting" data-code-language="java">float montecarlo() {
  // We do this “forever” until we find a qualifying random value.
  while (true) {
    // Pick a random value.
    float r1 = random(1);
    // Assign a probability.
    float probability = r1;
    // Pick a second random value.
    float r2 = random(1);

    //[full] Does it qualify?  If so, we’re done!
    if (r2 &lt; probability) {
      return r1;
    }
    //[end]
  }
}</pre>

<div id="intro_exercise6" data-type="example">
<h5>Exercise I.6</h5>
<p>Use a custom probability distribution to vary the size of a step taken by the random walker.   The step size can be determined by influencing the range of values picked.  Can you map the probability exponentially—i.e. making the likelihood that a value is picked equal to the value squared?</p>

<pre data-type="programlisting" data-code-language="java">  // A uniform distribution of step sizes. Change this!
  float stepsize = random(0,10);

  float stepx = random(-stepsize,stepsize);
  float stepy = random(-stepsize,stepsize);

  x += stepx;
  y += stepy;</pre>

<p>(Later we’ll see how to do this more efficiently using vectors.)</p>
</div>
</section>







<section data-type="sect1" id="intro_section6">
<h1>I.6 Perlin Noise (A Smoother Approach)</h1>
<p><a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""Perlin noise and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-uniform distributions"" data-secondary=""Perlin noise"">&nbsp;</a>
<a data-type="indexterm" data-primary=""distributions" data-secondary="non-uniform"" data-tertiary=""Perlin noise"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Perlin noise"" data-secondary=""natural phenomena" data-tertiary="modeling with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""<em>Tron</em> (1982)"">&nbsp;</a></p>

<p>A good random number generator produces numbers that have no relationship and show no discernible pattern. As we are beginning to see, a little bit of randomness can be a good thing when programming organic, lifelike behaviors.  However, randomness as the single guiding principle is not necessarily natural.   An algorithm known as “Perlin noise,” named for its inventor Ken Perlin, takes this concept into account.   Perlin developed the noise function while working on the original <em>Tron</em> movie in the early 1980s; it was designed to create procedural textures for computer-generated effects. In 1997 Perlin won an Academy Award in technical achievement for this work. Perlin noise can be used to generate various effects with natural qualities, such as clouds, landscapes, and patterned textures like marble.</p>

<p><a data-type="indexterm" data-primary=""naturally ordered sequence of numbers"">&nbsp;</a>
<a data-type="indexterm" data-primary=""pseudo-random numbers"" data-secondary=""Perlin noise and"">&nbsp;</a></p>

<p>Perlin noise has a more organic appearance because it produces a naturally ordered (“smooth”) sequence of pseudo-random numbers.    The graph on the left below shows Perlin noise over time, with the x-axis representing time; note the smoothness of the curve. The graph on the right shows pure random numbers over time.  (The code for generating these graphs is available in the accompanying book downloads.)</p>

<figure class="two-col">
<img src="imgs/intro/intro_05.png" alt="Figure I.5: Noise"/>
<figcaption/>
</figure>
<figure class="two-col">
<img src="imgs/intro/intro_06.png" alt="Figure I.6: Random"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""noise() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Perlin noise"" data-secondary=""noise() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""noise() function"">&nbsp;</a></p>

<p>Processing has a built-in implementation of the Perlin noise algorithm: the function <strong function>noise()</strong>.  The <strong function>noise()</strong> function takes one, two, or three arguments, as noise is computed in one, two, or three dimensions.  Let’s start by looking at one-dimensional noise.</p>

<p><a data-type="indexterm" data-primary=""noiseDetail() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""noiseDetail() function"">&nbsp;</a></p>

<div class="note">
<h3 id="noise-detail">Noise Detail</h3>
<p>The Processing <a href="http://processing.org/reference/noise_.html">noise reference</a> tells us that noise is calculated over several “octaves.” Calling the <a href="http://processing.org/reference/noiseDetail_.html"><span class="function">noiseDetail()</span></a> function will change both the number of octaves and their importance relative to one another.  This in turn changes how the noise function behaves.</p>

<p>An online lecture by Ken Perlin lets you learn more about how noise works from <a href="http://www.noisemachine.com/talk1/">Perlin himself</a>.</p>
</div>
<p>Consider drawing a circle in our Processing window at a random x-location.</p>

<pre data-type="programlisting" data-code-language="java">// A random x-location
float x = random(0,width);
ellipse(x,180,16,16);</pre>

<p>Now, instead of a random x-location, we want a Perlin noise x-location that is “smoother.”  You might think that all you need to do is replace <strong function>random()</strong> with <strong function>noise()</strong>, i.e.</p>

<pre data-type="programlisting" data-code-language="java">// A noise x-location?
float x = noise(0,width); //[line-through]</pre>

<p><a data-type="indexterm" data-primary=""noise() function (Processing)"" data-secondary=""arguments for"">&nbsp;</a></p>

<p>While conceptually this is exactly what we want to do—calculate an x-value that ranges between 0 and the width according to Perlin noise—this is not the correct implementation.    While the arguments to the <strong function>random()</strong> function specify a range of values between a minimum and a maximum, <strong function>noise()</strong> does not work this way.  Instead, the output range is fixed—it always returns a value between 0 and 1.  We’ll see in a moment that we can get around this easily with Processing’s <strong function>map()</strong> function, but first we must examine what exactly <strong function>noise()</strong> expects us to pass in as an argument.</p>

<p>We can think of one-dimensional Perlin noise as a linear sequence of values over time.   For example:</p>

<table>

<thead>
<tr>
<th>Time</th>
<th>Noise Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>0.365</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>0.363</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>0.363</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>0.364</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>0.366</p></td>
</tr>
</tbody>
</table>

<p>Now, in order to access a particular noise value in Processing, we have to pass a specific "moment in time" to the <strong function>noise()</strong> function.  For example:</p>

<pre data-type="programlisting" data-code-language="java">float n = noise(3);</pre>

<p>According to the above table, <strong function>noise(3)</strong> will return 0.364 at time equals 3. We could improve this by using a variable for time and asking for a noise value continuously in <strong function>draw()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">float t = 3;

void draw() {
  // We need the noise value for a specific moment in time.
  float n = noise(t);
  println(n);
}</pre>

<p>The above code results in the same value printed over and over.   This happens because we are asking for the result of the <strong function>noise()</strong> function at the same point in time—3—over and over.  If we increment the time variable <strong var>t</strong>, however, we’ll get a different result.</p>

<pre data-type="programlisting" data-code-language="java">// Typically we would start at time = 0, though this is arbitrary.
float t = 0;

void draw() {
  float n = noise(t);
  println(n);
  // Now, we move forward in time!
  t += 0.01;
}</pre>

<p>How quickly we increment <strong var>t</strong> also affects the smoothness of the noise.   If we make large jumps in time, then we are skipping ahead and the values will be more random.</p>

<figure id="intro_figure7">
<img src="imgs/intro/intro_07.png" alt="Figure I.7"/>
<figcaption/>
</figure>
<p>Try running the code several times, incrementing <strong var>t</strong> by 0.01, 0.02, 0.05, 0.1, 0.0001, and you will see different results.</p>





<section data-type="sect2" id="_mapping_noise">
<h2>Mapping Noise</h2>
<p><a data-type="indexterm" data-primary=""map() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Perlin noise"" data-secondary=""map() function"">&nbsp;</a></p>

<p>Now we’re ready to answer the question of what to do with the noise value.   Once we have the value with a range between 0 and 1, it’s up to us to map that range to what we want.   The easiest way to do this is with Processing’s <strong function>map()</strong> function.   The <strong function>map()</strong> function takes five arguments.  First up is the value we want to map, in this case <strong var>n</strong>.  Then we have to give it the value’s current range (minimum and maximum), followed by our desired range.</p>

<figure id="intro_figure8">
<img src="imgs/intro/intro_08.png" alt="Figure I.8"/>
<figcaption/>
</figure>
<p>In this case, we know that noise has a range between 0 and 1, but we’d like to draw our circle with a range between 0 and the window’s width.</p>

<pre data-type="programlisting" data-code-language="java">float t = 0;

void draw() {
  float n = noise(t);
  // Using map() to customize the range of Perlin noise
  float x = map(n,0,1,0,width);
  ellipse(x,180,16,16);

  t += 0.01;
}</pre>

<p>We can apply the exact same logic to our random walker, and assign both its x- and y-values according to Perlin noise.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_5_NoiseWalk/_I_5_NoiseWalk.pde processingjs/intro/_I_5_NoiseWalk/Walker.pde">
<img src="imgs/intro/intro_ex05.png" alt="intro ex05"/>
<figcaption/>
</figure>
<p><strong example>Example I.5: Perlin noise walker</strong></p>

<pre data-type="programlisting" data-code-language="java">class Walker {
  float x,y;

  float tx,ty;

  Walker() {
    tx = 0;
    ty = 10000;
  }

  void step() {
    //[full] x- and y-location mapped from noise
    x = map(noise(tx), 0, 1, 0, width);
    y = map(noise(ty), 0, 1, 0, height);
    //[end]

    //[full] Move forward through “time.”
    tx += 0.01;
    ty += 0.01;
    //[end]
  }
}</pre>

<p>Notice how the above example requires an additional pair of variables: <strong var>tx</strong> and  <strong var>ty</strong>.  This is because we need to keep track of two time variables, one for the x-location of the <strong klass>Walker</strong> object and one for the y-location.   But there is something a bit odd about these variables. Why does <strong var>tx</strong> start at 0 and  <strong var>ty</strong> at 10,000?  While these numbers are arbitrary choices, we have very specifically initialized our two time variables with different values.  This is because the noise function is deterministic: it gives you the same result for a specific time <strong var>t</strong> each and every time.  If we asked for the noise value at the same time <strong var>t</strong> for both <strong var>x</strong> and <strong var>y</strong>, then <strong var>x</strong> and <strong var>y</strong> would always be equal, meaning that the <strong klass>Walker</strong> object would only move along a diagonal.   Instead, we simply use two different parts of the noise space, starting at 0 for <strong var>x</strong> and 10,000 for <strong var>y</strong> so that <strong var>x</strong> and <strong var>y</strong> can appear to act independently of each other.</p>

<figure id="intro_figure9">
<img src="imgs/intro/intro_09.png" alt="Figure I.9"/>
<figcaption/>
</figure>
<p>In truth, there is no actual concept of time at play here.  It’s a useful metaphor to help us understand how the noise function works, but really what we have is space, rather than time.  The graph above depicts a linear sequence of noise values in a one-dimensional space, and we can ask for a value at a specific x-location whenever we want.   In examples, you will often see a variable named <strong var>xoff</strong> to indicate the x-offset along the noise graph, rather than <strong var>t</strong> for time (as noted in the diagram).</p>

<div id="intro_exercise7" data-type="example">
<h5>Exercise I.7</h5>
<p>In the above random walker, the result of the noise function is mapped directly to the <strong klass>Walker</strong><code>’</code>s location.  Create a random walker where you instead map the result of the <strong function>noise()</strong> function to a <strong klass>Walker</strong><code>’</code>s step size.</p>
</div>
</section>







<section data-type="sect2" id="_two_dimensional_noise">
<h2>Two-Dimensional Noise</h2>
<p><a data-type="indexterm" data-primary=""Perlin noise"" data-secondary=""two-dimensional"">&nbsp;</a></p>

<p>This idea of noise values living in a one-dimensional space is important because it leads us right into a discussion of two-dimensional space.  Let’s think about this for a moment.  With one-dimensional noise, we have a sequence of values in which any given value is similar to its neighbor.  Because the value is in one dimension, it only has two neighbors: a value that comes before it (to the left on the graph) and one that comes after it (to the right).</p>

<figure id="intro_figure10" class="two-col-borderless">
<img src="imgs/intro/intro_10.png" alt="Figure I.10: 1D Noise"/>
<figcaption/>
</figure>
<figure id="intro_figure11" class="two-col-borderless">
<img src="imgs/intro/intro_11.png" alt="Figure I.11: 2D Noise"/>
<figcaption/>
</figure>
<p>Two-dimensional noise works exactly the same way conceptually.  The difference of course is that we aren’t looking at values along a linear path, but values that are sitting on a grid.  Think of a piece of graph paper with numbers written into each cell.  A given value will be similar to all of its neighbors: above, below, to the right, to the left, and along any diagonal.</p>

<p>If you were to visualize this graph paper with each value mapped to the brightness of a color, you would get something that looks like clouds.  White sits next to light gray, which sits next to gray, which sits next to dark gray, which sits next to black, which sits next to dark gray, etc.</p>

<figure>
<img src="imgs/intro/intro_ex06.png" alt="intro ex06"/>
<figcaption/>
</figure>
<p>This is why noise was originally invented.   You tweak the parameters a bit or play with color to make the resulting image look more like marble or wood or any other organic texture.</p>

<p>Let’s take a quick look at how to implement two-dimensional noise in Processing.  If you wanted to color every pixel of a window randomly, you would need a nested loop, one that accessed each pixel and picked a random brightness.</p>

<pre data-type="programlisting" data-code-language="java">loadPixels();
for (int x = 0; x &lt; width; x++) {
  for (int y = 0; y &lt; height; y++) {
    // A random brightness!
    float bright = random(255);
    pixels[x+y*width] = color(bright);
  }
}
updatePixels();</pre>

<p>To color each pixel according to the <strong function>noise()</strong> function, we’ll do exactly the same thing, only instead of calling <strong function>random()</strong> we’ll call <strong function>noise()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">   // A Perlin noise brightness!
   float bright = map(noise(x,y),0,1,0,255); //[bold]</pre>

<p>This is a nice start conceptually—it gives you a noise value for every (<strong var>x</strong>,<strong var>y</strong>) location in our two-dimensional space.  The problem is that this won’t have the cloudy quality we want.  Jumping from pixel 200 to pixel 201 is too large of a jump through noise.  Remember, when we worked with one-dimensional noise, we incremented our time variable by 0.01 each frame, not by 1!    A pretty good solution to this problem is to just use different variables for the noise arguments.  For example, we could increment a variable called <strong var>xoff</strong> each time we move horizontally, and a <strong var>yoff</strong> variable each time we move vertically through the nested loops.</p>

<p><strong example>Example I.6: 2D Perlin noise</strong></p>

<pre data-type="programlisting" data-code-language="java">// Start xoff at 0.
float xoff = 0.0; //[bold]

for (int x = 0; x &lt; width; x++) {
  // For every xoff, start yoff at 0.
  float yoff = 0.0; //[bold]

  for (int y = 0; y &lt; height; y++) {
    // Use xoff and yoff for noise().
    float bright = map(noise(xoff,yoff),0,1,0,255); //[bold]
    // Use x and y for pixel location.
    pixels[x+y*width] = color(bright);
    // Increment yoff.
    yoff += 0.01; //[bold]
  }
  // Increment xoff.
  xoff += 0.01;  //[bold]
}</pre>

<div id="intro_exercise8" data-type="example">
<h5>Exercise I.8</h5>
<p>Play with color, <strong function>noiseDetail()</strong>, and the rate at which <strong var>xoff</strong> and <strong var>yoff</strong> are incremented to achieve different visual effects.</p>
</div>

<div id="intro_exercise9" data-type="example">
<h5>Exercise I.9</h5>
<p>Add a third argument to noise that increments once per cycle through <strong function>draw()</strong> to animate the two-dimensional noise.</p>
</div>

<div id="intro_exercise10" data-type="example">
<h5>Exercise I.10</h5>
<p>Use the noise values as the elevations of a landscape.  See the screenshot below as a reference.</p>

<figure>
<img src="imgs/intro/intro_exc10.png" alt="intro exc10"/>
<figcaption/>
</figure></div>

<p>We’ve examined several traditional uses of Perlin noise in this section.  With one-dimensional noise, we used smooth values to assign the location of an object to give the appearance of wandering.  With two-dimensional noise, we created a cloudy pattern with smoothed values on a plane of pixels.  It’s important to remember, however, that Perlin noise values are just that—values.  They aren’t inherently tied to pixel locations or color.  Any example in this book that has a variable could be controlled via Perlin noise.  When we model a wind force, its strength could be controlled by Perlin noise.  Same goes for the angles between the branches in a fractal tree pattern, or the speed and direction of objects moving along a grid in a flow field simulation.</p>

<figure id="intro_figure12" class="two-col" data-pde="processingjs/intro/TreeStochasticNoise/TreeStochasticNoise.pde">
<img src="imgs/intro/intro_12.png" alt="Figure I.12: Tree with Perlin noise"/>
<figcaption/>
</figure>
<figure id="intro_figure13" class="two-col" data-pde="processingjs/intro/_6_04_Flowfield/_6_04_Flowfield.pde processingjs/intro/_6_04_Flowfield/FlowField.pde processingjs/intro/_6_04_Flowfield/Vehicle.pde">
<img src="imgs/intro/intro_13.png" alt="Figure I.13: Flow field with Perlin noise"/>
<figcaption/>
</figure></section>


</section>







<section data-type="sect1" id="intro_section7">
<h1>I.7 Onward</h1>
<p>We began this chapter by talking about how randomness can be a crutch.  In many ways, it’s the most obvious answer to the kinds of questions we ask continuously—how should this object move? What color should it be?  This obvious answer, however, can also be a lazy one.</p>

<p>As we finish off the introduction, it’s also worth noting that we could just as easily fall into the trap of using Perlin noise as a crutch.   How should this object move? Perlin noise!  What color should it be?  Perlin noise!  How fast should it grow?  Perlin noise!</p>

<p>The point of all of this is not to say that you should or shouldn&#8217;t use randomness.  Or that you should or shouldn&#8217;t use Perlin noise.   The point is that the rules of your system are defined by you, and the larger your toolbox, the more choices you’ll have as you implement those rules.   The goal of this book is to fill your toolbox.  If all you know is random, then your design thinking is limited.  Sure, Perlin noise helps, but you’ll need more.  A lot more.</p>

<p>I think we’re ready to begin.</p>

<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_1_vectors">
<h1>Chapter 1.  Vectors</h1>
<blockquote data-type="epigraph"><p>“Roger, Roger. What&#8217;s our vector, Victor?”</p>
<p data-type="attribution">&#8212; — Captain Oveur (Airplane)</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""vectors"">&nbsp;</a></p>

<p>This book is all about looking at the world around us and coming up with clever ways to simulate that world with code.  Divided into three parts, the book will start by looking at basic physics—how an apple falls from a tree, a pendulum swings in the air, the earth revolves around the sun, etc.  Absolutely everything contained within the first five chapters of this book requires the use of the most basic building block for programming motion—the <strong><em>vector</em></strong>.   And so this is where we begin our story.</p>

<p><a data-type="indexterm" data-primary=""Euclid"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Euclidean vector"">&nbsp;</a>
<a data-type="indexterm" data-primary=""geometric vector"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""defined"">&nbsp;</a></p>

<p>Now, the word vector can mean a lot of different things. Vector is the name of a New Wave rock band formed in Sacramento, CA in the early 1980s.  It’s the name of a breakfast cereal manufactured by Kellogg’s Canada.   In the field of epidemiology, a vector is used to describe an organism that transmits infection from one host to another.  In the C++ programming language, a vector (std::vector) is an implementation of a dynamically resizable array data structure.  While all these definitions are interesting, they’re not what we&#8217;re looking for.   What we want is called a <strong><em>Euclidean vector</em></strong> (named for the Greek mathematician Euclid and also known as a geometric vector).  When you see the term “vector” in this book, you can assume it refers to a Euclidean vector, defined as <em>an entity that has both magnitude and direction</em>.</p>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""notation"">&nbsp;</a></p>

<p>A vector is typically drawn as a arrow; the direction is indicated by where the arrow is pointing, and the magnitude by the length of the arrow itself.</p>

<figure id="chapter01_figure1">
<img src="imgs/chapter01/ch01_01.png" alt="Figure 1.1: A vector (drawn as an arrow) has magnitude (length of arrow) and direction (which way it is pointing)."/>
<figcaption/>
</figure>
<p>In the above illustration, the vector is drawn as an arrow from point A to point B and serves as an instruction for how to travel from A to B.</p>




<section data-type="sect1" id="chapter01_section1">
<h1>1.1 Vectors, You Complete Me</h1>
<p><a data-type="indexterm" data-primary=""bouncing ball sketch"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""bouncing ball sketch"">&nbsp;</a></p>

<p>Before we dive into more of the details about vectors, let’s look at a basic Processing example that demonstrates why we should care about vectors in the first place.  If you’ve read any of the introductory Processing textbooks or taken a class on programming with Processing (and hopefully you’ve done one of these things to help prepare you for this book), you probably, at one point or another, learned how to write a simple bouncing ball sketch.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_1_bouncingball_novectors/_1_1_bouncingball_novectors.pde">
<img src="imgs/chapter01/ch01_ex01.png" alt="If you are reading this book as a PDF or in print, then you will only see screenshots of the code.  Motion, of course, is a key element of our discussion, so to the extent possible, the static screenshots will include trails to give a sense of the behavior. For more about how to draw trails, see the code examples available for download."/>
<figcaption/>
</figure>
<p><strong example>Example 1.1: Bouncing ball with no vectors</strong></p>

<pre data-type="programlisting" data-code-language="java">//[full] Variables for location and speed of ball.
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;
//[end]

//[full] Remember how Processing works?  setup() is executed once when the sketch starts and draw() loops forever and ever (until you quit).
void setup() {
  size(640,360);
  background(255);
}
//[end]

void draw() {
  background(255);

  //[full] Move the ball according to its speed.
  x = x + xspeed;
  y = y + yspeed;
  //[end]

  //[full] Check for bouncing.
  if ((x &gt; width) || (x &lt; 0)) {
    xspeed = xspeed * -1;
  }
  if ((y &gt; height) || (y &lt; 0)) {
    yspeed = yspeed * -1;
  }
  //[end]

  stroke(0);
  fill(175);
  // Display the ball at the location (x,y).
  ellipse(x,y,16,16);
}</pre>

<p>In the above example, we have a very simple world—a blank canvas with a circular shape (a “ball”) traveling around.  This ball has some properties, which are represented in the code as variables.</p>

<div data-type="note">
<dl>
<dt>Location</dt>
<dd>
<p><em>x and y</em></p>
</dd>
<dt>Speed</dt>
<dd>
<p><em>xspeed and yspeed</em></p>
</dd>
</dl>
</div>
<p>In a more advanced sketch, we could imagine having many more variables:</p>

<div data-type="note">
<dl>
<dt>Acceleration</dt>
<dd>
<p><em>xacceleration and yacceleration</em></p>
</dd>
<dt>Target location</dt>
<dd>
<p><em>xtarget and ytarget</em></p>
</dd>
<dt>Wind</dt>
<dd>
<p><em>xwind and ywind</em></p>
</dd>
<dt>Friction</dt>
<dd>
<p><em>xfriction and yfriction</em></p>
</dd>
</dl>
</div>
<p>It’s becoming clearer that for every concept in this world (wind, location, acceleration, etc.), we&#8217;ll need two variables.  And this is only a two-dimensional world. In a 3D world, we’ll need <strong var>x</strong>, <strong var>y</strong>, <strong var>z</strong>, <strong var>xspeed</strong>, <strong var>yspeed</strong>, <strong var>zspeed</strong>, and so on.</p>

<p>Wouldn’t it be nice if we could simplify our code and use fewer variables?</p>

<p>Instead of:</p>

<pre data-type="programlisting" data-code-language="java">float x;
float y;
float xspeed;
float yspeed;</pre>

<p>We could simply have&#8230;</p>

<pre data-type="programlisting" data-code-language="java">Vector location;
Vector speed;</pre>

<p>Taking this first step in using vectors won’t allow us to do anything new.  Just adding vectors won’t magically make your Processing sketches simulate physics. However, they will simplify your code and provide a set of functions for common mathematical operations that happen over and over and over again while programming motion.</p>

<p>As an introduction to vectors, we’re going to live in two dimensions for quite some time (at least until we get through the first several chapters).  All of these examples can be fairly easily extended to three dimensions (and the class we will use—<strong klass>PVector</strong><code>—</code>allows for three dimensions.)  However, it’s easier to start with just two.</p>
</section>







<section data-type="sect1" id="chapter01_section2">
<h1>1.2 Vectors for Processing Programmers</h1>
<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""vectors and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""Processing and"">&nbsp;</a></p>

<p>One way to think of a vector is the difference between two points.   Consider how you might go about providing instructions to walk from one point to another.</p>

<p>Here are some vectors and possible translations:</p>

<figure id="chapter01_figure2">
<img src="imgs/chapter01/ch01_02.png" alt="Figure 1.2"/>
<figcaption/>
</figure>
<div data-type="note">
<dl>
<dt>(-15, 3)</dt>
<dd>
<p><em>Walk fifteen steps west; turn and walk three steps north.</em></p>
</dd>
<dt>(3, 4)</dt>
<dd>
<p><em>Walk three steps east; turn and walk five steps north.</em></p>
</dd>
<dt>(2, -1)</dt>
<dd>
<p><em>Walk two steps east; turn and walk one step south.</em></p>
</dd>
</dl>
</div>
<p>You’ve probably done this before when programming motion.  For every frame of animation (i.e.  a single cycle through Processing’s <strong function>draw()</strong> loop), you instruct each object on the screen to move a certain number of pixels horizontally and a certain number of pixels vertically.</p>

<figure id="chapter01_figure3">
<img src="imgs/chapter01/ch01_03.png" alt="Figure 1.3"/>
<figcaption/>
</figure>
<p>For every frame:</p>

<p><strong><em>new location = velocity applied to current location</em></strong></p>

<p><a data-type="indexterm" data-primary=""locations"" data-secondary=""as vectors"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""locations and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""velocity and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""velocity"" data-secondary=""as vector"">&nbsp;</a></p>

<p>If velocity is a vector (the difference between two points), what is location?   Is it a vector too?  Technically, one might argue that location is not a vector, since it’s not describing how to move from one point to another—it’s simply describing a singular point in space.</p>

<p>Nevertheless, another way to describe a location is the path taken from the origin to reach that location. Hence, a location can be the vector representing the difference between location and origin.</p>

<figure id="chapter01_figure4">
<img src="imgs/chapter01/ch01_04.png" alt="Figure 1.4"/>
<figcaption/>
</figure>
<p>Let’s examine the underlying data for both location and velocity.  In the bouncing ball example, we had the following:</p>

<div data-type="note">
<dl>
<dt>location</dt>
<dd>
<p><em>x,y</em></p>
</dd>
<dt>velocity</dt>
<dd>
<p><em>xspeed,yspeed</em></p>
</dd>
</dl>
</div>
<p>Notice how we are storing the same data for both—two floating point numbers, an <strong var>x</strong> and a <strong var>y</strong>. If we were to write a vector class ourselves, we’d start with something rather basic:</p>

<pre data-type="programlisting" data-code-language="java">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

}</pre>

<p>At its core, a <strong klass>PVector</strong> is just a convenient way to store two values (or three, as we’ll see in 3D examples).</p>

<p>And so this &#8230;</p>

<pre data-type="programlisting" data-code-language="java">float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;</pre>

<p>becomes &#8230;</p>

<pre data-type="programlisting" data-code-language="java">PVector location = new PVector(100,100);
PVector velocity = new PVector(1,3.3);</pre>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""motion" data-tertiary="implementing with"">&nbsp;</a></p>

<p>Now that we have two vector objects (location and velocity), we’re ready to implement the algorithm for motion—<strong><em>location = location + velocity</em></strong>.   In Example 1.1, without vectors, we had:</p>

<pre data-type="programlisting" data-code-language="java">//[full] Add each speed to each location.
x = x + xspeed;
y = y + yspeed;
//[end]</pre>

<p>In an ideal world, we would be able to rewrite the above as:</p>

<pre data-type="programlisting" data-code-language="java">// Add the velocity vector to the location vector.
location = location + velocity;</pre>

<p><a data-type="indexterm" data-primary=""addition operator"">&nbsp;</a></p>

<p>However, in Processing, the addition operator + is reserved for primitive values (integers, floats, etc.) only.  Processing doesn’t know how to add two <strong klass>PVector</strong> objects together any more than it knows how to add two <strong klass>PFont</strong> objects or <strong klass>PImage</strong> objects.   Fortunately for us, the <strong klass>PVector</strong> class includes functions for common mathematical operations.</p>
</section>







<section data-type="sect1" id="chapter01_section3">
<h1>1.3 Vector Addition</h1>
<p><a data-type="indexterm" data-primary=""add() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""adding"">&nbsp;</a></p>

<p>Before we continue looking at the <strong klass>PVector</strong> class and its <strong function>add()</strong> method (purely for the sake of learning since it’s already implemented for us in Processing itself), let’s examine vector addition using the notation found in math and physics textbooks.</p>

<p><a data-type="indexterm" data-primary=""scalar notation" data-secondary="vs. vector notation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vector notation" data-secondary="vs. scalar notation"">&nbsp;</a></p>

<p>Vectors are typically written either in boldface type or with an arrow on top.  For the purposes of this book, to distinguish a <strong><em>vector</em></strong> from a <strong><em>scalar</em></strong> (<em>scalar</em> refers to a single value, such as an integer or a floating point number), we’ll use the arrow notation:</p>

<ul>
<li>
<p>Vector: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi>u</mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover></mstyle></math></p></li>
<li>
<p>Scalar: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>x </mi></mstyle></math></p></li>
</ul>

<p>Let’s say I have the following two vectors:</p>

<figure id="chapter01_figure5">
<img src="imgs/chapter01/ch01_05.png" alt="Figure 1.5"/>
<figcaption/>
</figure>
<p>Each vector has two components, an <strong var>x</strong> and a <strong var>y</strong>.  To add two vectors together, we simply add both <strong var>x</strong><code>’</code>s and both <strong var>y</strong><code>’</code>s.</p>

<figure id="chapter01_figure6">
<img src="imgs/chapter01/ch01_06.png" alt="Figure 1.6"/>
<figcaption/>
</figure>
<p>In other words:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi>w </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover><mo>= </mo><mover><mrow><mi>u </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover><mo>+ </mo><mover><mrow><mi>v </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover></mstyle></math></p>

<p>can be written as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> + </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> x </mi></mrow></msub></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> + </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> y </mi></mrow></msub></mstyle></math></p>

<p>Then, replacing <strong var>u</strong> and <strong var>v</strong> with their values from Figure 1.6, we get:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><mn> 5 </mn><mo> + </mo><mn> 3 </mn></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><mn> 2 </mn><mo> + </mo><mn> 4 </mn></mstyle></math></p>

<p>which means that:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><mn> 8 </mn></mstyle></math>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><mn> 6 </mn></mstyle></math></p>

<p>Finally, we write that as a vector:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mfenced><mrow><mn> 8 </mn><mo> , </mo><mn> 6 </mn></mrow></mfenced></mstyle></math></p>

<p><a data-type="indexterm" data-primary=""add() function (PVector class)"" data-secondary=""implementation of"">&nbsp;</a></p>

<p>Now that we understand how to add two vectors together, we can look at how addition is implemented in the <strong klass>PVector</strong> class itself.  Let’s write a function called <strong function>add()</strong> that takes another <strong klass>PVector</strong> object as its argument.</p>

<pre data-type="programlisting" data-code-language="java">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

  //[full] New! A function to add another PVector to this PVector.  Simply add the &lt;em&gt;x&lt;/em&gt; components and the &lt;em&gt;y&lt;/em&gt; components together.
  void add(PVector v) { //[bold]
    y = y + v.y; //[bold]
    x = x + v.x; //[bold]
  } //[bold]
  //[end]
}</pre>

<p><a data-type="indexterm" data-primary=""bouncing ball sketch"" data-secondary=""implementing with vectors"">&nbsp;</a></p>

<p>Now that we see how <strong function>add()</strong> is written inside of <strong klass>PVector</strong>, we can return to our bouncing ball example with its <strong><em>location + velocity</em></strong> algorithm and implement vector addition:</p>

<pre data-type="programlisting" data-code-language="java">// Add the current velocity to the location.
location = location + velocity; //[line-through]
location.add(velocity);</pre>

<p>And here we are, ready to rewrite the bouncing ball example using <strong klass>PVector</strong>.</p>

<p><a data-type="indexterm" data-primary=""dot syntax"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""dot syntax"">&nbsp;</a></p>

<p><strong example>Example 1.2: Bouncing ball with PVectors!</strong></p>

<pre data-type="programlisting" data-code-language="java">//[full] Instead of a bunch of floats, we now just have two PVector variables.
PVector location; //[bold]
PVector velocity; //[bold]
//[end]

void setup() {
  size(640,360);
  location = new PVector(100,100); //[bold]
  velocity = new PVector(2.5,5); //[bold]
}

void draw() {
  background(255);

  location.add(velocity); //[bold]
  //[full] We still sometimes need to refer to the individual components of a PVector and can do so using the dot syntax: location.x, velocity.y, etc.
  if ((location.x &gt; width) || (location.x &lt; 0)) { //[bold]
    velocity.x = velocity.x * -1; //[bold]
  } //[bold]
  if ((location.y &gt; height) || (location.y &lt; 0)) { //[bold]
    velocity.y = velocity.y * -1; //[bold]
  } //[bold]
  //[end]

  stroke(0);
  fill(175);
  ellipse(location.x,location.y,16,16); //[bold]
}</pre>

<p>Now, you might feel somewhat disappointed.  After all, this may initially appear to have made the code more complicated than the original version.  While this is a perfectly reasonable and valid critique, it’s important to understand that we haven’t fully realized the power of programming with vectors just yet.   Looking at a simple bouncing ball and only implementing vector addition is just the first step.  As we move forward into a more complex world of multiple objects and multiple <strong><em>forces</em></strong> (which we&#8217;ll introduce in Chapter 2), the benefits of <strong klass>PVector</strong> will become more apparent.</p>

<p>We should, however, note an important aspect of the above transition to programming with vectors.  Even though we are using <strong klass>PVector</strong> objects to describe two values—the <strong var>x</strong> and <strong var>y</strong> of location and the <strong var>x</strong> and <strong var>y</strong> of velocity—we still often need to refer to the <em>x</em> and <em>y</em> components of each <strong klass>PVector</strong> individually.  When we go to draw an object in Processing, there’s no means for us to say:</p>

<pre data-type="programlisting" data-code-language="java">ellipse(location,16,16); //[line-through]</pre>

<p>The <strong function>ellipse()</strong> function does not allow for a <strong klass>PVector</strong> as an argument.  An ellipse can only be drawn with two scalar values, an <strong var>x</strong>-coordinate and a <strong var>y</strong>-coordinate.  And so we must dig into the <strong klass>PVector</strong> object and pull out the <em>x</em> and <em>y</em> components using object-oriented dot syntax.</p>

<pre data-type="programlisting" data-code-language="java">ellipse(location.x,location.y,16,16);</pre>

<p>The same issue arises when testing if the circle has reached the edge of the window, and we need to access the individual components of both vectors: <strong var>location</strong> and <strong var>velocity</strong>.</p>

<pre data-type="programlisting" data-code-language="java">if ((location.x &gt; width) || (location.x &lt; 0)) {
  velocity.x = velocity.x * -1;
}</pre>

<div id="chapter01_exercise1" data-type="example">
<h5>Exercise 1.1</h5>
<p>Find something you’ve previously made in Processing using separate <strong var>x</strong> and <strong var>y</strong> variables and use <strong klass>PVector</strong><code>s</code> instead.</p>
</div>

<div id="chapter01_exercise2" data-type="example">
<h5>Exercise 1.2</h5>
<p>Take one of the walker examples from the introduction and convert it to use <strong klass>PVector</strong><code>s</code>.</p>
</div>

<div id="chapter01_exercise3" data-type="example">
<h5>Exercise 1.3</h5>
<p>Extend the bouncing ball with vectors example into 3D.  Can you get a sphere to bounce around a box?</p>
</div>
</section>







<section data-type="sect1" id="chapter01_section4">
<h1>1.4 More Vector Math</h1>
<p>Addition was really just the first step.   There are many mathematical operations that are commonly used with vectors.   Below is a comprehensive list of the operations available as functions in the <strong klass>PVector</strong> class.  We’ll go through a few of the key ones now.  As our examples get more sophisticated in later chapters, we’ll continue to reveal the details of more functions.</p>

<p><a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""mathematical functions for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""angleBetween() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""cross() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""dist() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""dot() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""heading() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""lerp() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""limit() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""function list for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random2D() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""random3D() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""rotate() function (PVector class)"">&nbsp;</a></p>

<ul>
<li>
<p><strong function>add()</strong> — add vectors</p></li>
<li>
<p><strong function>sub()</strong> — subtract vectors</p></li>
<li>
<p><strong function>mult()</strong> — scale the vector with multiplication</p></li>
<li>
<p><strong function>div()</strong> — scale the vector with division</p></li>
<li>
<p><strong function>mag()</strong> — calculate the magnitude of a vector</p></li>
<li>
<p><strong function>setMag()</strong> - set the magnitude of a vector</p></li>
<li>
<p><strong function>normalize()</strong> — normalize the vector to a unit length of 1</p></li>
<li>
<p><strong function>limit()</strong> — limit the magnitude of a vector</p></li>
<li>
<p><strong function>heading()</strong> — the 2D heading of a vector expressed as an angle</p></li>
<li>
<p><strong function>rotate()</strong> — rotate a 2D vector by an angle</p></li>
<li>
<p><strong function>lerp()</strong> — linear interpolate to another vector</p></li>
<li>
<p><strong function>dist()</strong> — the Euclidean distance between two vectors (considered as points)</p></li>
<li>
<p><strong function>angleBetween()</strong> — find the angle between two vectors</p></li>
<li>
<p><strong function>dot()</strong> — the dot product of two vectors</p></li>
<li>
<p><strong function>cross()</strong> — the cross product of two vectors (only relevant in three dimensions)</p></li>
<li>
<p><strong function>random2D()</strong> - make a random 2D vector</p></li>
<li>
<p><strong function>random3D()</strong> - make a random 3D vector</p></li>
</ul>

<p>Having already covered addition, let’s start with subtraction.  This one’s not so bad; just take the plus sign and replace it with a minus!</p>





<section data-type="sect2" id="_vector_subtraction">
<h2>Vector subtraction</h2>
<p><a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""sub() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""sub() function (PVector class)"">&nbsp;</a></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi>w </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover><mo>= </mo><mover><mrow><mi>u </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover><mo>- </mo><mover><mrow><mi>v </mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover></mstyle></math></p>

<p>can be written as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> - </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> x </mi></mrow></msub></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> - </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> y </mi></mrow></msub></mstyle></math></p>

<figure id="chapter01_figure7">
<img src="imgs/chapter01/ch01_07.png" alt="Figure 1.7: Vector Subtraction"/>
<figcaption/>
</figure>
<p>and so the function inside <strong klass>PVector</strong> looks like:</p>

<pre data-type="programlisting" data-code-language="java">  void sub(PVector v) {
    x = x - v.x;
    y = y - v.y;
  }</pre>

<p>The following example demonstrates vector subtraction by taking the difference between two points—the mouse location and the center of the window.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_3_vector_subtraction/_1_3_vector_subtraction.pde">
<img src="imgs/chapter01/ch01_ex03.png" alt="ch01 ex03"/>
<figcaption/>
</figure>
<p><strong example>Example 1.3: Vector subtraction</strong></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
}

void draw() {
  background(255);
  //[full] Two PVectors, one for the mouse location and one for the center of the window
  PVector mouse  = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  //[end]
  // PVector subtraction!
  mouse.sub(center);
    // Draw a line to represent the vector.
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);
}</pre>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""commutative/associative rules of addition/subtraction with"">&nbsp;</a></p>

<div data-type="note">
<h1>Basic Number Properties with Vectors</h1><p>Addition with vectors follow the same algebraic rules as with real numbers.</p>

<p><strong><em>The commutative rule:</em></strong>  <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math><br/>
<strong><em>The associative rule:</em></strong>  <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mfenced><mrow><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced><mo> = </mo><mfenced><mrow><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced><mo> + </mo><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math></p>

<p>Fancy terminology and symbols aside, this is really quite a simple concept.  We’re just saying that common sense properties of addition apply to vectors as well.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 3 </mn><mo> + </mo><mn> 2 </mn><mo> = </mo><mn> 2 </mn><mo> + </mo><mn> 3 </mn></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mn> 3 </mn><mo> + </mo><mn> 2 </mn></mrow></mfenced><mo> + </mo><mn> 1 </mn><mo> = </mo><mn> 3 </mn><mo> + </mo><mfenced><mrow><mn> 2 </mn><mo> + </mo><mn> 1 </mn></mrow></mfenced></mstyle></math></p>
</div></section>







<section data-type="sect2" id="_vector_multiplication">
<h2>Vector multiplication</h2>
<p><a data-type="indexterm" data-primary=""mult() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""mult() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""multiplying"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""scaling"">&nbsp;</a></p>

<p>Moving on to multiplication, we have to think a little bit differently.  When we talk about multiplying a vector, what we typically mean is <strong><em>scaling</em></strong> a vector.  If we wanted to scale a vector to twice its size or one-third of its size (leaving its direction the same), we would say: “Multiply the vector by 2” or “Multiply the vector by 1/3.”   Note that we are multiplying a vector by a scalar, a single number, not another vector.</p>

<p>To scale a vector, we multiply each component (<strong var>x</strong> and <strong var>y</strong>) by a scalar.</p>

<figure id="chapter01_figure8" class="half-width-right">
<img src="imgs/chapter01/ch01_08.png" alt="Figure 1.8: Scaling a vector"/>
<figcaption/>
</figure>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> * </mo><mi> n </mi></mstyle></math></p>

<p>can be written as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> * </mo><mi> n </mi></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><msub><mrow><mi> u </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> * </mo><mi> n </mi></mstyle></math></p>

<p>Let’s look at an example with vector notation.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mfenced><mrow><mo> - </mo><mn> 3 </mn><mo> , </mo><mn> 7 </mn></mrow></mfenced></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> n </mi><mo> = </mo><mn> 3 </mn></mstyle></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> * </mo><mi> n </mi></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> = </mo><mo> - </mo><mn> 3 </mn><mo> * </mo><mn> 3 </mn></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> w </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> = </mo><mn> 7 </mn><mo> * </mo><mn> 3 </mn></mstyle></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> w </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mfenced><mrow><mo> - </mo><mn> 9 </mn><mo> , </mo><mn> 21 </mn></mrow></mfenced></mstyle></math></p>

<p>Therefore, the function inside the <strong klass>PVector</strong> class is written as:</p>

<pre data-type="programlisting" data-code-language="java">void mult(float n) {
   //[full] With multiplication, the components of the vector are multiplied by a number.
   x = x * n;
   y = y * n;
   //[end]
 }</pre>

<p>And implementing multiplication in code is as simple as:</p>

<p><a data-type="indexterm" data-primary=""mult() function (PVector class)"" data-secondary=""implementation"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">PVector u = new PVector(-3,7);
// This PVector is now three times the size and is equal to (-9,21).
u.mult(3);</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_4_vector_multiplication/_1_4_vector_multiplication.pde">
<img src="imgs/chapter01/ch01_ex04.png" alt="ch01 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 1.4: Multiplying a vector</strong></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).
  mouse.mult(0.5);

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</pre>

<figure id="chapter01_figure9" class="half-width-right">
<img src="imgs/chapter01/ch01_09.png" alt="Figure 1.9"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""div() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""div() function"">&nbsp;</a></p>

<p>Division works just like multiplication—we simply replace the multiplication sign (asterisk) with the division sign (forward slash).</p>

<pre data-type="programlisting" data-code-language="java">void div(float n) {
  x = x / n;
  y = y / n;
}

PVector u = new PVector(8,-4);
// Dividing a vector!  The vector is now half its original size (divided by 2).
u.div(2);</pre>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""associative/distributive rules for multiplication/division of"">&nbsp;</a></p>

<div data-type="note">
<h1>More Number Properties with Vectors</h1><p>As with addition, basic algebraic rules of multiplication apply to vectors.</p>

<p>The associative rule: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mi> n </mi><mo> * </mo><mi> m </mi></mrow></mfenced><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mi> n </mi><mo> * </mo><mfenced><mrow><mi> m </mi><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced></mstyle></math><br/>
The distributive rule with 2 scalars, 1 vector: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mi> n </mi><mo> * </mo><mi> m </mi></mrow></mfenced><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mi> n </mi><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mi> m </mi><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math><br/>
The distributive rule with 2 vectors, 1 scalar: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> + </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced><mo> * </mo><mi> n </mi><mo> = </mo><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> * </mo><mi> n </mi><mo> + </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> * </mo><mi> n </mi></mstyle></math></p>
</div></section>


</section>







<section data-type="sect1" id="chapter01_section5">
<h1>1.5 Vector Magnitude</h1>
<p><a data-type="indexterm" data-primary=""magnitude (of vectors)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""magnitude"">&nbsp;</a></p>

<p>Multiplication and division, as we just saw, are means by which the length of the vector can be changed without affecting direction.  Perhaps you’re wondering: “OK, so how do I know what the length of a vector is?  I know the components (<strong var>x</strong> and <strong var>y</strong>), but how long (in pixels) is the actual arrow?” Understanding how to calculate the length (also known as <strong><em>magnitude</em></strong>) of a vector is incredibly useful and important.</p>

<div class="image-container half-width-right" >
  <img src="imgs/chapter01/ch01_10.png" alt="Nature of Code Image" />
  <p class="caption">Figure 1.10: The length or “magnitude” of a vector

  <svg:svg xmlns="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" height="12.190371pt" width="8.520000pt" xmlns:svgmath="http://www.grigoriev.ru/svgmath" viewBox="0 -9.600527 8.520000 12.190371"><svg:metadata><svgmath:metrics top="12.1903710937" axis="6.57421875" baseline="2.58984375" bottom="2.44921875"/></svg:metadata><svg:g transform="translate(1.596914, 0.000000)"><svg:text font-size="12.000000" text-anchor="middle" y="0.000000" x="2.663086" font-family="Times New Roman" font-style="italic" fill="black">v</svg:text></svg:g><svg:g transform="translate(0.000000, -8.785137)"><svg:text font-size="8.520000" text-anchor="middle" y="2.828906" x="4.260000" font-family="Times New Roman" fill="black">→</svg:text></svg:g></svg:svg>

  is often written as:

 <svg:svg xmlns="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" height="12.503906pt" width="29.061672pt" xmlns:svgmath="http://www.grigoriev.ru/svgmath" viewBox="0 -9.914062 29.061672 12.503906"><svg:metadata><svgmath:metrics top="12.357421875" axis="6.57421875" baseline="2.58984375" bottom="1.37109375"/></svg:metadata><svg:g transform="translate(0.000000, -3.984375)"><svg:text font-size="12.000000" text-anchor="middle" y="3.468750" x="3.468750" font-family="Lucida Sans Unicode" fill="black">∥</svg:text></svg:g><svg:g transform="translate(10.270836, 0.000000)"><svg:g transform="translate(1.596914, 0.000000)"><svg:text font-size="12.000000" text-anchor="middle" y="0.000000" x="2.663086" font-family="Times New Roman" font-style="italic" fill="black">v</svg:text></svg:g><svg:g transform="translate(0.000000, -8.785137)"><svg:text font-size="8.520000" text-anchor="middle" y="2.828906" x="4.260000" font-family="Times New Roman" fill="black">→</svg:text></svg:g></svg:g><svg:g transform="translate(22.124172, -3.984375)"><svg:text font-size="12.000000" text-anchor="middle" y="3.468750" x="3.468750" font-family="Lucida Sans Unicode" fill="black">∥</svg:text></svg:g></svg:svg>

  </p>
</div>
<p><a data-type="indexterm" data-primary=""Pythagoras"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Pythagorean theorem"">&nbsp;</a></p>

<p>Notice in the above diagram how the vector, drawn as an arrow and two components (<strong var>x</strong> and <strong var>y</strong>), creates a right triangle.  The sides are the components and the hypotenuse is the arrow itself.   We’re very lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras developed a lovely formula to describe the relationship between the sides and hypotenuse of a right triangle.</p>

<figure id="chapter01_figure11" class="half-width-right">
<img src="imgs/chapter01/ch01_11.png" alt="Figure 1.11: The Pythagorean Theorem"/>
<figcaption/>
</figure>
<p>The Pythagorean theorem is <em>a</em> squared plus <em>b</em> squared equals <em>c</em> squared.</p>

<p>Armed with this formula, we can now compute the magnitude of <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi>v</mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover></mstyle></math> as follows:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced open="∥" close="∥"><mrow><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced><mo> = </mo><msqrt><msub><mrow><mi> v </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> * </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> + </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> * </mo><msub><mrow><mi> v </mi></mrow><mrow><mi> y </mi></mrow></msub></msqrt></mstyle></math></p>

<p>or in <strong klass>PVector</strong>:</p>

<pre data-type="programlisting" data-code-language="java">float mag() {
  return sqrt(x*x + y*y);
}</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_5_vector_magnitude/_1_5_vector_magnitude.pde">
<img src="imgs/chapter01/ch01_ex05.png" alt="ch01 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 1.5: Vector magnitude</strong></p>

<p><a data-type="indexterm" data-primary=""mag() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""mag() function"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  //[full] The magnitude (i.e. length) of a vector can be accessed via the mag() function.  Here it is used as the width of a rectangle drawn at the top of the window.
  float m = mouse.mag();
  fill(0);
  rect(0,0,m,10);

  //[end]

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</pre>
</section>







<section data-type="sect1" id="chapter01_section6">
<h1>1.6 Normalizing Vectors</h1>
<p><a data-type="indexterm" data-primary=""normalization"">&nbsp;</a>
<a data-type="indexterm" data-primary=""unit vectors"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""normalization"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""unit vectors"">&nbsp;</a></p>

<p>Calculating the magnitude of a vector is only the beginning.  The magnitude function opens the door to many possibilities, the first of which is <strong><em>normalization</em></strong>.  Normalizing refers to the process of making something “standard” or, well, “normal.”  In the case of vectors, let’s assume for the moment that a standard vector has a length of 1.  To normalize a vector, therefore, is to take a vector of any length and, keeping it pointing in the same direction, change its length to 1, turning it into what is called a <strong><em>unit vector</em></strong>.</p>

<figure id="chapter01_figure12" class="half-width-right">
<img src="imgs/chapter01/ch01_12.png" alt="Figure 1.12"/>
<figcaption/>
</figure>
<p>Since it describes a vector&#8217;s direction without regard to its length, it&#8217;s useful to have the unit vector readily accessible.  We’ll see this come in handy once we start to work with forces in Chapter 2.</p>

<p>For any given vector <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi>u</mi></mrow><mrow><mo>&#x2192;</mo></mrow></mover></mstyle></math>, its unit vector (written as <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math>) is calculated as follows:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover><mo> = </mo><mfrac><mrow><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow><mrow><mfenced open="∥" close="∥"><mrow><mover><mrow><mi> u </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mrow></mfenced></mrow></mfrac></mstyle></math></p>

<p>In other words, to normalize a vector, simply divide each component by its magnitude.  This is pretty intuitive.  Say a vector is of length 5.  Well, 5 divided by 5 is 1.  So, looking at our right triangle, we then need to scale the hypotenuse down by dividing by 5.   In that process the sides shrink, divided by 5 as well.</p>

<p><a data-type="indexterm" data-primary=""normalize() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""normalize() function"">&nbsp;</a></p>

<figure id="chapter01_figure13" class="half-width-right">
<img src="imgs/chapter01/ch01_13.png" alt="Figure 1.13"/>
<figcaption/>
</figure>
<p>In the <strong klass>PVector</strong> class, we therefore write our normalization function as follows:</p>

<pre data-type="programlisting" data-code-language="java">void normalize() {
  float m = mag();
  div(m);
}</pre>

<p>Of course, there’s one small issue.  What if the magnitude of the vector is 0?  We can’t divide by 0!   Some quick error checking will fix that right up:</p>

<pre data-type="programlisting" data-code-language="java">void normalize() {
 float m = mag();
 if (m != 0) {
   div(m);
 }
}</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_6_vector_normalize/_1_6_vector_normalize.pde">
<img src="imgs/chapter01/ch01_ex06.png" alt="ch01 ex06"/>
<figcaption/>
</figure>
<p><strong example>Example 1.6: Normalizing a vector</strong></p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // In this example, after the vector is normalized, it is multiplied by 50 so that it is viewable onscreen. Note that no matter where the mouse is, the vector will have the same length (50) due to the normalization process.
  mouse.normalize();
  mouse.mult(50);
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</pre>
</section>







<section data-type="sect1" id="chapter01_section7">
<h1>1.7 Vector Motion: Velocity</h1>
<p><a data-type="indexterm" data-primary=""motion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""velocity and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""velocity"">&nbsp;</a></p>

<p>All this vector math stuff sounds like something we should know about, but why?  How will it actually help us write code?   The truth of the matter is that we need to have some patience.  It will take some time before the awesomeness of using the <strong klass>PVector</strong> class fully comes to light.  This is actually a common occurrence when first learning a new data structure.   For example, when you first learn about an array, it might seem like much more work to use an array than to just have several variables stand for multiple things.   But that plan quickly breaks down when you need a hundred, or a thousand, or ten thousand things.  The same can be true for <strong klass>PVector</strong>.  What might seem like more work now will pay off later, and pay off quite nicely.  And you don’t have to wait too long, as your reward will come in the next chapter.</p>

<p>For now, however, we want to focus on simplicity.  What does it mean to program motion using vectors?   We’ve seen the beginning of this in <a href="#chapter01_example2">Example 1.2</a><code>:</code> the bouncing ball.   An object on screen has a location (where it is at any given moment) as well as a velocity (instructions for how it should move from one moment to the next).   Velocity is added to location:</p>

<pre data-type="programlisting" data-code-language="java">location.add(velocity);</pre>

<p>And then we draw the object at that location:</p>

<pre data-type="programlisting" data-code-language="java">ellipse(location.x,location.y,16,16);</pre>

<p>This is Motion 101.</p>

<ol>
<li>
<p><strong><em>Add velocity to location</em></strong></p></li>
<li>
<p><strong><em>Draw object at location</em></strong></p></li>
</ol>

<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""OOP online tutorial"">&nbsp;</a></p>

<p>In the bouncing ball example, all of this code happened in Processing’s main tab, within <strong function>setup()</strong> and <strong function>draw()</strong>.   What we want to do now is move towards encapsulating all of the logic for motion inside of a <strong><em>class</em></strong>. This way, we can create a foundation for programming moving objects in Processing.    In <a href="#intro_section2">section I.2 of the introduction</a>, “The Random Walker Class,” we briefly reviewed the basics of object-oriented-programming (“OOP”).   Beyond that short introduction, this book assumes experience with objects and classes in Processing.   If you need a refresher, I encourage you to check out the <a href="http://processing.org/learning/objects/">Processing objects tutorial</a>.</p>

<p>In this case, we’re going to create a generic <strong klass>Mover</strong> class that will describe a thing moving around the screen.  And so we must consider the following two questions:</p>

<ol>
<li>
<p><strong><em>What data does a mover have?</em></strong></p></li>
<li>
<p><strong><em>What functionality does a mover have?</em></strong></p></li>
</ol>

<p>Our Motion 101 algorithm tells us the answers to these questions.  A <strong klass>Mover</strong> object has two pieces of data: <strong var>location</strong> and <strong var>velocity</strong>, which are both <strong klass>PVector</strong> objects.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  PVector location;
  PVector velocity;</pre>

<p>Its functionality is just about as simple.  The <strong klass>Mover</strong> needs to move and it needs to be seen.  We’ll implement these needs as functions named <strong function>update()</strong> and <strong function>display()</strong>.   We’ll put all of our motion logic code in <strong function>update()</strong> and draw the object in <strong function>display()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  void update() {
    // The Mover moves.
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    // The Mover is displayed.
    ellipse(location.x,location.y,16,16);
  }

}</pre>

<p><a data-type="indexterm" data-primary=""class (Processing)"" data-secondary=""constructor"">&nbsp;</a>
<a data-type="indexterm" data-primary=""constructor"">&nbsp;</a></p>

<p>We’ve forgotten one crucial item, however: the object’s <strong><em>constructor</em></strong>.  The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give instructions on how to set up the object.  It always has the same name as the class and is called by invoking the <strong><em>new</em></strong> operator:</p>

<pre data-type="programlisting" data-code-language="java">  Mover m = new Mover();</pre>

<p>In our case, let’s arbitrarily decide to initialize our <strong klass>Mover</strong> object by giving it a random location and a random velocity.</p>

<pre data-type="programlisting" data-code-language="java">  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }</pre>

<p>If object-oriented programming is at all new to you, one aspect here may seem a bit confusing.  After all, we spent the beginning of this chapter discussing the <strong klass>PVector</strong> class.  The <strong klass>PVector</strong> class is the template for making the <strong klass>location</strong> object and the <strong klass>velocity</strong> object.  So what are they doing inside of yet another object, the <strong klass>Mover</strong> object?   In fact, this is just about the most normal thing ever.  An object is simply something that holds data (and functionality).  That data can be numbers (integers, floats, etc.) or other objects!  We’ll see this over and over again in this book.   For example, in <a href="#chapter04_section1">Chapter 4</a> we’ll write a class to describe a system of particles.  That <strong klass>ParticleSystem</strong> object will have as its data a list of <strong klass>Particle</strong> objects&#8230;and each <strong klass>Particle</strong> object will have as its data several <strong klass>PVector</strong> objects!</p>

<p>Let’s finish off the <strong klass>Mover</strong> class by incorporating a function to determine what the object should do when it reaches the edge of the window.  For now let’s do something simple, and just have it wrap around the edges.</p>

<pre data-type="programlisting" data-code-language="java">  void checkEdges() {

    //[full] When it reaches one edge, set location to the other.
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }
    //[end]

  }</pre>

<p>Now that the <strong klass>Mover</strong> class is finished, we can look at what we need to do in our main program.  We first declare a <strong klass>Mover</strong> object:</p>

<pre data-type="programlisting" data-code-language="java">Mover mover;</pre>

<p>Then initialize the mover in <strong function>setup()</strong>:</p>

<pre data-type="programlisting" data-code-language="java">mover = new Mover();</pre>

<p>and call the appropriate functions in <strong function>draw()</strong>:</p>

<pre data-type="programlisting" data-code-language="java">mover.update();
mover.checkEdges();
mover.display();</pre>

<p>Here is the entire example for reference:</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_7_motion101/_1_7_motion101.pde processingjs/chapter01/_1_7_motion101/Mover.pde">
<img src="imgs/chapter01/ch01_ex07.png" alt="ch01 ex07"/>
<figcaption/>
</figure>
<p><strong example>Example 1.7: Motion 101 (velocity)</strong></p>

<pre data-type="programlisting" data-code-language="java">// Declare Mover object.
Mover mover;

void setup() {
  size(640,360);
  // Create Mover object.
  mover = new Mover();
}

void draw() {
  background(255);

  //[full] Call functions on Mover object.
  mover.update();
  mover.checkEdges();
  mover.display();
  //[end]
}

class Mover {

  //[full] Our object has two PVectors: location and velocity.
  PVector location;
  PVector velocity;
  //[end]

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }

  void update() {
    // Motion 101: Location changes by velocity.
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</pre>
</section>







<section data-type="sect1" id="chapter01_section8">
<h1>1.8 Vector Motion: Acceleration</h1>
<p><a data-type="indexterm" data-primary=""acceleration"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""acceleration"">&nbsp;</a>
<a data-type="indexterm" data-primary=""velocity"" data-secondary=""acceleration"">&nbsp;</a></p>

<p>OK. At this point, we should feel comfortable with two things: (1) what a <strong klass>PVector</strong> is and (2) how we use <strong klass>PVector</strong><code>s</code> inside of an object to keep track of its location and movement.  This is an excellent first step and deserves a mild round of applause.   Before standing ovations and screaming fans, however, we need to make one more, somewhat bigger step forward.   After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns.  For more interesting motion, for motion that appears in the real world around us, we need to add one more <strong klass>PVector</strong> to our class—<strong var>acceleration</strong>.</p>

<p>The strict definition of <strong><em>acceleration</em></strong> we’re using here is: <em>the rate of change of velocity</em>.  Let’s think about that definition for a moment.  Is this a new concept?  Not really.  Velocity is defined as <em>the rate of change of location</em>.  In essence, we are developing a “trickle-down” effect.  Acceleration affects velocity, which in turn affects location (for some brief foreshadowing, this point will become even more crucial in the next chapter, when we see how forces affect acceleration, which affects velocity, which affects location).  In code, this reads:</p>

<pre data-type="programlisting" data-code-language="java">velocity.add(acceleration);
location.add(velocity);</pre>

<p>As an exercise, from this point forward, let’s make a rule for ourselves.  Let’s write every example in the rest of this book without ever touching the value of velocity and location (except to initialize them).  In other words, our goal now for programming motion is: Come up with an algorithm for how we calculate acceleration and let the trickle-down effect work its magic.   (In truth, you’ll find reasons to break this rule, but it’s important to illustrate the principles behind our motion algorithm.)  And so we need to come up with some ways to calculate acceleration:</p>





<section data-type="sect2" id="_acceleration_algorithms">
<h2>Acceleration Algorithms!</h2>
<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""algorithms for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""acceleration algorithms"">&nbsp;</a></p>

<ol>
<li>
<p><em>A constant acceleration</em></p></li>
<li>
<p><em>A totally random acceleration</em></p></li>
<li>
<p><em>Acceleration towards the mouse</em></p></li>
</ol>

<p><a data-type="indexterm" data-primary=""acceleration algorithms"" data-secondary=""constant"">&nbsp;</a></p>

<p>Algorithm #1, <em>a constant acceleration</em>, is not particularly interesting, but it is the simplest and will help us begin incorporating acceleration into our code.   The first thing we need to do is add another <strong klass>PVector</strong> to the <strong klass>Mover</strong> class:</p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  PVector location;
  PVector velocity;
  // A new PVector for acceleration
  PVector acceleration;  //[bold]</pre>

<p>And incorporate acceleration into the <strong function>update()</strong> function:</p>

<pre data-type="programlisting" data-code-language="java"> void update() {
    //[full] Our motion algorithm is now two lines of code!
    velocity.add(acceleration); //[bold]
    location.add(velocity);
    //[end]
 }</pre>

<p>We’re almost done.  The only missing piece is initialization in the constructor.</p>

<pre data-type="programlisting" data-code-language="java">  Mover() {</pre>

<p>Let’s start the <strong klass>Mover</strong> object in the middle of the window&#8230;</p>

<pre data-type="programlisting" data-code-language="java">    location = new PVector(width/2,height/2);</pre>

<p>&#8230;with an initial velocity of zero.</p>

<pre data-type="programlisting" data-code-language="java">    velocity = new PVector(0,0);</pre>

<p>This means that when the sketch starts, the object is at rest.  We don’t have to worry about velocity anymore, as we are controlling the object’s motion entirely with acceleration.  Speaking of which, according to Algorithm #1, our first sketch involves constant acceleration.  So let’s pick a value.</p>

<pre data-type="programlisting" data-code-language="java">    acceleration = new PVector(-0.001,0.01);
  }</pre>

<p>Maybe you’re thinking, “Gosh, those values seem awfully small!”   That’s right, they are quite tiny.  It’s important to realize that our acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on our sketch’s frame rate.   And so to keep the magnitude of the velocity vector within a reasonable range, our acceleration values should remain quite small.   We can also help this cause by incorporating the <strong klass>PVector</strong> function <strong function>limit()</strong>.</p>

<p><a data-type="indexterm" data-primary=""limit() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""magnitude (of vectors)"" data-secondary=""limiting"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""limit() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""velocity"" data-secondary=""limiting"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">// The limit() function constrains the magnitude of a vector.
velocity.limit(10);</pre>

<p>This translates to the following:</p>

<p><em>What is the magnitude of velocity?  If it’s less than 10, no worries; just leave it as is.  If it’s more than 10, however, reduce it to 10!</em></p>

<div id="chapter01_exercise4" data-type="example">
<h5>Exercise 1.4</h5>
<p>Write the <strong function>limit()</strong> function for the <strong klass>PVector</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">  void limit(float max) {
    if (_______ &gt; _______) {
      _________();
      ____(max);
    }
  }</pre>
</div>

<p>Let’s take a look at the changes to the <strong klass>Mover</strong> class, complete with <strong function>acceleration</strong> and <strong function>limit()</strong>.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_8_motion101_acceleration/_1_8_motion101_acceleration.pde processingjs/chapter01/_1_8_motion101_acceleration/Mover.pde">
<img src="imgs/chapter01/ch01_ex08.png" alt="ch01 ex08"/>
<figcaption/>
</figure>
<p><strong example>Example 1.8: Motion 101 (velocity and constant acceleration)</strong></p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  PVector location;
  PVector velocity;
  // Acceleration is the key!
  PVector acceleration;
  // The variable topspeed will limit the magnitude of velocity.
  float topspeed;

  Mover() {
    location = new PVector(width/2,height/2);
    velocity = new PVector(0,0);
    acceleration = new PVector(-0.001,0.01);
    topspeed = 10;
  }

  void update() {
    //[full] Velocity changes by acceleration and is limited by topspeed.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    //[end]
    location.add(velocity);
  }

  // display() is the same.
  void display() {}
  // checkEdges() is the same.
  void checkEdges() {}
}</pre>

<div id="chapter01_exercise5" data-type="example">
<h5>Exercise 1.5</h5>
<p>Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.</p>
</div>

<p><a data-type="indexterm" data-primary=""acceleration algorithms"" data-secondary=""random"">&nbsp;</a></p>

<p>Now on to Algorithm #2, <em>a totally random acceleration</em>.  In this case, instead of initializing acceleration in the object’s constructor, we want to pick a new acceleration each cycle, i.e. each time <strong function>update()</strong> is called.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_9_motion101_acceleration/_1_9_motion101_acceleration.pde processingjs/chapter01/_1_9_motion101_acceleration/Mover.pde">
<img src="imgs/chapter01/ch01_ex09.png" alt="ch01 ex09"/>
<figcaption/>
</figure>
<p><strong example>Example 1.9: Motion 101 (velocity and random acceleration)</strong></p>

<pre data-type="programlisting" data-code-language="java">  void update() {

    // The random2D() function will give us a PVector of length 1 pointing in a random direction.
    acceleration = PVector.random2D();

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }</pre>

<p>Because the random vector is a normalized one, we can try scaling it:</p>

<pre>(a) scaling the acceleration to a constant value</pre>

<pre data-type="programlisting" data-code-language="java">acceleration = PVector.random2D();
// Constant
acceleration.mult(0.5); //[bold]</pre>

<pre>(b) scaling the acceleration to a random value</pre>

<pre data-type="programlisting" data-code-language="java">acceleration = PVector.random2D();
// Random
acceleration.mult(random(2)); //[bold]</pre>

<p>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <em>speeding up</em> or <em>slowing down</em> of a moving object, but rather <em>any change</em> in velocity in either magnitude or direction.   Acceleration is used to steer an object, and we’ll see this again and again in future chapters as we begin to program objects that make decisions about how to move about the screen.</p>

<div id="chapter01_exercise6" data-type="example">
<h5>Exercise 1.6</h5>
<p>Referring back to the <a href="#intro_section6">Introduction</a>, implement acceleration according to Perlin noise.</p>
</div>
</section>


</section>







<section data-type="sect1" id="chapter01_section9">
<h1>1.9 Static vs. Non-Static Functions</h1>
<p><a data-type="indexterm" data-primary=""functions"" data-secondary=""static vs. non-static"">&nbsp;</a>
<a data-type="indexterm" data-primary=""methods" data-secondary="static vs. non-static"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""static vs. non-static methods"">&nbsp;</a></p>

<p>Before we get to Algorithm #3 (<em>accelerate towards the mouse</em>), we need to cover one more rather important aspect of working with vectors and the <strong klass>PVector</strong> class: the difference between using <strong><em>static</em></strong> methods and <strong><em>non-static</em></strong> methods.</p>

<p>Forgetting about vectors for a moment, take a look at the following code:</p>

<pre data-type="programlisting" data-code-language="java">float x = 0;
float y = 5;

x = x + y;</pre>

<p>Pretty simple, right?  <strong var>x</strong> has the value of 0, we add <strong var>y</strong> to it, and now <strong var>x</strong> is equal to 5.  We could write the corresponding code pretty easily based on what we’ve learned about <strong klass>PVector</strong>.</p>

<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
v.add(u);</pre>

<p>The vector <strong var>v</strong> has the value of (0,0), we add <strong var>u</strong> to it, and now <strong var>v</strong> is equal to (4,5).  Easy, right?</p>

<p>Let’s take a look at another example of some simple floating point math:</p>

<pre data-type="programlisting" data-code-language="java">float x = 0;
float y = 5;

float z = x + y;</pre>

<p><strong var>x</strong> has the value of 0, we add <strong var>y</strong> to it, and store the result in a new variable <strong var>z</strong>.   The value of <strong var>x</strong> does not change in this example (neither does <strong var>y</strong>)!  This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with floats.   However, it’s not so obvious with mathematical operations in <strong klass>PVector</strong>.  Let’s try to write the code based on what we know so far.</p>

<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
// Don’t be fooled; this is incorrect!!!
PVector w = v.add(u); //[line-through]</pre>

<p>The above might seem like a good guess, but it’s just not the way the <strong klass>PVector</strong> class works.   If we look at the definition of <strong function>add()</strong> . . .</p>

<pre data-type="programlisting" data-code-language="java">void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
 }</pre>

<p>we see that this code does not accomplish our goal.  First, it does not return a new <strong klass>PVector</strong> (the return type is “void”) and second, it changes the value of the <strong klass>PVector</strong> upon which it is called.  In order to add two <strong klass>PVector</strong> objects together and return the result as a new <strong klass>PVector</strong>, we must use the static <strong function>add()</strong> function.</p>

<p><a data-type="indexterm" data-primary=""static functions"">&nbsp;</a></p>

<p>Functions that we call from the class name itself (rather than from a speciﬁc object instance) are known as <strong><em>static functions</em></strong>.   Here are two examples of function calls that assume two <strong klass>PVector</strong> objects, <strong var>v</strong> and <strong var>u</strong>:</p>

<pre data-type="programlisting" data-code-language="java">// Static: called from the class name.
PVector.add(v,u);
// Not static: called from an object instance.
v.add(u);</pre>

<p>Since you can’t write static functions yourself in Processing, you might not have encountered them before.  <strong klass>PVector</strong>'s static functions allow us to perform generic mathematical operations on <strong klass>PVector</strong> objects without having to adjust the value of one of the input <strong klass>PVector</strong><code>s</code>.  Let’s look at how we might write the static version of <strong function>add()</strong>:</p>

<pre data-type="programlisting" data-code-language="java">  //The static version of add allows us to add two PVectors together and assign the result to a new PVector while leaving the original PVectors (v and u above) intact.
  static PVector add(PVector v1, PVector v2) {



    PVector v3 = new PVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }</pre>

<p>There are several differences here:</p>

<ul>
<li>
<p>The function is labeled as <strong><em>static</em></strong>.</p></li>
<li>
<p>The function does not have a <strong><em>void</em></strong> return type, but rather returns a <strong klass>PVector</strong>.</p></li>
<li>
<p>The function creates a new <strong klass>PVector</strong> (<strong var>v3</strong>) and returns the sum of the components of <strong var>v1</strong> and <strong var>v2</strong> in that new <strong klass>PVector</strong>.</p></li>
</ul>

<p>When you call a static function, instead of referencing an actual object instance, you simply reference the name of the class itself.</p>

<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
PVector w = v.add(u); //[line-through]
PVector w = PVector.add(v,u); //[bold]</pre>

<p>The <strong klass>PVector</strong> class has static versions of <strong function>add()</strong>, <strong function>sub()</strong>, <strong function>mult()</strong>, and <strong function>div()</strong>.</p>

<div id="chapter01_exercise7" data-type="example">
<h5>Exercise 1.7</h5>
<p>Translate the following pseudocode to code using static or non-static functions where appropriate.</p>

<ul>
<li>
<p>The <strong klass>PVector</strong> <strong var>v</strong> equals (1,5).</p></li>
<li>
<p>The <strong klass>PVector</strong> <strong var>u</strong> equals <strong var>v</strong> multiplied by 2.</p></li>
<li>
<p>The <strong klass>PVector</strong> <strong var>w</strong> equals <strong var>v</strong> minus <strong var>u</strong>.</p></li>
<li>
<p>Divide the <strong klass>PVector</strong> w by 3.</p></li>
</ul>

<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(1,5);
PVector u = ________._____(__,__);
PVector w = ________._____(__,__);
___________;</pre>
</div>
</section>







<section data-type="sect1" id="chapter01_section10">
<h1>1.10 Interactivity with Acceleration</h1>
<p><a data-type="indexterm" data-primary=""acceleration algorithms"" data-secondary=""interactive"">&nbsp;</a></p>

<figure id="chapter01_figure14" class="half-width-right">
<img src="imgs/chapter01/ch01_14.png" alt="Figure 1.14"/>
<figcaption/>
</figure>
<p>To finish out this chapter, let’s try something a bit more complex and a great deal more useful.  We’ll dynamically calculate an object’s acceleration according to a rule stated in Algorithm #3 — <em>the object accelerates towards the mouse</em>.</p>

<p>Anytime we want to calculate a vector based on a rule or a formula, we need to compute two things: <strong><em>magnitude</em></strong> and <strong><em>direction</em></strong>.  Let’s start with direction.  We know the acceleration vector should point from the object’s location towards the mouse location.  Let’s say the object is located at the point (<strong var>x</strong>,<strong var>y</strong>) and the mouse at (<strong var>mouseX</strong>,<strong var>mouseY</strong>).</p>

<figure id="chapter01_figure15" class="half-width-right">
<img src="imgs/chapter01/ch01_15.png" alt="Figure 1.15"/>
<figcaption/>
</figure>
<p>In Figure 1.15, we see that we can get a vector (<strong var>dx</strong>,<strong var>dy</strong>) by subtracting the object’s location from the mouse’s location.</p>

<ul>
<li>
<p><strong formula>dx = mouseX - x</strong></p></li>
<li>
<p><strong formula>dy = mouseY - y</strong></p></li>
</ul>

<p>Let’s rewrite the above using <strong klass>PVector</strong> syntax.   Assuming we are in the <strong klass>Mover</strong> class and thus have access to the object’s <strong klass>PVector location</strong>, we then have:</p>

<pre data-type="programlisting" data-code-language="java">PVector mouse = new PVector(mouseX,mouseY);
// Look! We’re using the static reference to sub() because we want a new PVector pointing from one point to another.
PVector dir = PVector.sub(mouse,location);</pre>

<p>We now have a <strong klass>PVector</strong> that points from the mover&#8217;s location all the way to the mouse.  If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse location.  This does not make for good animation, of course, and what we want to do now is decide how quickly that object should accelerate toward the mouse.</p>

<p>In order to set the magnitude (whatever it may be) of our acceleration <strong klass>PVector</strong>, we must first <em><em></em><em></em></em><em><em></em><em></em></em><em><em></em><em></em></em><em>_</em> that direction vector.  That’s right, you said it.  <em>Normalize</em>.   If we can shrink the vector down to its unit vector (of length one) then we have a vector that tells us the direction and can easily be scaled to any value.   One multiplied by anything equals anything.</p>

<pre data-type="programlisting" data-code-language="java">float anything = ?????
dir.normalize();
dir.mult(anything);</pre>

<p>To summarize, we take the following steps:</p>

<ol>
<li>
<p>Calculate a vector that points from the object to the target location (mouse)</p></li>
<li>
<p>Normalize that vector (reducing its length to 1)</p></li>
<li>
<p>Scale that vector to an appropriate value (by multiplying it by some value)</p></li>
<li>
<p>Assign that vector to acceleration</p></li>
</ol>

<p>And here are those steps in the <strong function>update()</strong> function itself:</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/chapter01/_1_10_motion101_acceleration/Mover.pde">
<img src="imgs/chapter01/ch01_ex10.png" alt="ch01 ex10"/>
<figcaption/>
</figure>
<p><strong example>Example 1.10: Accelerating towards the mouse</strong></p>

<pre data-type="programlisting" data-code-language="java"> void update() {

    PVector mouse = new PVector(mouseX,mouseY);
    // Step 1: Compute direction
    PVector dir = PVector.sub(mouse,location);

    // Step 2: Normalize
    dir.normalize();

    // Step 3: Scale
    dir.mult(0.5);

    // Step 4: Accelerate
    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);

  }</pre>

<p>You may be wondering why the circle doesn’t stop when it reaches the target.  It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination is and tries to go there as quickly as possible. Going as quickly as possible means it will inevitably overshoot the location and have to turn around, again going as quickly as possible towards the destination, overshooting it again, and so on and so forth.   Stay tuned; in later chapters we’ll learn how to program an object to <strong><em>arrive</em></strong> at a location (slow down on approach).</p>

<p>This example is remarkably close to the concept of gravitational attraction (in which the object is attracted to the mouse location).  Gravitational attraction will be covered in more detail in the next chapter. However, one thing missing here is that the strength of gravity (magnitude of acceleration) is inversely proportional to distance.  This means that the closer the object is to the mouse, the faster it accelerates.</p>

<div id="chapter01_exercise8" data-type="example">
<h5>Exercise 1.8</h5>
<p>Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</p>
</div>

<p>Let’s see what this example would look like with an array of movers (rather than just one).</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_11_motion101_acceleration_array/_1_11_motion101_acceleration_array.pde processingjs/chapter01/_1_11_motion101_acceleration_array/Mover.pde">
<img src="imgs/chapter01/ch01_ex11.png" alt="ch01 ex11"/>
<figcaption/>
</figure>
<p><strong example>Example 1.11: Array of movers accelerating towards the mouse</strong></p>

<pre data-type="programlisting" data-code-language="java">// An array of objects
Mover[] movers = new Mover[20];

void setup() {
  size(640,360);
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    // Initialize each object in the array.
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    //[full] Calling functions on all the objects in the array
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
    //[end]
  }
}

class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    topspeed = 4;
  }

  void update() {

    // &lt;b&gt;&lt;u&gt;Our algorithm for calculating acceleration&lt;/b&gt;&lt;/u&gt;:

    //[full] Find the vector pointing towards the mouse.
    PVector mouse = new PVector(mouseX,mouseY);
    PVector dir = PVector.sub(mouse,location);
    //[end]
    // Normalize.
    dir.normalize();
    // Scale.
    dir.mult(0.5);
    // Set to acceleration.
    acceleration = dir;

    //[full] Motion 101! Velocity changes by acceleration.  Location changes by velocity.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
    //[end]
  }

  // Display the Mover
  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  // What to do at the edges
  void checkEdges() {

    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    }  else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</pre>

<div style="page-break-after:always;"> </div>
<figure id="chapter01_figure16" class="screenshot">
<img src="imgs/chapter01/ch01_16.png" alt="Figure 1.16: The Ecosystem Project"/>
<figcaption/>
</figure>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p><em>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one step at a time.  We’ll follow the development of an example project throughout this book—a simulation of an ecosystem.  Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</em></p>

<p>Step 1 Exercise:</p>

<p>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc.  Can you control the object’s motion by only manipulating the acceleration?  Try to give the creature a personality through its behavior (rather than through its visual design).</p>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_2_forces">
<h1>Chapter 2.  Forces</h1>
<blockquote data-type="epigraph"><p>“Don&#8217;t underestimate the Force.”</p>
<p data-type="attribution">&#8212; — Darth Vader</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""forces"">&nbsp;</a></p>

<p>In the final example of Chapter 1, we saw how we could calculate a dynamic acceleration based on a vector pointing from a circle on the screen to the mouse location.   The resulting motion resembled a magnetic attraction between circle and mouse, as if some <em>force</em> were pulling the circle in towards the mouse.  In this chapter we will formalize our understanding of the concept of a force and its relationship to acceleration.    Our goal, by the end of this chapter, is to understand how to make multiple objects move around the screen and respond to a variety of environmental forces.</p>




<section data-type="sect1" id="chapter02_section1">
<h1>2.1 Forces and Newton’s Laws of Motion</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""Newton's laws of motion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Newton" data-secondary="Isaac"">&nbsp;</a></p>

<p>Before we begin examining the practical realities of simulating forces in code, let’s take a conceptual look at what it means to be a force in the real world.   Just like the word “vector,” “force” is often used to mean a variety of things.  It can indicate a powerful intensity, as in “She pushed the boulder with great force” or “He spoke forcefully.”   The definition of <strong><em>force</em></strong> that we care about is much more formal and comes from Isaac Newton’s laws of motion:</p>

<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""defined"">&nbsp;</a></p>

<p><strong highlight>A force is a vector that causes an object with mass to accelerate.</strong></p>

<p>The good news here is that we recognize the first part of the definition: <em>a force is a vector</em>. Thank goodness we just spent a whole chapter learning what a vector is and how to program with <strong klass>PVector</strong><code>s</code>!</p>

<p>Let’s look at Newton’s three laws of motion in relation to the concept of a force.</p>





<section data-type="sect2" id="_newton_s_first_law">
<h2>Newton’s First Law</h2>
<p><a data-type="indexterm" data-primary=""Newton's first law"">&nbsp;</a></p>

<p>Newton’s first law is commonly stated as:</p>

<p><strong highlight>An object at rest stays at rest and an object in motion stays in motion.</strong></p>

<p>However, this is missing an important element related to forces. We could expand it by stating:</p>

<p><strong highlight>An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an unbalanced force.</strong></p>

<p><a data-type="indexterm" data-primary=""Aristotle"">&nbsp;</a></p>

<p>By the time Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly two thousand years old. It stated that if an object is moving, some sort of force is required to keep it moving.   Unless that moving thing is being pushed or pulled, it will simply slow down or stop.  Right?</p>

<p><a data-type="indexterm" data-primary=""equilibrium"">&nbsp;</a>
<a data-type="indexterm" data-primary=""forces"" data-secondary=""equilibrium"">&nbsp;</a>
<a data-type="indexterm" data-primary=""forces"" data-secondary=""terminal velocity"">&nbsp;</a>
<a data-type="indexterm" data-primary=""terminal velocity"">&nbsp;</a></p>

<p>This, of course, is not true.   In the absence of any forces, no force is required to keep an object moving.  An object (such as a ball) tossed in the earth’s atmosphere slows down because of air resistance (a force).    An object’s velocity will only remain constant in the absence of any forces or if the forces that act on it cancel each other out, i.e. the net force adds up to zero.  This is often referred to as <strong><em>equilibrium</em></strong>.  The falling ball will reach a terminal velocity (that stays constant) once the force of air resistance equals the force of gravity.</p>

<figure id="chapter02_figure1">
<img src="imgs/chapter02/ch02_01.png" alt="Figure 2.1: The pendulum doesn't move because all the forces cancel each other out (add up to a net force of zero)."/>
<figcaption/>
</figure>
<p>In our Processing world, we could restate Newton’s first law as follows:</p>

<p><a data-type="indexterm" data-primary=""Newton's first law"" data-secondary=""PVector class and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""Newton's first law and"">&nbsp;</a></p>

<p><strong highlight>An object’s PVector velocity will remain constant if it is in a state of equilibrium.</strong></p>

<p>Skipping Newton’s second law (arguably the most important law for our purposes) for a moment, let’s move on to the third law.</p>

<p><a data-type="indexterm" data-primary=""Newton's third law"">&nbsp;</a></p>
</section>







<section data-type="sect2" id="_newton_s_third_law">
<h2>Newton’s Third Law</h2>
<p>This law is often stated as:</p>

<p><strong highlight>For every action there is an equal and opposite reaction.</strong></p>

<p>This law frequently causes some confusion in the way that it is stated.   For one, it sounds like one force causes another.   Yes, if you push someone, that someone may <em>actively</em> decide to push you back.  But this is not the action and reaction we are talking about with Newton’s third law.</p>

<p>Let’s say you push against a wall.  The wall doesn’t actively decide to push back on you.   There is no “origin” force.   Your push simply includes both forces, referred to as an “action/reaction pair.”</p>

<p>A better way of stating the law might be:</p>

<p><strong highlight>Forces always occur in pairs.  The two forces are of equal strength, but in opposite directions.</strong></p>

<p>Now, this still causes confusion because it sounds like these forces would always cancel each other out.   This is not the case.  Remember, the forces act on different objects.  And just because the two forces are equal, it doesn’t mean that the movements are equal (or that the objects will stop moving).</p>

<p>Try pushing on a stationary truck.  Although the truck is far more powerful than you, unlike a moving one, a stationary truck will never overpower you and send you flying backwards.  The force you exert on it is equal and opposite to the force exerted on your hands.   The outcome depends on a variety of other factors.  If the truck is a small truck on an icy downhill, you’ll probably be able to get it to move.  On the other hand, if it’s a very large truck on a dirt road and you push hard enough (maybe even take a running start), you could injure your hand.</p>

<p>And if you are wearing roller skates when you push on that truck?</p>

<figure id="chapter02_figure2">
<img src="imgs/chapter02/ch02_02.png" alt="Figure 2.2"/>
<figcaption/>
</figure>
<p>You’ll accelerate away from the truck, sliding along the road while the truck stays put.   Why do you slide but not the truck?  For one, the truck has a much larger mass (which we’ll get into with Newton’s second law).  There are other forces at work too, namely the friction of the truck’s tires and your roller skates against the road.</p>
</section>







<section data-type="sect2" id="_newton_s_third_law_as_seen_through_the_eyes_of_processing">
<h2>Newton’s Third Law (as seen through the eyes of Processing)</h2>
<p><a data-type="indexterm" data-primary=""Newton's third law"" data-secondary=""PVector class and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""Newton's third law and"">&nbsp;</a></p>

<p><strong highlight>If we calculate a PVector f that is a force of object A on object B, we must also apply the force—PVector.mult(f,-1);—that B exerts on object A.</strong></p>

<p>We’ll see that in the world of Processing programming, we don’t always have to stay true to the above.  Sometimes, such as in the case of see <a href="#chapter02_example6">gravitational attraction between bodies</a>, we’ll want to model equal and opposite forces.  Other times, such as when we’re simply saying, “Hey, there’s some wind in the environment,” we’re not going to bother to model the force that a body exerts back on the air.  In fact, we’re not modeling the air at all!  Remember, we are simply taking inspiration from the physics of the natural world, not simulating everything with perfect precision.</p>
</section>


</section>







<section data-type="sect1" id="chapter02_section2">
<h1>2.2 Forces and Processing—Newton’s Second Law as a Function</h1>
<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""Newton's second law"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""Newton's second law" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Newton's second law"">&nbsp;</a></p>

<p>And here we are at the most important law for the Processing programmer.</p>





<section data-type="sect2" id="_newton_s_second_law">
<h2>Newton’s Second Law</h2>
<p>This law is stated as:</p>

<p><strong highlight>Force equals mass times acceleration.</strong></p>

<p>Or:</p>

<p>{newton2ablock}</p>

<p>Why is this the most important law for us?  Well, let’s write it a different way.</p>

<p>{newton2bblock}</p>

<p>Acceleration is directly proportional to force and inversely proportional to mass.  This means that if you get pushed, the harder you are pushed, the faster you’ll move (accelerate).  The bigger you are, the slower you’ll move.</p>

<p><a data-type="indexterm" data-primary=""density"">&nbsp;</a>
<a data-type="indexterm" data-primary=""mass"" data-secondary=""weight vs."">&nbsp;</a>
<a data-type="indexterm" data-primary=""weight"" data-secondary=""mass vs."">&nbsp;</a></p>

<div data-type="note">
<h1>Weight vs. Mass</h1><ul>
<li>
<p>The <strong><em>mass</em></strong> of an object is a measure of the amount of matter in the object (measured in kilograms).</p></li>
<li>
<p><strong><em>Weight</em></strong>, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, we can calculate it as mass times the acceleration of gravity (<strong var>w</strong> = <strong var>m</strong> * <strong var>g</strong>). Weight is measured in newtons.</p></li>
<li>
<p><strong><em>Density</em></strong> is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).</p></li>
</ul>

<p>Note that an object that has a mass of one kilogram on earth would have a mass of one kilogram on the moon. However, it would weigh only one-sixth as much.</p>
</div>
<p>Now, in the world of Processing, what is mass anyway?  Aren’t we dealing with pixels?  To start in a simpler place, let’s say that in our pretend pixel world, all of our objects have a mass equal to 1.  <strong var>F</strong>/ 1 = <strong var>F</strong>.  And so:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mover><mrow><mi> F </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math></p>

<p>The acceleration of an object is equal to force.  This is great news.  After all, we saw in Chapter 1 that acceleration was the key to controlling the movement of our objects on screen.  Location is adjusted by velocity, and velocity by acceleration.  Acceleration was where it all began.  Now we learn that <em>force</em> is truly where it all begins.</p>

<p>Let’s take our <strong klass>Mover</strong> class, with location, velocity, and acceleration.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
}</pre>

<p>Now our goal is to be able to add forces to this object, perhaps saying:</p>

<pre data-type="programlisting" data-code-language="java">mover.applyForce(wind);</pre>

<p>or:</p>

<pre data-type="programlisting" data-code-language="java">mover.applyForce(gravity);</pre>

<p>where wind and gravity are <strong klass>PVector</strong><code>s</code>.  According to Newton’s second law, we could implement this function as follows.</p>

<pre data-type="programlisting" data-code-language="java">void applyForce(PVector force) {
  // Newton’s second law at its simplest.
  acceleration = force;
}</pre>
</section>


</section>







<section data-type="sect1" id="chapter02_section3">
<h1>2.3 Force Accumulation</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""accumulation of"">&nbsp;</a></p>

<p>This looks pretty good.  After all, <em>acceleration = force</em> is a literal translation of Newton’s second law (without mass).  Nevertheless, there’s a pretty big problem here.  Let’s return to what we are trying to accomplish: creating a moving object on the screen that responds to wind and gravity.</p>

<pre data-type="programlisting" data-code-language="java">mover.applyForce(wind);
mover.applyForce(gravity);
mover.update();
mover.display();</pre>

<p>Ok, let’s <em>be</em> the computer for a moment.  First, we call <strong function>applyForce()</strong> with wind.  And so the <strong klass>Mover</strong> object’s acceleration is now assigned the <strong klass>PVector</strong> <strong var>wind</strong>.   Second, we call <strong function>applyForce()</strong> with gravity.  Now the <strong klass>Mover</strong> object’s acceleration is set to the gravity <strong klass>PVector</strong>.    Third, we call <strong function>update()</strong>.  What happens in <strong function>update()</strong>?  Acceleration is added to velocity.</p>

<pre data-type="programlisting" data-code-language="java">velocity.add(acceleration);</pre>

<p>We’re not going to see any error in Processing, but zoinks!  We’ve got a major problem.  What is the value of acceleration when it is added to velocity?  It is equal to the gravity force.  Wind has been left out!  If we call <strong function>applyForce()</strong> more than once, it overrides each previous call.   How are we going to handle more than one force?</p>

<p><a data-type="indexterm" data-primary=""force accumulation"">&nbsp;</a></p>

<p>The truth of the matter here is that we started with a simplified statement of Newton&#8217;s second law.   Here&#8217;s a more accurate way to put it:</p>

<p><strong highlight>Net Force equals mass times acceleration.</strong></p>

<p>Or, acceleration is equal to the <em>sum of all forces</em> divided by mass.  This makes perfect sense.  After all, as we saw in Newton&#8217;s first law, if all the forces add up to zero, an object experiences an equilibrium state (i.e. no acceleration).    Our implementation of this is through a process known as <strong><em>force accumulation</em></strong>.  It’s actually very simple; all we need to do is add all of the forces together.  At any given moment, there might be 1, 2, 6, 12, or 303 forces.  As long as our object knows how to accumulate them, it doesn’t matter how many forces act on it.</p>

<pre data-type="programlisting" data-code-language="java"> void applyForce(PVector force) {
  // Newton’s second law, but with force accumulation.
  // We now add each force to acceleration, one at a time.
    acceleration.add(force);
 }</pre>

<p>Now, we’re not finished just yet.  Force accumulation has one more piece.  Since we’re adding all the forces together at any given moment, we have to make sure that we clear acceleration (i.e. set it to zero) before each time <strong function>update()</strong> is called.   Let’s think about wind for a moment.   Sometimes the wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all.   At any given moment, there might be a huge gust of wind, say, when the user holds down the mouse.</p>

<pre data-type="programlisting" data-code-language="java">if (mousePressed) {
  PVector wind = new PVector(0.5,0);
  mover.applyForce(wind);
}</pre>

<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""force accumulation and"">&nbsp;</a></p>

<p>When the user releases the mouse, the wind will stop, and according to Newton’s first law, the object will continue to move at a constant velocity.   However, if we had forgotten to reset acceleration to zero, the gust of wind would still be in effect.  Even worse, it would add onto itself from the previous frame, since we are accumulating forces!    Acceleration, in our simulation, has no memory; it is simply calculated based on the environmental forces present at a moment in time.   This is different than, say, location, which must remember where the object was in the previous frame in order to move properly to the next.</p>

<p>The easiest way to implement clearing the acceleration for each frame is to multiply the <strong klass>PVector</strong> by 0 at the end of <strong function>update()</strong>.</p>

<pre data-type="programlisting" data-code-language="java"> void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
 }</pre>

<div id="chapter02_exercise1" data-type="example">
<h5>Exercise 2.1</h5>
<p>Using forces, simulate a helium-filled balloon floating upward and bouncing off the top of a window.  Can you add a wind force that changes over time, perhaps according to Perlin noise?</p>
</div>
</section>







<section data-type="sect1" id="chapter02_section4">
<h1>2.4 Dealing with Mass</h1>
<p><a data-type="indexterm" data-primary=""mass"" data-secondary=""modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""mass" data-tertiary="modeling"">&nbsp;</a></p>

<p>OK. We’ve got one tiny little addition to make before we are done with integrating forces into our <strong klass>Mover</strong> class and are ready to look at examples.  After all, Newton’s second law is really <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> F </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mi> M </mi><mo> &#x00D7; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>, not <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mover><mrow><mi> F </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>.   Incorporating mass is as easy as adding an instance variable to our class, but we need to spend a little more time here because a slight complication will emerge.</p>

<p>First we just need to add mass.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Adding mass as a float
  float mass;</pre>

<p><a data-type="indexterm" data-primary=""mass"" data-secondary=""units of measurement" data-tertiary="defining"">&nbsp;</a></p>

<div data-type="note">
<h1>Units of Measurement</h1><p>Now that we are introducing mass, it’s important to make a quick note about units of measurement.  In the real world, things are measured in specific units.  We say that two objects are 3 meters apart, the baseball is moving at a rate of 90 miles per hour, or this bowling ball has a mass of 6 kilograms.   As we’ll see later in this book, sometimes we will want to take real-world units into consideration.  However, in this chapter, we’re going to ignore them for the most part.  Our units of measurement are in pixels (“These two circles are 100 pixels apart”) and frames of animation (“This circle is moving at a rate of 2 pixels per frame”).   In the case of mass, there isn’t any unit of measurement for us to use.  We’re just going to make something up.  In this example, we’re arbitrarily picking the number 10.   There is no unit of measurement, though you might enjoy inventing a unit of your own, like “1 moog” or “1 yurkle.”  It should also be noted that, for demonstration purposes, we’ll tie mass to pixels (drawing, say, a circle with a radius of 10).  This will allow us to visualize the mass of an object.   In the real world, however, size does not definitely indicate mass. A small metal ball could have a much higher mass than a large balloon due to its higher density.</p>
</div>
<p>Mass is a scalar (float), not a vector, as it’s just one number describing the amount of matter in an object.  We could be fancy about things and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is&#8230;um, I dunno&#8230;how about 10?”</p>

<pre data-type="programlisting" data-code-language="java"> Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
    mass = 10.0;
  }</pre>

<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""applying to objects"">&nbsp;</a></p>

<p>This isn’t so great since things only become interesting once we have objects with varying mass, but it’ll get us started.  Where does mass come in?  We use it while applying Newton’s second law to our object.</p>

<pre data-type="programlisting" data-code-language="java"> void applyForce(PVector force) {
   //[full] Newton’s second law (with force accumulation and mass)
   force.div(mass);
   acceleration.add(force);
   //[end]
 }</pre>

<p>Yet again, even though our code looks quite reasonable, we have a fairly major problem here.  Consider the following scenario with two <strong klass>Mover</strong> objects, both being blown away by a wind force.</p>

<pre data-type="programlisting" data-code-language="java">Mover m1 = new Mover();
Mover m2 = new Mover();

PVector wind = new PVector(1,0);

m1.applyForce(wind);
m2.applyForce(wind);</pre>

<p>Again, let’s <em>be</em> the computer.  Object <strong var>m1</strong> receives the wind force—(1,0)—divides it by mass (10), and adds it to acceleration.</p>

<p><strong formula>m1 equals wind force: &#160;&#160;&#160; (1,0)</strong><br/>
<strong formula>Divided by mass of 10: &#160;&#160; (0.1,0)</strong></p>

<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""references to vs. copies of objects"">&nbsp;</a></p>

<p>OK. Moving on to object <strong var>m2</strong>.  It also receives the wind force—(1,0).  Wait.  Hold on a second.  What is the value of the wind force?   Taking a closer look, the wind force is actually now—(0.1,0)!!   Do you remember this little tidbit about working with objects?  When you pass an object (in this case a <strong klass>PVector</strong>) into a function, you are passing a reference to that object.  It’s not a copy!  So if a function makes a change to that object (which, in this case, it does by dividing by mass) then that object is permanently changed!  But we don’t want <strong var>m2</strong> to receive a force divided by the mass of object <strong var>m1</strong>. We want it to receive that force in its original state—(1,0).  And so we must protect ourselves and make a copy of the <strong klass>PVector</strong> f before dividing it by mass.    Fortunately, the <strong klass>PVector</strong> class has a convenient method for making a copy—<strong function>get()</strong>.  <strong function>get()</strong> returns a new <strong klass>PVector</strong> object with the same data.  And so we can revise <strong function>applyForce()</strong> as follows:</p>

<pre data-type="programlisting" data-code-language="java">void applyForce(PVector force) {
  // Making a copy of the PVector before using it!
  PVector f = force.get();
  f.div(mass);
  acceleration.add(f);
}</pre>

<p>There’s another way we could write the above function, using the static method <strong function>div()</strong>. For help with this exercise, review static methods in <a href="#chapter01_section9">Chapter 1</a>.</p>

<div id="chapter02_exercise2" data-type="example">
<h5>Exercise 2.2</h5>
<p>Rewrite the <strong function>applyForce()</strong> method using the static method <strong function>div()</strong> instead of <strong function>get()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void applyForce(PVector force) {
  PVector f = _______.___(_____,____);
  acceleration.add(f);
}</pre>
</div>
</section>







<section data-type="sect1" id="chapter02_section5">
<h1>2.5 Creating Forces</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""creating"">&nbsp;</a></p>

<p>Let’s take a moment to remind ourselves where we are.  We know what a force is (a vector), and we know how to apply a force to an object (divide it by mass and add it to the object’s acceleration vector).   What are we missing?  Well, we have yet to figure out how we get a force in the first place.  Where do forces come from?</p>

<p>In this chapter, we’ll look at two methods for creating forces in our Processing world.</p>

<p><a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""forces" data-tertiary="modeling"">&nbsp;</a></p>

<ol>
<li>
<p><strong>Make up a force!</strong>  After all, you are the programmer, the creator of your world. There’s no reason why you can’t just make up a force and apply it.</p></li>
<li>
<p><strong>Model a force!</strong>  Yes, forces exist in the real world.  And physics textbooks often contain formulas for these forces.  We can take these formulas, translate them into source code, and model real-world forces in Processing.</p></li>
</ol>

<p>The easiest way to make up a force is to just pick a number.  Let’s start with the idea of simulating wind.  How about a wind force that points to the right and is fairly weak?  Assuming a <strong klass>Mover</strong> object m, our code would look like:</p>

<pre data-type="programlisting" data-code-language="java">  PVector wind = new PVector(0.01,0);
  m.applyForce(wind);</pre>

<p>The result isn’t terribly interesting, but it is a good place to start.  We create a <strong klass>PVector</strong> object, initialize it, and pass it into an object (which in turn will apply it to its own acceleration).  If we wanted to have two forces, perhaps wind and gravity (a bit stronger, pointing down), we might write the following:</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_1_forces/_2_1_forces.pde processingjs/chapter02/_2_1_forces/Mover.pde">
<img src="imgs/chapter02/ch02_ex01.png" alt="ch02 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 2.1: Forces</strong></p>

<pre data-type="programlisting" data-code-language="java">  PVector wind = new PVector(0.01,0);
  PVector gravity = new PVector(0,0.1);
  m.applyForce(wind);
  m.applyForce(gravity);</pre>

<p>Now we have two forces, pointing in different directions with different magnitudes, both applied to object <strong var>m</strong>.  We’re beginning to get somewhere.  We’ve now built a world for our objects in Processing, an environment to which they can actually respond.</p>

<p>Let’s look at how we could make this example a bit more exciting with many objects of varying mass.   To do this, we’ll need a quick review of object-oriented programming.  Again, we’re not covering all the basics of programming here (for that you can check out any of the intro Processing books listed in the introduction).  However, since the idea of creating a world filled with objects is pretty fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.</p>

<p>This is where we are with the <strong klass>Mover</strong> class as a whole.  Notice how it is identical to the <strong klass>Mover</strong> class created in Chapter 1, with two additions—<strong var>mass</strong> and a new <strong function>applyForce()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // The object now has mass!
  float mass;

  Mover() {
    // And for now, we’ll just set the mass equal to 1 for simplicity.
    mass = 1;
    location = new PVector(30,30);
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }

  // Newton’s second law.
  void applyForce(PVector force) {
    //[full] Receive a force, divide by mass, and add to acceleration.
    PVector f = PVector.div(force,mass);
    acceleration.add(f);
    //[end]
  }

  void update() {
    //[full] Motion 101 from Chapter 1
    velocity.add(acceleration);
    location.add(velocity);
    //[end]
    // Now add clearing the acceleration each time!
    acceleration.mult(0);
  }

  void display() {
    stroke(0);
    fill(175);
    //[offset-down] Scaling the size according to mass.
    ellipse(location.x,location.y,mass*16,mass*16);
  }

  // Somewhat arbitrarily, we are deciding that an object bounces when it hits the edges of a window.
  void checkEdges() {
    if (location.x &gt; width) {
      location.x = width;
      velocity.x *= -1;
    } else if (location.x &lt; 0) {
      velocity.x *= -1;
      location.x = 0;
    }

    if (location.y &gt; height) {
      // Even though we said we shouldn't touch location and velocity directly, there are some exceptions.
      // Here we are doing so as a quick and easy way to reverse the direction of our object when it reaches the edge.
      velocity.y *= -1;
      location.y = height;
    }
  }
}</pre>

<p>Now that our class is set, we can choose to create, say, one hundred <strong klass>Mover</strong> objects with an array.</p>

<pre data-type="programlisting" data-code-language="java">Mover[] movers = new Mover[100];</pre>

<p>And then we can initialize all of those <strong klass>Mover</strong> objects in <strong function>setup()</strong> with a loop.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover();
  }
}</pre>

<p>But now we have a small issue.  If we refer back to the <strong klass>Mover</strong> object’s constructor&#8230;</p>

<pre data-type="programlisting" data-code-language="java">  Mover() {
    //[full] Every object has a mass of 1 and a location of (30,30).
    mass = 1;
    location = new PVector(30,30);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }</pre>

<p><a data-type="indexterm" data-primary=""constructor"" data-secondary=""arguments" data-tertiary="adding to"">&nbsp;</a></p>

<p>&#8230;we discover that every <strong klass>Mover</strong> object is made exactly the same way.  What we want are <strong klass>Mover</strong> objects of varying mass that start at varying locations.  Here is where we need to increase the sophistication of our constructor by adding arguments.</p>

<pre data-type="programlisting" data-code-language="java">  Mover(float m, float x , float y) {
    //[full] Now setting these variables with arguments
    mass = m;
    location = new PVector(x,y);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }</pre>

<p>Notice how the mass and location are no longer set to hardcoded numbers, but rather initialized via arguments passed through the constructor.   This means we can create a variety of <strong klass>Mover</strong> objects: big ones, small ones, ones that start on the left side of the screen, ones that start on the right, etc.</p>

<pre data-type="programlisting" data-code-language="java">// A big Mover on the left side of the window
Mover m1 = new Mover(10,0,height/2);
// A small Mover on the right side of the window
Mover m1 = new Mover(0.1,width,height/2);</pre>

<p>With an array, however, we want to initialize all of the objects with a loop.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
    // Initializing many Mover objects, all with random mass (and all starting at 0,0)
    movers[i] = new Mover(random(0.1,5),0,0);
  }
}</pre>

<p>For each mover created, the mass is set to a random value between 0.1 and 5, the starting x-location is set to 0, and the starting y-location is set to 0.  Certainly, there are all sorts of ways we might choose to initialize the objects; this is just a demonstration of one possibility.</p>

<p>Once the array of objects is declared, created, and initialized, the rest of the code is simple.  We run through every object, hand them each the forces in the environment, and enjoy the show.</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_2_forces_many/_2_2_forces_many.pde processingjs/chapter02/_2_2_forces_many/Mover.pde">
<img src="imgs/chapter02/ch02_ex02.png" alt="ch02 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 2.2: Forces acting on many objects</strong></p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);

  PVector wind = new PVector(0.01,0);
  // Make up two forces.
  PVector gravity = new PVector(0,0.1);

  //[full] Loop through all objects and apply both forces to each object.
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);
  //[end]
    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}</pre>

<p>Note how in the above image, the smaller circles reach the right of the window faster than the larger ones.  This is because of our formula: <em>acceleration = force divided by mass</em>.   The larger the mass, the smaller the acceleration.</p>

<div id="chapter02_exercise3" data-type="example">
<h5>Exercise 2.3</h5>
<p>Instead of objects bouncing off the edge of the wall, create an example in which an invisible force pushes back on the objects to keep them in the window.  Can you weight the force according to how far the object is from an edge—i.e., the closer it is, the stronger the force?</p>
</div>
</section>







<section data-type="sect1" id="chapter02_section6">
<h1>2.6 Gravity on Earth and Modeling a Force</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""gravity" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Galileo"">&nbsp;</a>

<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""gravity"">&nbsp;</a></p>

<p>You may have noticed something woefully inaccurate about this last example.  The smaller the circle, the faster it falls.   There is a logic to this; after all, we just stated (according to Newton’s second law) that the smaller the mass, the higher the acceleration.  But this is not what happens in the real world.  If you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one will hit the ground first?  According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same time.  Why is this?   As we will see later in this chapter, the force of gravity is calculated relative to an object’s mass.  The bigger the object, the stronger the force.  So if the force is scaled according to mass, it is canceled out when acceleration is divided by mass.   We can implement this in our sketch rather easily by multiplying our made-up gravity force by mass.</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_3_forces_many_realgravity/_2_3_forces_many_realgravity.pde processingjs/chapter02/_2_3_forces_many_realgravity/Mover.pde">
<img src="imgs/chapter02/ch02_ex03.png" alt="ch02 ex03"/>
<figcaption/>
</figure>
<p><strong example>Example 2.3: Gravity scaled by mass</strong></p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; movers.length; i++) {

    PVector wind = new PVector(0.001,0);
    float m = movers[i].mass;
    // Scaling gravity by mass to be more accurate
    PVector gravity = new PVector(0,0.1*m);
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }</pre>

<p>While the objects now fall at the same rate, because the strength of the wind force is independent of mass, the smaller objects still accelerate to the right more quickly.</p>

<p>Making up forces will actually get us quite far.  The world of Processing is a pretend world of pixels and you are its master.  So whatever you deem appropriate to be a force, well by golly, that’s the force it should be.  Nevertheless, there may come a time where you find yourself wondering: “But how does it really all work?”</p>

<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""models of" data-tertiary="building"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""physics (real world)" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""physics"" data-secondary=""modeling"">&nbsp;</a></p>

<p>Open up any high school physics textbook and you will find some diagrams and formulas describing many different forces—gravity, electromagnetism, friction, tension, elasticity, and more.  In this chapter we’re going to look at two forces—friction and gravity.  The point we’re making here is not that friction and gravity are fundamental forces that you always need to have in your Processing sketches.  Rather, we want to evaluate these two forces as case studies for the following process:</p>

<ul>
<li>
<p>Understanding the concept behind a force</p></li>
<li>
<p>Deconstructing the force’s formula into two parts:</p>
<ul>
<li>
<p>How do we compute the force’s direction?</p></li>
<li>
<p>How do we compute the force’s magnitude?</p></li>
</ul>
</li>
<li>
<p>Translating that formula into Processing code that calculates a <strong klass>PVector</strong> to be sent through our <strong klass>Mover</strong><code>'s</code> <strong function>applyForce()</strong> function</p></li>
</ul>

<p>If we can follow the above steps with two forces, then hopefully if you ever find yourself Googling “atomic nuclei weak nuclear force” at 3 a.m., you will have the skills to take what you find and adapt it for Processing.</p>

<p><a data-type="indexterm" data-primary=""formulae" data-secondary="evaluating in code"">&nbsp;</a></p>

<div data-type="note">
<h1>Dealing with formulae</h1><p>OK, in a moment we’re going to write out the formula for friction.  This isn’t the first time we’ve seen a formula in this book; we just finished up our discussion of Newton’s second law, <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> F </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mi> M </mi><mo> &#x00D7; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> (or force = mass * acceleration).    We didn’t spend a lot of time worrying about this formula because it’s a nice and simple one.  Nevertheless, it’s a scary world out there.  Just take a look at the equation for a “normal” distribution, which we covered (without looking at the formula) in the <a href="#intro_section4">Introduction</a>.</p>

<p><div style="font-size: 1.5em;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> f </mi><mfenced><mrow><mi> x </mi><mo> ; </mo><mi> &#x00B5; </mi><mo> , </mo><msup><mrow><mi> &#x03C3; </mi></mrow><mrow><mn> 2 </mn></mrow></msup></mrow></mfenced><mo> = </mo><mfrac><mrow><mn> 1 </mn></mrow><mrow><mi> &#x03C3; </mi><msqrt><mn> 2 </mn><mi> &#x03C0; </mi></msqrt></mrow></mfrac><mi> e </mi><msup><mo> - </mo><mfrac><mrow><msup><mrow><mfenced><mrow><mi> x </mi><mo> - </mo><mi> &#x00B5; </mi></mrow></mfenced></mrow><mrow><mn> 2 </mn></mrow></msup></mrow><mrow><mn> 2 </mn><msup><mrow><mi> &#x03C3; </mi></mrow><mrow><mn> 2 </mn></mrow></msup></mrow></mfrac></msup></mstyle></math></div></p>

<p><a data-type="indexterm" data-primary=""friction"" data-secondary=""formula for"">&nbsp;</a></p>

<p>What we’re seeing here is that formulas like to use a lot of symbols (quite often letters from the Greek alphabet).   Let’s take a look at the formula for friction.</p>

<p><div style="font-size: 1.5em;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> F </mi><mi> r </mi><mi> i </mi><mi> c </mi><mi> t </mi><mi> i </mi><mi> o </mi><mi> n </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mo> - </mo><mi> &#x00B5; </mi><mi> N </mi><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math></div></p>

<p>If it’s been a while since you’ve looked at a formula from a math or physics textbook, there are three key points that are important to cover before we move on.</p>

<ul>
<li>
<p><strong><em>Evaluate the right side, assign to the left side.</em></strong>  This is just like in code!  What we’re doing here is evaluating the right side of the equation and assigning it to the left.  In the case above, we want to calculate the force of friction—the left side tells us what we want to calculate and the right side tells us how to do it.</p></li>
<li>
<p><strong><em>Are we talking about a vector or a scalar?</em></strong>  It’s important for us to realize that in some cases, we’ll be looking at a vector; in others, a scalar.   For example, in this case the force of friction is a vector.  We can see that by the arrow above the word “friction.” It has a magnitude and direction.  The right side of the equation also has a vector, as indicated by the symbol <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math>, which in this case stands for the velocity unit vector.</p></li>
<li>
<p><strong><em>When symbols are placed next to each other, we mean for them to be multiplied.</em></strong>  The formula above actually has four elements:  -1, <em>μ</em>, <em>N</em>, and <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math>.  We want to multiply them together and read the formula as: <div style="font-size: 1.0em;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> F </mi><mi> r </mi><mi> i </mi><mi> c </mi><mi> t </mi><mi> i </mi><mi> o </mi><mi> n </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo> <mo> - </mo><mn> 1 </mn><mo> * </mo><mi> &#x00B5; </mi><mo> * </mo><mi> N </mi><mo> * </mo><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math></div></p></li>
</ul>
</div></section>







<section data-type="sect1" id="chapter02_section7">
<h1>2.7 Friction</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""friction" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""friction"" data-secondary=""modeling with formulae"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""friction"">&nbsp;</a></p>

<p>Let’s begin with friction and follow our steps.</p>

<p><a data-type="indexterm" data-primary=""dissipative force"">&nbsp;</a></p>

<p>Friction is a <strong><em>dissipative force</em></strong>.  A dissipative force is one in which the total energy of a system decreases when an object is in motion.   Let’s say you are driving a car. When you press your foot down on the brake pedal, the car’s brakes use friction to slow down the motion of the tires.  Kinetic energy (motion) is converted into thermal energy (heat).   Whenever two surfaces come into contact, they experience friction.   A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for our purposes, we are only going to look at the kinetic case.</p>

<p>Here&#8217;s the formula for friction:</p>

<figure id="chapter02_figure3">
<img src="imgs/chapter02/ch02_03.png" alt="Figure 2.3"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""friction"" data-secondary=""determining direction/magnitude of"">&nbsp;</a></p>

<p>It’s now up to us to separate this formula into two components that determine the direction of friction as well as the magnitude.  Based on the diagram above, we can see that <em>friction points in the opposite direction of velocity.</em>   In fact, that’s the part of the formula that says -1 * <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math>, or -1 times the velocity unit vector.  In Processing, this would mean taking the velocity vector, normalizing it, and multiplying by -1.</p>

<pre data-type="programlisting" data-code-language="java">PVector friction = velocity.get();
friction.normalize();
// Let’s figure out the direction of the friction force
// (a unit vector in the opposite direction of velocity).
friction.mult(-1);</pre>

<p>Notice two additional steps here.  First, it’s important to make a copy of the velocity vector, as we don’t want to reverse the object’s direction by accident.  Second, we normalize the vector.  This is because the magnitude of friction is not associated with how fast it is moving, and we want to start with a friction vector of magnitude 1 so that it can easily be scaled.</p>

<p><a data-type="indexterm" data-primary=""mu (μ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""coefficient of friction"">&nbsp;</a>
<a data-type="indexterm" data-primary=""coefficient of friction"" data-secondary=""mu (μ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""friction"" data-secondary=""mu (μ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""friction"" data-secondary=""coefficient of friction"">&nbsp;</a></p>

<p>According to the formula, the magnitude is <strong var>μ</strong> * <strong var>N</strong>.   <strong var>μ</strong>, the Greek letter <em>mu</em> (pronounced “mew”), is used here to describe the <strong><em>coefficient of friction</em></strong>.   The coefficient of friction establishes the strength of a friction force for a particular surface.  The higher it is, the stronger the friction; the lower, the weaker.   A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper.   Since we’re in a pretend Processing world, we can arbitrarily set the coefficient based on how much friction we want to simulate.</p>

<pre data-type="programlisting" data-code-language="java">float c = 0.01;</pre>

<p><a data-type="indexterm" data-primary=""friction"" data-secondary=""normal force"">&nbsp;</a>
<a data-type="indexterm" data-primary=""normal force"">&nbsp;</a></p>

<p>Now for the second part: <strong var>N</strong>.  <strong var>N</strong> refers to the <strong><em>normal force</em></strong>, the force perpendicular to the object’s motion along a surface.  Think of a vehicle driving along a road.   The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road in turn pushes back against the vehicle.  That’s the normal force.  The greater the gravitational force, the greater the normal force.   As we’ll see in the next section, gravity is associated with mass, and so a lightweight sports car would experience less friction than a massive tractor trailer truck.   With the diagram above, however, where the object is moving along a surface at an angle, computing the normal force is a bit more complicated because it doesn’t point in the same direction as gravity.  We’ll need to know something about angles and trigonometry.</p>

<p>All of these specifics are important; however, in Processing, a “good enough” simulation can be achieved without them.  We can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1.  When we get into trigonometry in the next chapter, we’ll remember to return to this question and make our friction example a bit more sophisticated.  Therefore:</p>

<pre data-type="programlisting" data-code-language="java">float normal = 1;</pre>

<p>Now that we have both the magnitude and direction for friction, we can put it all together&#8230;</p>

<pre data-type="programlisting" data-code-language="java">float c = 0.01;
float normal = 1;
// Let’s figure out the magnitude of friction
// (really just an arbitrary constant).
float frictionMag = c*normal;

PVector friction = velocity.get();
friction.mult(-1);
friction.normalize();

// Take the unit vector and multiply it by magnitude
// and we have our force vector!
friction.mult(frictionMag);</pre>

<p>&#8230;and add it to our “forces” example, where many objects experience wind, gravity, and now friction:</p>

<figure class="two-col" data-pde="processingjs/chapter02/_2_4_forces_nofriction/_2_4_forces_nofriction.pde processingjs/chapter02/_2_4_forces_nofriction/Mover.pde">
<img src="imgs/chapter02/ch02_ex04a.png" alt="No friction"/>
<figcaption/>
</figure>
<figure class="two-col" data-pde="processingjs/chapter02/_2_4_forces_friction/_2_4_forces_friction.pde processingjs/chapter02/_2_4_forces_friction/Mover.pde">
<img src="imgs/chapter02/ch02_ex04b.png" alt="With friction"/>
<figcaption/>
</figure>
<p><strong example>Example 2.4: Including friction</strong></p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);

  PVector wind = new PVector(0.001,0);
  // We could scale by mass to be more accurate.
  PVector gravity = new PVector(0,0.1);

  for (int i = 0; i &lt; movers.length; i++) {

    float c = 0.01; //[bold]
    PVector friction = movers[i].velocity.get(); //[bold]
    friction.mult(-1); //[bold]
    friction.normalize(); //[bold]
    friction.mult(c); //[bold]

    // Apply the friction force vector to the object.
    movers[i].applyForce(friction); //[bold]
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }

}</pre>

<p>Running this example, you’ll notice that the circles don’t even make it to the right side of the window.  Since friction continuously pushes against the object in the opposite direction of its movement, the object continuously slows down.  This can be a useful technique or a problem depending on the goals of your visualization.</p>

<div id="chapter02_exercise4" data-type="example">
<h5>Exercise 2.4</h5>
<p>Create pockets of friction in a Processing sketch so that objects only experience friction when crossing over those pockets.    What if you vary the strength (friction coefficient) of each area?   What if you make some pockets feature the opposite of friction—i.e., when you enter a given pocket you actually speed up instead of slowing down?</p>
</div>
</section>







<section data-type="sect1" id="chapter02_section8">
<h1>2.8 Air and Fluid Resistance</h1>
<figure id="chapter02_figure4">
<img src="imgs/chapter02/ch02_04.png" alt="Figure 2.4"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""drag force"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fluid resistance" data-secondary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""forces"" data-secondary=""fluid resistance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""fluid resistance" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""viscous force"">&nbsp;</a></p>

<p>Friction also occurs when a body passes through a liquid or gas.  This force has many different names, all really meaning the same thing: <em>viscous force</em>, <em>drag force</em>, <em>fluid resistance</em>.  While the result is ultimately the same as our previous friction examples (the object slows down), the way in which we calculate a drag force will be slightly different.  Let’s look at the formula:</p>

<p><div style="font-size: 2.0em;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> F </mi></mrow><mrow><mi> d </mi></mrow></msub><mo> = </mo><mo> - </mo><mfrac><mrow><mn> 1 </mn></mrow><mrow><mn> 2 </mn></mrow></mfrac><mi> &#x03C1; </mi><msup><mrow><mi> v </mi></mrow><mrow><mn> 2 </mn></mrow></msup><mi> A </mi><msub><mrow><mi> C </mi></mrow><mrow><mi> d </mi></mrow></msub><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math></div></p>

<p>Now let’s break this down and see what we really need for an effective simulation in Processing, making ourselves a much simpler formula in the process.</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> F </mi></mrow><mrow><mi> d </mi></mrow></msub></mstyle></math> refers to <em>drag force</em>, the vector we ultimately want to compute and pass into our <strong function>applyForce()</strong> function.</p></li>
<li>
<p>- 1/2 is a constant: -0.5.   This is fairly irrelevant in terms of our Processing world, as we will be making up values for other constants anyway.   However, the fact that it is negative is important, as it tells us that the force is in the opposite direction of velocity (just as with friction).</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""rho (ρ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""friction"" data-secondary=""rho (ρ)"">&nbsp;</a></p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03C1; </mi></mstyle></math> is the Greek letter <em>rho</em>, and refers to the density of the liquid, something we don’t need to worry about.  We can simplify the problem and consider this to have a constant value of 1.</p></li>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> v </mi></mstyle></math> refers to the speed of the object moving.  OK, we’ve got this one!  The object’s speed is the magnitude of the velocity vector:  <strong function>velocity.magnitude()</strong>.  And <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msup><mrow><mi> v </mi></mrow><mrow><mn> 2 </mn></mrow></msup></mstyle></math> just means <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> v </mi></mstyle></math> squared or <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> v </mi></mstyle></math> * <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> v </mi></mstyle></math>.</p></li>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> A </mi></mstyle></math> refers to the frontal area of the object that is pushing through the liquid (or gas).  An aerodynamic Lamborghini, for example, will experience less air resistance than a boxy Volvo.   Nevertheless, for a basic simulation, we can consider our object to be spherical and ignore this element.</p></li>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> C </mi></mrow><mrow><mi> d </mi></mrow></msub></mstyle></math> is the coefficient of drag, exactly the same as the coefficient of friction (<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03C1; </mi></mstyle></math>).  This is a constant we’ll determine based on whether we want the drag force to be strong or weak.</p></li>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> v </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math> Look familiar?  It should.  This refers to the velocity unit vector, i.e. <strong function>velocity.normalize()</strong>.  Just like with friction, drag is a force that points in the opposite direction of velocity.</p></li>
</ul>

<p>Now that we’ve analyzed each of these components and determined what we need for a simple simulation, we can reduce our formula to:</p>

<figure id="chapter02_figure5">
<img src="imgs/chapter02/ch02_05.png" alt="Figure 2.5: Our simplified drag force formula"/>
<figcaption/>
</figure>
<p>or:</p>

<pre data-type="programlisting" data-code-language="java">float c = 0.1;
float speed = v.mag();
// Part 1 of our formula (magnitude): Cd * v2
float dragMagnitude = c * speed * speed;
PVector drag = velocity.get();
// Part 2 of our formula (direction):
// -1 * velocity
drag.mult(-1);
drag.normalize();
// Magnitude and direction together!
drag.mult(dragMagnitude);</pre>

<p><a data-type="indexterm" data-primary=""friction"" data-secondary=""applying to an object"">&nbsp;</a></p>

<p>Let’s implement this force in our <strong klass>Mover</strong> class example with one addition.   When we wrote our friction example, the force of friction was always present.  Whenever an object was moving, friction would slow it down.  Here, let’s introduce an element to the environment—a “liquid” that the <strong klass>Mover</strong> objects pass through.  The <strong klass>Liquid</strong> object will be a rectangle and will know about its location, width, height, and “coefficient of drag”—i.e., is it easy for objects to move through it (like air) or difficult (like molasses)?  In addition, it should include a function to draw itself on the screen (and two more functions, which we’ll see in a moment).</p>

<pre data-type="programlisting" data-code-language="java">class Liquid {
  // The liquid object includes a variable defining
  // its coefficient of drag.
  float x,y,w,h;
  float c;

  Liquid(float x_, float y_, float w_, float h_, float c_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;
    c = c_;
  }

  void display() {
    noStroke();
    fill(175);
    rect(x,y,w,h);
  }

}</pre>

<p>The main program will now include a <strong klass>Liquid</strong> object reference as well as a line of code that initializes that object.</p>

<pre data-type="programlisting" data-code-language="java">Liquid liquid;

void setup() {
  //[offset-up] Initialize a Liquid object.  Note the coefficient is low (0.1), otherwise the object would come to a halt fairly quickly (which may someday be the effect you want).
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}</pre>

<p>Now comes an interesting question: how do we get the <strong klass>Mover</strong> object to talk to the <strong klass>Liquid</strong> object?  In other words, we want to execute the following:</p>

<p><em>When a mover passes through a liquid it experiences a drag force.</em></p>

<p>&#8230;or in object-oriented speak (assuming we are looping through an array of <strong klass>Mover</strong> objects with index i):</p>

<pre data-type="programlisting" data-code-language="java">if (movers[i].isInside(liquid)) {
  // If a Mover is inside a Liquid, apply the drag force.
  movers[i].drag(liquid);
}</pre>

<p>The above code tells us that we need to add two functions to the <strong klass>Mover</strong> class: (1) a function that determines if a <strong klass>Mover</strong> object is inside the <strong klass>Liquid</strong> object, and (2) a function that computes and applies a drag force on the <strong klass>Mover</strong> object.</p>

<p>The first is easy; we can simply use a conditional statement to determine if the location vector rests inside the rectangle defined by the liquid.</p>

<pre data-type="programlisting" data-code-language="java">boolean isInside(Liquid l) {
  //[offset-down] This conditional statement determines if the PVector location is inside the rectangle defined by the Liquid class.
  if (location.x&gt;l.x &amp;&amp; location.x&lt;l.x+l.w &amp;&amp; location.y&gt;l.y &amp;&amp; location.y&lt;l.y+l.h)
  {
    return true;
  } else {
    return false;
  }
}</pre>

<p>The <strong function>drag()</strong> function is a bit more complicated; however, we’ve written the code for it already.  This is simply an implementation of our formula.  The drag force is equal to <em>the coefficient of drag multiplied by the speed of the <strong klass>Mover</strong> squared in the opposite direction of velocity!</em></p>

<pre data-type="programlisting" data-code-language="java"> void drag(Liquid l) {

    float speed = velocity.mag();
    // The force’s magnitude: Cd * v~2~
    float dragMagnitude = l.c * speed * speed;

    PVector drag = velocity.get();
    drag.mult(-1);
    // The force's direction: -1 * velocity
    drag.normalize();

    // Finalize the force: magnitude and direction together.
    drag.mult(dragMagnitude);

    // Apply the force.
    applyForce(drag);
  }</pre>

<p>And with these two functions added to the <strong klass>Mover</strong> class, we’re ready to put it all together in the main tab:</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_5_fluidresistance/_2_5_fluidresistance.pde processingjs/chapter02/_2_5_fluidresistance/Liquid.pde processingjs/chapter02/_2_5_fluidresistance/Mover.pde">
<img src="imgs/chapter02/ch02_ex05.png" alt="ch02 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 2.5: Fluid Resistance</strong></p>

<pre data-type="programlisting" data-code-language="java">Mover[] movers = new Mover[100];

Liquid liquid;

void setup() {
  size(360, 640);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,5),0,0);
  }
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}

void draw() {
  background(255);

  liquid.display();

  for (int i = 0; i &lt; movers.length; i++) {

    if (movers[i].isInside(liquid)) {
      movers[i].drag(liquid);
    }

    float m = 0.1*movers[i].mass;
    // Note that we are scaling gravity according to mass.
    PVector gravity = new PVector(0, m);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}</pre>

<p>Running the example, you should notice that we are simulating balls falling into water.  The objects only slow down when crossing through the gray area at the bottom of the window (representing the liquid).  You’ll also notice that the smaller objects slow down a great deal more than the larger objects.    Remember Newton’s second law?  <strong var>A</strong> = <strong var>F</strong> / <strong var>M</strong>. Acceleration equals force <em>divided</em> by mass.  A massive object will accelerate less.  A smaller object will accelerate more.    In this case, the acceleration we’re talking about is the “slowing down” due to drag.  The smaller objects will slow down at a greater rate than the larger ones.</p>

<div id="chapter02_exercise5" data-type="example">
<h5>Exercise 2.5</h5>
<p>Take a look at our formula for drag again:  <strong><em>drag force = coefficient * speed * speed</em></strong>.  The faster an object moves, the greater the drag force against it.  In fact, an object not moving in water experiences no drag at all.   Expand the example to drop the balls from different heights.  How does this affect the drag as they hit the water?</p>
</div>

<div id="chapter02_exercise6" data-type="example">
<h5>Exercise 2.6</h5>
<p>The formula for drag also included surface area.  Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?</p>
</div>

<div id="chapter02_exercise7" data-type="example">
<h5>Exercise 2.7</h5>
<p>Fluid resistance does not only work opposite to the velocity vector, but also perpendicular to it.  This is known as “lift-induced drag” and will cause an airplane with an angled wing to rise in altitude.   Try creating a simulation of lift.</p>
</div>
</section>







<section data-type="sect1" id="chapter02_section9">
<h1>2.9 Gravitational Attraction</h1>
<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""gravity"">&nbsp;</a></p>

<figure id="chapter02_figure6" class="half-width-right">
<img src="imgs/chapter02/ch02_06.png" alt="Figure 2.6"/>
<figcaption/>
</figure>
<p>Probably the most famous force of all is gravity.   We humans on earth think of gravity as an apple hitting Isaac Newton on the head.    Gravity means that stuff falls down.  But this is only <em>our</em> experience of gravity.   In truth, just as the earth pulls the apple towards it due to a gravitational force, the apple pulls the earth as well.   The thing is, the earth is just so freaking big that it overwhelms all the other gravity interactions.  Every object with mass exerts a gravitational force on every other object.   And there is a formula for calculating the strengths of these forces, as depicted in Figure 2.6.</p>

<p>Let’s examine this formula a bit more closely.</p>

<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""universal gravitational constant"">&nbsp;</a>
<a data-type="indexterm" data-primary=""gravity"" data-secondary=""universal gravitational constant"">&nbsp;</a>
<a data-type="indexterm" data-primary=""universal gravitational constant"">&nbsp;</a></p>

<ul>
<li>
<p><strong var>F</strong> refers to the gravitational force, the vector we ultimately want to compute and pass into our <strong function>applyForce()</strong> function.</p></li>
<li>
<p><strong var>G</strong> is the <em>universal gravitational constant</em>, which in our world equals 6.67428 x 10<sup>-11</sup> meters cubed per kilogram per second squared.   This is a pretty important number if your name is Isaac Newton or Albert Einstein.  It’s not an important number if you are a Processing programmer.  Again, it’s a constant that we can use to make the forces in our world weaker or stronger.  Just making it equal to one and ignoring it isn’t such a terrible choice either.</p></li>
<li>
<p><strong var>m<sub>1</sub></strong> and <strong var>m<sub>2</sub></strong> are the masses of objects 1 and 2.   As we saw with Newton’s second law (<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> F </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> = </mo><mi> M </mi><mo> &#x00D7; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>), mass is also something we could choose to ignore.  After all, shapes drawn on the screen don’t actually have a physical mass.  However, if we keep these values, we can create more interesting simulations in which “bigger” objects exert a stronger gravitational force than smaller ones.</p></li>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> r </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math> refers to the unit vector pointing from object 1 to object 2.  As we’ll see in a moment, we can compute this direction vector by subtracting the location of one object from the other.</p></li>
<li>
<p><strong var>r</strong><sup>2</sup> refers to the distance between the two objects squared.  Let’s take a moment to think about this a bit more.  With everything on the top of the formula—<strong var>G</strong>, <strong var>m<sub>1</sub></strong>, <strong var>m<sub>2</sub></strong>—the bigger its value, the stronger the force.  Big mass, big force.  Big <strong var>G</strong>, big force.  Now, when we divide by something, we have the opposite.  The strength of the force is inversely proportional to the distance squared.  The <em>farther away</em> an object is, the <em>weaker</em> the force; the <em>closer</em>, the <em>stronger</em>.</p></li>
</ul>

<p>Hopefully by now the formula makes some sense to us.  We’ve looked at a diagram and dissected the individual components of the formula.  Now it’s time to figure out how we translate the math into Processing code.  Let’s make the following assumptions.</p>

<p>We have two objects, and:</p>

<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""implementing model of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""gravity"">&nbsp;</a></p>

<ol>
<li>
<p>Each object has a location: <strong var>PVector location1</strong> and <strong var>PVector location2</strong>.</p></li>
<li>
<p>Each object has a mass: <strong var>float mass1</strong> and <strong var>float mass2</strong>.</p></li>
<li>
<p>There is a variable <strong var>float G</strong> for the universal gravitational constant.</p></li>
</ol>

<p>Given these assumptions, we want to compute <strong var>PVector force</strong>, the force of gravity.  We’ll do it in two parts.  First, we’ll compute the direction of the force <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> r </mi></mrow><mrow><mo> &#x2227; </mo></mrow></mover></mstyle></math> in the formula above.  Second, we’ll calculate the strength of the force according to the masses and distance.</p>

<figure id="chapter02_figure7" class="half-width-right">
<img src="imgs/chapter02/ch02_07.png" alt="Figure 2.7"/>
<figcaption/>
</figure>
<p>Remember in <a href="#chapter01_section10">Chapter 1</a>, when we figured out how to have an object accelerate towards the mouse? (See Figure 2.7.)</p>

<p>A vector is the difference between two points. To make a vector that points from the circle to the mouse, we simply subtract one point from another:</p>

<pre data-type="programlisting" data-code-language="java">PVector dir = PVector.sub(mouse,location);</pre>

<p>In our case, the direction of the attraction force that object 1 exerts on object 2 is equal to:</p>

<pre data-type="programlisting" data-code-language="java">PVector dir = PVector.sub(location1,location2);
dir.normalize();</pre>

<p>Don’t forget that since we want a unit vector, a vector that tells us about direction only, we’ll need to <em>normalize</em> the vector after subtracting the locations.</p>

<p>OK, we’ve got the direction of the force.  Now we just need to compute the magnitude and scale the vector accordingly.</p>

<pre data-type="programlisting" data-code-language="java">float m = (G * mass1 * mass2) / (distance * distance);
dir.mult(m);</pre>

<figure id="chapter02_figure8" class="half-width-right">
<img src="imgs/chapter02/ch02_08.png" alt="Figure 2.8"/>
<figcaption/>
</figure>
<p>The only problem is that we don’t know the distance.  <strong var>G</strong>, <strong var>mass1</strong>, and <strong var>mass2</strong> were all givens, but we’ll need to actually compute distance before the above code will work.   Didn’t we just make a vector that points all the way from one location to another?   Wouldn’t the length of that vector be the distance between two objects?</p>

<p>Well, if we add just one line of code and grab the magnitude of that vector before normalizing it, then we’ll have the distance.</p>

<pre data-type="programlisting" data-code-language="java">// The vector that points from one object to another
PVector force = PVector.sub(location1,location2);

// The length (magnitude) of that vector is the distance between the two objects.
float distance = force.mag();

// Use the formula for gravity to compute the strength of the force.
float m = (G * mass1 * mass2) / (distance * distance);

// Normalize and scale the force vector
// to the appropriate magnitude.
force.normalize();
force.mult(m);</pre>

<p>Note that I also renamed the <strong klass>PVector</strong> “dir” as “force.”   After all, when we’re finished with the calculations, the <strong klass>PVector</strong> we started with ends up being the actual force vector we wanted all along.</p>

<p>Now that we’ve worked out the math and the code for calculating an attractive force (emulating gravity), we need to turn our attention to applying this technique in the context of an actual Processing sketch.   In Example 2.1, you may recall how we created a simple <strong klass>Mover</strong> object—a class with <strong klass>PVector</strong><code>’s</code> location, velocity, and acceleration as well as an <strong function>applyForce()</strong>.  Let’s take this exact class and put it in a sketch with:</p>

<figure id="chapter02_figure9" class="half-width-right">
<img src="imgs/chapter02/ch02_09.png" alt="Figure 2.9"/>
<figcaption/>
</figure>
<ul>
<li>
<p>A single <strong klass>Mover</strong> object.</p></li>
<li>
<p>A single <strong klass>Attractor</strong> object (a new class that will have a fixed location).</p></li>
</ul>

<p>The <strong klass>Mover</strong> object will experience a gravitational pull towards the <strong klass>Attractor</strong> object, as illustrated in Figure 2.9.</p>

<p>We can start by making the new <strong klass>Attractor</strong> class very simple—giving it a location and a mass, along with a function to display itself (tying mass to size).</p>

<pre data-type="programlisting" data-code-language="java">class Attractor {
  // Our Attractor is a simple object that doesn’t move.
  // We just need a mass and a location.
  float mass;
  PVector location;

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}</pre>

<p>And in our main program, we can add an instance of the <strong klass>Attractor</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">Mover m;
Attractor a;

void setup() {
  size(640,360);
  m = new Mover();
  // Initialize Attractor object.
  a = new Attractor();
}

void draw() {
  background(255);

  // Display Attractor object.
  a.display();

  m.update();
  m.display();
}</pre>

<p><a data-type="indexterm" data-primary=""object"" data-secondary=""interaction between"">&nbsp;</a></p>

<p>This is a good structure: a main program with a <strong klass>Mover</strong> and an <strong klass>Attractor</strong> object, and a class to handle the variables and behaviors of movers and attractors.   The last piece of the puzzle is how to get one object to attract the other.  How do we get these two objects to talk to each other?</p>

<p>There are a number of ways we could do this.  Here are just a few possibilities.</p>

<table class="codewide">
<tr>
<th>Task</th>
<th>Function</th>
</tr>
<tr>
<td>1. A function that receives both an Attractor and a Mover:</td>
<td><pre>attraction(a,m);</pre></td>
</tr>
<tr>
<td>2. A function in the Attractor class that receives a Mover:</td>
<td><pre>a.attract(m);</pre></td>
</tr>
<tr>
<td>3. A function in the Mover class that receives an Attractor:</td>
<td><pre>m.attractedTo(a);</pre></td>
</tr>
<tr>
<td>4. A function in the Attractor class that receives a Mover and returns a PVector, which is the attraction force.  That attraction force is then passed into the Mover's applyForce() function:</td>
<td>
<pre>
PVector f = a.attract(m);
m.applyForce(f);
</pre></td>
</tr>
</table>
<p>and so on. . .</p>

<p>It’s good to look at a range of options for making objects talk to each other, and you could probably make arguments for each of the above possibilities.  I’d like to at least discard the first one, since an object-oriented approach is really a much better choice over an arbitrary function not tied to either the <strong klass>Mover</strong> or <strong klass>Attractor</strong> class.   Whether you pick option 2 or option 3 is the difference between saying “The attractor attracts the mover” or “The mover is attracted to the attractor.”  Number 4 is really my favorite, at least in terms of where we are in this book.  After all, we spent a lot of time working out the <strong function>applyForce()</strong> function, and I think our examples will be clearer if we continue with the same methodology.</p>

<p>In other words, where we once had:</p>

<pre data-type="programlisting" data-code-language="java">// Made-up force
PVector f = new PVector(0.1,0);
m.applyForce(f);</pre>

<p>We now have:</p>

<pre data-type="programlisting" data-code-language="java">// Attraction force between two objects
PVector f = a.attract(m); //[bold]
m.applyForce(f);</pre>

<p>And so our <strong function>draw()</strong> function can now be written as:</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);

  //[full] Calculate attraction force and apply it.
  PVector f = a.attract(m); //[bold]
  m.applyForce(f); //[bold]
  //[end]

  m.update();

  a.display();
  m.display();

}</pre>

<p>We’re almost there.  Since we decided to put the <strong function>attract()</strong> function inside of the <strong klass>Attractor</strong> class, we’ll need to actually write that function.   The function needs to receive a <strong klass>Mover</strong> object and return a <strong klass>PVector</strong>, i.e.:</p>

<pre data-type="programlisting" data-code-language="java">PVector attract(Mover m) {

}</pre>

<p>And what goes inside that function?  All of that nice math we worked out for gravitational attraction!</p>

<pre data-type="programlisting" data-code-language="java">PVector attract(Mover m) {

  // What’s the force’s direction?
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  force.normalize();
  //[offset-down] What’s the force’s magnitude?
  float strength = (G * mass * m.mass) / (distance * distance);
  force.mult(strength);

  // Return the force so that it can be applied!
  return force;
}</pre>

<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""placing limits on model of"">&nbsp;</a></p>

<p>And we’re done.  Sort of.  Almost.  There’s one small kink we need to work out.  Let’s look at the above code again.  See that symbol for divide, the slash?  Whenever we have one of these, we need to ask ourselves the question:  What would happen if  the distance happened to be a really, really small number or (even worse!) zero??!  Well, we know we can’t divide a number by 0, and if we were to divide a number by something like 0.0001, that is the equivalent of multiplying that number by 10,000!   Yes, this is the real-world formula for the strength of gravity, but we don’t live in the real world.  We live in the <em>Processing</em> world.   And in the Processing world, the mover could end up being very, very close to the attractor and the force could become so strong the mover would just fly way off the screen.   And so with this formula, it’s good for us to be practical and constrain the range of what <strong var>distance</strong> can actually be.   Maybe, no matter where the <strong klass>Mover</strong> actually is, we should never consider it less than 5 pixels or more than 25 pixels away from the attractor.</p>

<pre data-type="programlisting" data-code-language="java">  distance = constrain(distance,5,25);</pre>

<p>For the same reason that we need to constrain the minimum distance, it’s useful for us to do the same with the maximum.  After all, if the mover were to be, say, 500 pixels from the attractor (not unreasonable), we’d be dividing the force by 250,000.  That force might end up being so weak that it’s almost as if we’re not applying it at all.</p>

<p>Now, it’s really up to you to decide what behaviors you want.  But in the case of, “I want reasonable-looking attraction that is never absurdly weak or strong,” then constraining the distance is a good technique.</p>

<p>Our <strong klass>Mover</strong> class hasn’t changed at all, so let’s just look at the main program and the <strong klass>Attractor</strong> class as a whole, adding a variable <strong var>G</strong> for the universal gravitational constant.  (On the website, you’ll find that this example also has code that allows you to move the <strong klass>Attractor</strong> object with the mouse.)</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_6_attraction/_2_6_attraction.pde processingjs/chapter02/_2_6_attraction/Attractor.pde processingjs/chapter02/_2_6_attraction/Mover.pde">
<img src="imgs/chapter02/ch02_ex06.png" alt="ch02 ex06"/>
<figcaption/>
</figure>
<p><strong example>Example 2.6: Attraction</strong></p>

<pre data-type="programlisting" data-code-language="java">// A Mover and an Attractor
Mover m;
Attractor a;

void setup() {
  size(640,360);
  m = new Mover();
  a = new Attractor();
}

void draw() {
  background(255);

  // Apply the attraction force from the Attractor on the Mover.
  PVector force = a.attract(m);
  m.applyForce(force);
  m.update();

  a.display();
  m.display();
}

class Attractor {
  float mass;
  PVector location;
  float G;

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
    G = 0.4;
  }

  PVector attract(Mover m) {
    PVector force = PVector.sub(location,m.location);
    float distance = force.mag();
    // Remember, we need to constrain the distance
    // so that our circle doesn’t spin out of control.
    distance = constrain(distance,5.0,25.0);


    force.normalize();
    float strength = (G * mass * m.mass) / (distance * distance);
    force.mult(strength);
    return force;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}</pre>

<p>And we could, of course, expand this example using an array to include many <strong klass>Mover</strong> objects, just as we did with friction and drag:</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_7_attraction_many/_2_7_attraction_many.pde processingjs/chapter02/_2_7_attraction_many/Attractor.pde processingjs/chapter02/_2_7_attraction_many/Mover.pde">
<img src="imgs/chapter02/ch02_ex07.png" alt="ch02 ex07"/>
<figcaption/>
</figure>
<p><strong example>Example 2.7: Attraction with many Movers</strong></p>

<pre data-type="programlisting" data-code-language="java">// Now we have 10 Movers!
Mover[] movers = new Mover[10];

Attractor a;

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    //[offset-down] Each Mover is initialized randomly.
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
  a = new Attractor();
}

void draw() {
  background(255);

  a.display();

  for (int i = 0; i &lt; movers.length; i++) {
    // We calculate an attraction force for each Mover object.
    PVector force = a.attract(movers[i]);
    movers[i].applyForce(force);

    movers[i].update();
    movers[i].display();
  }

}</pre>

<div id="chapter02_exercise8" data-type="example">
<h5>Exercise 2.8</h5>
<p>In the example above, we have a system (i.e. array) of <strong klass>Mover</strong> objects and one <strong klass>Attractor</strong> object.  Build an example that has systems of both movers and attractors.  What if you make the attractors invisible?  Can you create a pattern/design from the trails of objects moving around attractors?  See the <a href="http://processing.org/exhibition/works/metropop/">Metropop Denim project by Clayton Cubitt and Tom Carden</a> for an example.</p>
</div>

<div id="chapter02_exercise9" data-type="example">
<h5>Exercise 2.9</h5>
<p>It’s worth noting that gravitational attraction is a model we can follow to develop our own forces.  This chapter isn’t suggesting that you should exclusively create sketches that use gravitational attraction.  Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects.  For example, what happens if you design a force that is weaker the closer it gets and stronger the farther it gets?  Or what if you design your attractor to attract faraway objects, but repel close ones?</p>
</div>
</section>







<section data-type="sect1" id="chapter02_section10">
<h1>2.10 Everything Attracts (or Repels) Everything</h1>
<p>Hopefully, you found it helpful that we started with a simple scenario—<em>one object attracts another object</em><code>—</code>and moved on to <em>one object attracts many objects</em>.  However, it’s likely that you are going to find yourself in a slightly more complex situation: <em>many objects attract each other</em>.  In other words, every object in a given system attracts every other object in that system (except for itself).</p>

<p>We’ve really done almost all of the work for this already.  Let’s consider a Processing sketch with an array of <strong klass>Mover</strong> objects:</p>

<pre data-type="programlisting" data-code-language="java">Mover[] movers = new Mover[10];

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}

void draw() {
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].update();
    movers[i].display();
  }
}</pre>

<p>The <strong function>draw()</strong> function is where we need to work some magic.  Currently, we’re saying: “for every mover <strong var>i</strong>, update and display yourself.”  Now what we need to say is: “for every mover <strong var>i</strong>, be attracted to every other mover <strong var>j</strong>, and update and display yourself.”</p>

<p>To do this, we need to nest a second loop.</p>

<pre data-type="programlisting" data-code-language="java"> for (int i = 0; i &lt; movers.length; i++) {
  // For every Mover, check every Mover!
    for (int j = 0; j &lt; movers.length; j++) {
      PVector force = movers[j].attract(movers[i]);
      movers[i].applyForce(force);
    }
    movers[i].update();
    movers[i].display();
  }</pre>

<p>In the previous example, we had an <strong klass>Attractor</strong> object with a function named <strong function>attract()</strong>.  Now, since we have movers attracting movers, all we need to do is copy the <strong function>attract()</strong> function into the <strong klass>Mover</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  [inline]// All the other stuff we had before plus. . .

  // The Mover now knows how to attract another Mover.
  PVector attract(Mover m) {

    PVector force = PVector.sub(location,m.location);
    float distance = force.mag();
    distance = constrain(distance,5.0,25.0);
    force.normalize();

    float strength = (G * mass * m.mass) / (distance * distance);
    force.mult(strength);
    return force;
  }
}</pre>

<p>Of course, there’s one small problem. When we are looking at every mover <strong var>i</strong> and every mover <strong var>j</strong>, are we OK with the times that <strong var>i</strong> equals <strong var>j</strong>?  For example, should mover #3 attract mover #3?   The answer, of course, is no.   If there are five objects, we only want mover #3 to attract 0, 1, 2, and 4, skipping itself.   And so, we finish this example by adding a simple conditional statement to skip applying the force when i equals j.</p>

<figure class="screenshot" data-pde="processingjs/chapter02/_2_8_mutual_attraction/_2_8_mutual_attraction.pde processingjs/chapter02/_2_8_mutual_attraction/Mover.pde">
<img src="imgs/chapter02/ch02_ex08.png" alt="ch02 ex08"/>
<figcaption/>
</figure>
<p><strong example>Example 2.8: Mutual attraction</strong></p>

<pre data-type="programlisting" data-code-language="java">Mover[] movers = new Mover[20];

float g = 0.4;

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    for (int j = 0; j &lt; movers.length; j++) {
      // Don’t attract yourself!
      if (i != j) {
        PVector force = movers[j].attract(movers[i]);
        movers[i].applyForce(force);
      }
    }
    movers[i].update();
    movers[i].display();
  }
}</pre>

<div id="chapter02_exercise10" data-type="example">
<h5>Exercise 2.10</h5>
<p>Change the attraction force in Example 2.8 to a repulsion force.  Can you create an example in which all of the <strong klass>Mover</strong> objects are attracted to the mouse, but repel each other?  Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.</p>
</div>

<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 2 Exercise:</p>

<p>Incorporate the concept of forces into your ecosystem.   Try introducing other elements into the environment (food, a predator) for the creature to interact with.   Does the creature experience attraction or repulsion to things in its world?  Can you think more abstractly and design forces based on the creature’s desires or goals?</p>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_3_oscillation">
<h1>Chapter 3.  Oscillation</h1>
<blockquote data-type="epigraph"><p>“Trigonometry is a sine of the times.”</p>
<p data-type="attribution">&#8212; — Anonymous</p>
</blockquote>

<p>In Chapters 1 and 2, we carefully worked out an object-oriented structure to make something move on the screen, using the concept of a vector to represent location, velocity, and acceleration driven by forces in the environment.   We could move straight from here into topics such as particle systems, steering forces, group behaviors, etc.  If we did that, however, we’d skip an important area of mathematics that we’re going to need: <strong><em>trigonometry</em></strong>, or the mathematics of triangles, specifically right triangles.</p>

<p>Trigonometry is going to give us a lot of tools.   We’ll get to think about angles and angular velocity and acceleration.  Trig will teach us about the sine and cosine functions, which when used properly can yield an nice ease-in, ease-out wave pattern.   It’s going to allow us to calculate more complex forces in an environment that involves angles, such as a pendulum swinging or a box sliding down an incline.</p>

<p>So this chapter is a bit of a mishmash. We’ll start with the basics of angles in Processing and cover many trigonometric topics, tying it all into forces at the end.  And by taking this break now, we’ll also pave the way for more advanced examples that require trig later in this book.</p>




<section data-type="sect1" id="chapter03_section1">
<h1>3.1  Angles</h1>
<p><a data-type="indexterm" data-primary=""angles"">&nbsp;</a></p>

<p>OK. Before we can do any of this stuff, we need to make sure we understand what it means to be an angle in Processing.   If you have experience with Processing, you’ve undoubtedly encountered this issue while using the <strong function>rotate()</strong> function to rotate and spin objects.</p>

<p><a data-type="indexterm" data-primary=""angles"" data-secondary=""measuring in degrees"">&nbsp;</a>
<a data-type="indexterm" data-primary=""degrees"">&nbsp;</a></p>

<p>The first order of business is to cover <strong><em>radians</em></strong> and <strong><em>degrees</em></strong>.  You’re probably familiar with the concept of an angle in <strong><em>degrees</em></strong>.  A full rotation goes from 0 to 360 degrees.   90 degrees (a right angle) is 1/4th of 360, shown below as two perpendicular lines.</p>

<figure id="chapter03_figure1">
<img src="imgs/chapter03/ch03_01.png" alt="Figure 3.1"/>
<figcaption/>
</figure>
<p>It’s fairly intuitive for us to think of angles in terms of degrees.  For example, the square in Figure 3.2 is rotated 45 degrees around its center.</p>

<figure id="chapter03_figure2">
<img src="imgs/chapter03/ch03_02.png" alt="Figure 3.3"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""angles"" data-secondary=""measuring in radians"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""angles" data-tertiary="measuring in"">&nbsp;</a>
<a data-type="indexterm" data-primary=""radians"">&nbsp;</a></p>

<p>Processing, however, requires angles to be specified in <strong><em>radians</em></strong>.   A radian is a unit of measurement for angles defined by the ratio of the length of the arc of a circle to the radius of that circle.   One radian is the angle at which that ratio equals one (see Figure 3.1).  180 degrees = PI radians, 360 degrees = 2*PI radians, 90 degrees = PI/2 radians, etc.</p>

<figure id="chapter03_figure3">
<img src="imgs/chapter03/ch03_03.png" alt="Figure 3.3"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""degrees"" data-secondary=""radians" data-tertiary="converting to"">&nbsp;</a>
<a data-type="indexterm" data-primary=""radians"" data-secondary=""converting from degrees"">&nbsp;</a></p>

<p>The formula to convert from degrees to radians is:</p>

<p>radians = 2 * PI * (degrees / 360)</p>

<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""radians() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""radians() function (Processing)"">&nbsp;</a></p>

<p>Thankfully, if we prefer to think in degrees but code with radians, Processing makes this easy.  The <strong function>radians()</strong> function will automatically convert values from degrees to radians, and the constants <strong var>PI</strong> and <strong var>TWO_PI</strong> provide convenient access to these commonly used numbers (equivalent to 180 and 360 degrees, respectively).   The following code, for example, will rotate shapes by 60 degrees.</p>

<pre data-type="programlisting" data-code-language="java">float angle = radians(60);
rotate(angle);</pre>

<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""rotation tutorial"">&nbsp;</a></p>

<p>If you are not familiar with how rotation is implemented in Processing, I would suggest this tutorial: <a href="http://www.processing.org/learning/transform2d/">Processing - Transform 2D</a>.</p>

<p><a data-type="indexterm" data-primary=""pi (π)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PI variable (Processing)"">&nbsp;</a></p>

<div data-type="note">
<h1>What is PI?</h1><p>The mathematical constant pi (or π) is a real number defined as the ratio of a circle&#8217;s circumference (the distance around the perimeter) to its diameter (a straight line that passes through the circle&#8217;s center).  It is equal to approximately 3.14159 and can be accessed in Processing with the built-in variable <strong var>PI</strong>.</p>
</div>
<div style="page-break-after:always;"> </div>
<div id="chapter03_exercise1" data-type="example">
<h5>Exercise 3.1</h5>
<p>Rotate a baton-like object (see below) around its center using <strong function>translate()</strong> and <strong function>rotate()</strong>.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/Ex_3_01_exercise_baton/Ex_3_01_exercise_baton.pde">
<img src="imgs/chapter03/ch03_exc01.png" alt="ch03 exc01"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter03_section2">
<h1>3.2 Angular Motion</h1>
<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""rotation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""angles"" data-secondary=""motion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""motion"" data-secondary=""angular"">&nbsp;</a>
<a data-type="indexterm" data-primary=""rotation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""shapes"" data-secondary=""rotating"">&nbsp;</a></p>

<p>Remember all this stuff?</p>

<p><strong formula>location = location + velocity</strong><br/>
<strong formula>velocity = velocity + acceleration</strong></p>

<p>The stuff we dedicated almost all of Chapters 1 and 2 to?  Well, we can apply exactly the same logic to a rotating object.</p>

<p><strong formula>angle = angle + angular velocity</strong><br/>
<strong formula>angular velocity = angular velocity + angular acceleration</strong></p>

<p>In fact, the above is actually simpler than what we started with because an angle is a <em>scalar</em> quantity—a single number, not a vector!</p>

<p>Using the answer from Exercise 3.1 above, let’s say we wanted to rotate a baton in Processing by some angle.  We would have code like:</p>

<pre data-type="programlisting" data-code-language="java">  translate(width/2,height/2);
  rotate(angle);
  line(-50,0,50,0);
  ellipse(50,0,8,8);
  ellipse(-50,0,8,8);</pre>

<p>Adding in our principles of motion brings us to the following example.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_01_angular_motion/_3_01_angular_motion.pde">
<img src="imgs/chapter03/ch03_ex01.png" alt="ch03 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 3.1: Angular motion using rotate()</strong></p>

<pre data-type="programlisting" data-code-language="java">// Location
float angle = 0;
// Velocity
float aVelocity = 0;
// Acceleration
float aAcceleration = 0.001;

void setup() {
  size(640,360);
}

void draw() {
  background(255);

  fill(175);
  stroke(0);
  rectMode(CENTER);
  translate(width/2,height/2);
  rotate(angle);
  line(-50,0,50,0);
  ellipse(50,0,8,8);
  ellipse(-50,0,8,8);

  // Angular equivalent of velocity.add(acceleration);
  aVelocity += aAcceleration;
  // Angular equivalent of location.add(velocity);
  angle += aVelocity;
}</pre>

<p>The baton starts onscreen with no rotation and then spins faster and faster as the angle of rotation accelerates.</p>

<p>This idea can be incorporated into our <strong klass>Mover</strong> object.  For example, we can add the variables related to angular motion to our <strong klass>Mover</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float mass;

  float angle = 0;
  float aVelocity = 0;
  float aAcceleration = 0;</pre>

<p>And then in <strong function>update()</strong>, we update both location and angle according to the same algorithm!</p>

<pre data-type="programlisting" data-code-language="java"> void update() {

    //[full] Regular old-fashioned motion
    velocity.add(acceleration);
    location.add(velocity);
    //[end]

    //[full] Newfangled angular motion
    aVelocity += aAcceleration;
    angle += aVelocity;
    //[end]

    acceleration.mult(0);
  }</pre>

<p>Of course, for any of this to matter, we also would need to rotate the object when displaying it.</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    stroke(0);
    fill(175,200);
    rectMode(CENTER);
    // pushMatrix() and popMatrix() are necessary
    // so that the rotation of this shape doesn’t
    // affect the rest of our world.
    pushMatrix();

    // Set the origin at the shape’s location.
    translate(location.x,location.y);
    // Rotate by the angle.
    rotate(angle);
    rect(0,0,mass*16,mass*16);
    popMatrix();
  }</pre>

<p>Now, if we were to actually go ahead and run the above code, we wouldn’t see anything new.  This is because the angular acceleration (<strong function>float aAcceleration = 0;</strong>) is initialized to zero.  For the object to rotate, we need to give it an acceleration!  Certainly, we could hard-code in a different number.</p>

<pre data-type="programlisting" data-code-language="java">float aAcceleration = 0.01;</pre>

<p>However, we can produce a more interesting result by dynamically assigning an angular acceleration according to forces in the environment.   Now, we could head far down this road, trying to model the physics of angular acceleration using the concepts of <a href="http://en.wikipedia.org/wiki/Torque">torque</a> and <a href="http://en.wikipedia.org/wiki/Moment_of_inertia">moment of inertia</a>.    Nevertheless, this level of simulation is beyond the scope of this book.  (We will see more about modeling angular acceleration with a pendulum later in this chapter, as well as look at how Box2D realistically models rotational motion in Chapter 5.)</p>

<p>For now, a quick and dirty solution will do.  We can produce reasonable results by simply calculating angular acceleration as a function of the object’s acceleration vector.  Here’s one such example:</p>

<pre data-type="programlisting" data-code-language="java">    aAcceleration = acceleration.x;</pre>

<p>Yes, this is completely arbitrary.  But it does do something.  If the object is accelerating to the right, its angular rotation accelerates in a clockwise direction; acceleration to the left results in a counterclockwise rotation.  Of course, it’s important to think about scale in this case. The <em>x</em> component of the acceleration vector might be a quantity that’s too large, causing the object to spin in a way that looks ridiculous or unrealistic.  So dividing the <em>x</em> component by some value, or perhaps constraining the angular velocity to a reasonable range, could really help.  Here’s the entire <strong function>update()</strong> function with these tweaks added.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_02_forces_angular_motion/_3_02_forces_angular_motion.pde processingjs/chapter03/_3_02_forces_angular_motion/Attractor.pde processingjs/chapter03/_3_02_forces_angular_motion/Mover.pde">
<img src="imgs/chapter03/ch03_ex02.png" alt="ch03 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 3.2: Forces with (arbitrary) angular motion</strong></p>

<pre data-type="programlisting" data-code-language="java">  void update() {

    velocity.add(acceleration);
    location.add(velocity);

    // Calculate angular acceleration according to
    // acceleration’s horizontal direction and
    // magnitude.
    aAcceleration = acceleration.x / 10.0;
    aVelocity += aAcceleration;
    // Use constrain() to ensure that angular
    // velocity doesn’t spin out of control.
    aVelocity = constrain(aVelocity,-0.1,0.1);
    angle += aVelocity;

    acceleration.mult(0);
  }</pre>

<div id="chapter03_exercise2" data-type="example">
<h5>Exercise 3.2</h5>
<p>Step 1:  Create a simulation where objects are shot out of a cannon.  Each object should experience a sudden force when shot (just once) as well as gravity (always present).</p>

<p>Step 2:  Add rotation to the object to model its spin as it is shot from the cannon.  How realistic can you make it look?</p>
</div>
</section>







<section data-type="sect1" id="chapter03_section3">
<h1>3.3 Trigonometry</h1>
<p><a data-type="indexterm" data-primary=""<em>sohcahtoa</em>"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""<em>sohcahtoa</em>"">&nbsp;</a></p>

<p>I think it may be time.  We’ve looked at angles, we’ve spun an object.  It’s time for: <em>sohcahtoa</em>.  Yes, <em>sohcahtoa</em>.  This seemingly nonsensical word is actually the foundation for a lot of computer graphics work.    A basic understanding of trigonometry is essential if you want to calculate an angle, figure out the distance between points, work with circles, arcs, or lines.  And <em>sohcahtoa</em> is a  mnemonic device (albeit a somewhat absurd one) for what the trigonometric functions sine, cosine, and tangent mean.</p>

<figure id="chapter03_figure4">
<img src="imgs/chapter03/ch03_04.png" alt="Figure 3.4"/>
<figcaption/>
</figure>
<ul>
<li>
<p><strong><em>soh</em></strong>: sine  = opposite / hypotenuse</p></li>
<li>
<p><strong><em>cah</em></strong>: cosine  = adjacent / hypotenuse</p></li>
<li>
<p><strong><em>toa</em></strong>: tangent  = opposite / adjacent</p></li>
</ul>

<figure id="chapter03_figure5" class="half-width-right">
<img src="imgs/chapter03/ch03_05.png" alt="Figure 3.5"/>
<figcaption/>
</figure>
<p>Take a look at Figure 3.4 again.  There’s no need to memorize it, but make sure you feel comfortable with it.  Draw it again yourself.    Now let’s draw it a slightly different way (Figure 3.5).</p>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""as right triangles"">&nbsp;</a></p>

<p>See how we create a right triangle out of a vector?  The vector arrow itself is the hypotenuse and the components of the vector (<strong var>x</strong> and <strong var>y</strong>) are the sides of the triangle.  The angle is an additional means for specifying the vector’s direction (or “heading”).</p>

<p>Because the trigonometric functions allow us to establish a relationship between the components of a vector and its direction + magnitude, they will prove very useful throughout this book.  We’ll begin by looking at an example that requires the tangent function.</p>
</section>







<section data-type="sect1" id="chapter03_section4">
<h1>3.4 Pointing in the Direction of Movement</h1>
<p><a data-type="indexterm" data-primary=""rotation"" data-secondary=""pointing towards movement"">&nbsp;</a></p>

<p>Let’s go all the way back to Example 1.10, which features a <strong klass>Mover</strong> object accelerating towards the mouse.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/chapter01/_1_10_motion101_acceleration/Mover.pde">
<img src="imgs/chapter01/ch01_ex10.png" alt="ch01 ex10"/>
<figcaption/>
</figure>
<p>You might notice that almost all of the shapes we’ve been drawing so far are circles.   This is convenient for a number of reasons, one of which is that we don’t have to consider the question of rotation.  Rotate a circle and, well, it looks exactly the same.  However, there comes a time in all motion programmers’ lives when they want to draw something on the screen that points in the direction of movement. Perhaps you are drawing an ant, or a car, or a spaceship. And when we say "point in the direction of movement," what we are really saying is “rotate according to the velocity vector.”  Velocity is a vector, with an <strong var>x</strong> and a <strong var>y</strong> component, but to rotate in Processing we need an angle, in radians.   Let’s draw our trigonometry diagram one more time, with an object’s velocity vector (Figure 3.6).</p>

<figure id="chapter03_figure6" class="half-width-right">
<img src="imgs/chapter03/ch03_06.png" alt="Figure 3.6"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""tangent"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""tangent"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""tangent"">&nbsp;</a></p>

<p>OK. We know that the definition of tangent is:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> t </mi><mi> a </mi><mi> n </mi><mi> g </mi><mi> e </mi><mi> n </mi><mi> t </mi><mfenced><mrow><mi> a </mi><mi> n </mi><mi> g </mi><mi> l </mi><mi> e </mi></mrow></mfenced><mo> = </mo><mfrac><msub><mrow><mi> v </mi><mi> e </mi><mi> l </mi><mi> o </mi><mi> c </mi><mi> i </mi><mi> t </mi><mi> y </mi></mrow><mrow><mi> y </mi></mrow></msub> <msub><mrow><mi> v </mi><mi> e </mi><mi> l </mi><mi> o </mi><mi> c </mi><mi> i </mi><mi> t </mi><mi> y </mi></mrow><mrow><mi> x </mi></mrow></msub> </mfrac></mstyle></math></p>

<p>The problem with the above is that we know velocity, but we don’t know the angle.  We have to solve for the angle.   This is where a special function known as <em>inverse tangent</em> comes in, sometimes referred to as <em>arctangent</em> or <em>tan<sup>-1</sup></em>.  (There is also an <em>inverse sine</em> and an <em>inverse cosine</em>.)</p>

<p>If the tangent of some value <strong var>a</strong> equals some value <strong var>b</strong>, then the inverse tangent of <strong var>b</strong> equals <strong var>a</strong>. For example:</p>

<dl>
<dt><em>if</em></dt>
<dd>
<p><em>tangent(a) = b</em></p>
</dd>
<dt><em>then</em></dt>
<dd>
<p><em>a = arctangent(b)</em></p>
</dd>
</dl>

<p>See how that is the inverse?   The above now allows us to solve for the angle:</p>

<dl>
<dt><em>if</em></dt>
<dd>
<p><em>tangent(angle) = velocity<sub>y</sub> / velocity<sub>x</sub></em></p>
</dd>
<dt><em>then</em></dt>
<dd>
<p><em>angle = arctangent(velocity<sub>y</sub> / velocity<sub>x</sub>)</em></p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary=""atan() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""atan() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""tangent"" data-secondary=""atan() function (arctangent)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""atan() function"">&nbsp;</a></p>

<p>Now that we have the formula, let’s see where it should go in our mover&#8217;s <strong function>display()</strong> function.   Notice that in Processing, the function for arctangent is called <strong function>atan()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    // Solve for angle by using atan().
    float angle = atan(velocity.y/velocity.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(location.x,location.y);
    // Rotate according to that angle.
    rotate(angle);
    rect(0,0,30,10);
    popMatrix();
  }</pre>

<p>Now the above code is pretty darn close, and almost works.   We still have a big problem, though.  Let’s consider the two velocity vectors depicted below.</p>

<figure id="chapter03_figure7">
<img src="imgs/chapter03/ch03_07.png" alt="Figure 3.7"/>
<figcaption/>
</figure>
<p>Though superficially similar, the two vectors point in quite different directions—opposite  directions, in fact!  However, if we were to apply our formula to solve for the angle to each vector&#8230;</p>

<p><strong formula>V1 &#8658; angle = atan(-4/3) = atan(-1.25) = -0.9272952 radians = -53 degrees</strong><br/>
<strong formula>V2 &#8658; angle = atan(4/-3) = atan(-1.25) = -0.9272952 radians = -53 degrees</strong></p>

<p><a data-type="indexterm" data-primary=""atan2() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""atan2() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""tangent"" data-secondary=""atan2() function"">&nbsp;</a></p>

<p>&#8230;we get the same angle for each vector.   This can’t be right for both; the vectors point in opposite directions!   The thing is, this is a pretty common problem in computer graphics. Rather than simply using <strong function>atan()</strong> along with a bunch of conditional statements to account for positive/negative scenarios, Processing (along with pretty much all programming environments) has a nice function called <strong function>atan2()</strong> that does it for you.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_03_pointing_velocity/_3_03_pointing_velocity.pde  processingjs/chapter03/_3_03_pointing_velocity/Mover.pde">
<img src="imgs/chapter03/ch03_ex03.png" alt="ch03 ex03"/>
<figcaption/>
</figure>
<p><strong example>Example 3.3: Pointing in the direction of motion</strong></p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    // Using atan2() to account for all possible directions
    float angle = atan2(velocity.y,velocity.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(location.x,location.y);
    // Rotate according to that angle.
    rotate(angle);
    rect(0,0,30,10);
    popMatrix();
  }</pre>

<p><a data-type="indexterm" data-primary=""heading() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""motion"" data-secondary=""heading() function (PVector class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""heading() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""tangent"" data-secondary=""heading() function (PVector class)"">&nbsp;</a></p>

<p>To simplify this even further, the <strong klass>PVector</strong> class itself provides a function called <strong klass>heading()</strong>, which takes care of calling <strong function>atan2()</strong> for you so you can get the 2D direction angle, in radians, for any Processing <strong klass>PVector</strong>.</p>

<pre data-type="programlisting" data-code-language="java">    // The easiest way to do this!
    float angle = velocity.heading();</pre>

<div id="chapter03_exercise3" data-type="example">
<h5>Exercise 3.3</h5>
<p>Create a simulation of a vehicle that you can drive around the screen using the arrow keys: left arrow accelerates the car to the left, right to the right.  The car should point in the direction in which it is currently moving.</p>
</div>
</section>







<section data-type="sect1" id="chapter03_section5">
<h1>3.5 Polar vs. Cartesian Coordinates</h1>
<p><a data-type="indexterm" data-primary=""Cartesian coordinates"">&nbsp;</a>
<a data-type="indexterm" data-primary=""coordinate systems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""coordinate systems"" data-secondary=""Cartesian"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Descartes" data-secondary="René"">&nbsp;</a>
<a data-type="indexterm" data-primary=""shapes"" data-secondary=""displaying"">&nbsp;</a></p>

<p>Any time we display a shape in Processing, we have to specify a pixel location, a set of <strong var>x</strong> and <strong var>y</strong> coordinates.  These coordinates are known as <strong><em>Cartesian coordinates</em></strong>, named for René Descartes, the French mathematician who developed the ideas behind Cartesian space.</p>

<p><a data-type="indexterm" data-primary=""coordinate systems"" data-secondary=""polar"">&nbsp;</a>
<a data-type="indexterm" data-primary=""polar coordinates"">&nbsp;</a></p>

<p>Another useful coordinate system known as <strong><em>polar coordinates</em></strong> describes a point in space as an angle of rotation around the origin and a radius from the origin.   Thinking about this in terms of a vector:</p>

<p>Cartesian coordinate—the <em>x</em>,<em>y</em> components of a vector<br/>
Polar coordinate—the magnitude (length) and direction (angle) of a vector</p>

<p><a data-type="indexterm" data-primary=""coordinate systems"" data-secondary=""Processing and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""coordinate systems and"">&nbsp;</a></p>

<p>Processing’s drawing functions, however, don’t understand polar coordinates.  Whenever we want to display something in Processing, we have to specify locations as <em>(x,y)</em> Cartesian coordinates.   However, sometimes it is a great deal more convenient for us to think in polar coordinates when designing.   Happily for us, with trigonometry we can convert back and forth between polar and Cartesian, which allows us to design with whatever coordinate system we have in mind but always draw with Cartesian coordinates.</p>

<p><a data-type="indexterm" data-primary=""theta (θ)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""angles"" data-secondary=""theta (θ)"">&nbsp;</a></p>

<figure id="chapter03_figure8">
<img src="imgs/chapter03/ch03_08.png" alt="Figure 3.8: The Greek letter θ (theta) is often used to denote an angle.  Since a polar coordinate is conventionally referred to as (r, θ), we’ll use theta as a variable name when referring to an angle."/>
<figcaption/>
</figure>
<p><strong formula>sine(theta) &#160;&#160;= y/r &#160;&#160;&#8594;&#160;&#160; y = r <code>*</code> sine(theta)</strong><br/>
<strong formula>cosine(theta) = x/r &#160;&#160;&#8594;&#160;&#160; x = r <code>*</code> cosine(theta)</strong></p>

<p><a data-type="indexterm" data-primary=""Cartesian coordinates"" data-secondary=""polar coordinates" data-tertiary="converting from"">&nbsp;</a>
<a data-type="indexterm" data-primary=""cos() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""polar coordinates"" data-secondary=""Cartesian coordinates" data-tertiary="converting to"">&nbsp;</a>
<a data-type="indexterm" data-primary=""sin() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""cos() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""sin() function (Processing)"">&nbsp;</a></p>

<p>For example, if <strong var>r</strong> is 75 and <strong var>theta</strong> is 45 degrees (or PI/4 radians), we can calculate <strong var>x</strong> and <strong var>y</strong> as below.  The functions for sine and cosine in Processing are <strong function>sin()</strong> and <strong function>cos()</strong>, respectively.  They each take one argument, an angle measured in radians.</p>

<pre data-type="programlisting" data-code-language="java">float r = 75;
float theta = PI / 4;
//[full] Converting from polar (r,theta) to Cartesian (x,y)
float x = r * cos(theta);
float y = r * sin(theta);
//[end]</pre>

<p><a data-type="indexterm" data-primary=""shapes"" data-secondary=""moving with polar coordinates"">&nbsp;</a></p>

<p>This type of conversion can be useful in certain applications.  For example, to move a shape along a circular path using Cartesian coordinates is not so easy.  With polar coordinates, on the other hand, it’s simple: increment the angle!</p>

<p>Here’s how it is done with global variables <strong var>r</strong> and <strong var>theta</strong>.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_04_PolarToCartesian/_3_04_PolarToCartesian.pde">
<img src="imgs/chapter03/ch03_ex04.png" alt="ch03 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 3.4: Polar to Cartesian</strong></p>

<pre data-type="programlisting" data-code-language="java">float r = 75;
float theta = 0;

void setup() {
  size(640,360);
  background(255);
}

void draw() {

  //[full] Polar coordinates (r,theta) are converted to Cartesian (x,y) for use in the ellipse() function.
  float x = r * cos(theta);
  float y = r * sin(theta);
  //[end]

  noStroke();
  fill(0);
  ellipse(x+width/2, y+height/2, 16, 16);

  theta += 0.01;
}</pre>

<div id="chapter03_exercise4" data-type="example">
<h5>Exercise 3.4</h5>
<p>Using Example 3.4 as a basis, draw a spiral path.  Start in the center and move outwards.  Note that this can be done by only changing one line of code and adding one line of code!</p>

<figure>
<img src="imgs/chapter03/ch03_exc04.png" alt="ch03 exc04"/>
<figcaption/>
</figure></div>

<div id="chapter03_exercise5" data-type="example">
<h5>Exercise 3.5</h5>
<p>Simulate the spaceship in the game Asteroids.   In case you aren’t familiar with Asteroids, here is a brief description: A spaceship (represented as a triangle) floats in two dimensional space.   The left arrow key turns the spaceship counterclockwise, the right arrow key, clockwise.  The <em>z</em> key applies a “thrust” force in the direction the spaceship is pointing.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/Ex_3_05_asteroids/Ex_3_05_asteroids.pde processingjs/chapter03/Ex_3_05_asteroids/Spaceship.pde">
<img src="imgs/chapter03/ch03_exc05.png" alt="ch03 exc05"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter03_section6">
<h1>3.6 Oscillation Amplitude and Period</h1>
<p><a data-type="indexterm" data-primary=""oscillation"">&nbsp;</a></p>

<p>Are you amazed yet?  We’ve seen some pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates).   We could stop right here and be satisfied.  But we’re not going to.  This is only the beginning.  What sine and cosine can do for you goes beyond mathematical formulas and right triangles.</p>

<p>Let’s take a look at a graph of the sine function, where <em>y = sine(x)</em>.</p>

<figure id="chapter03_figure9">
<img src="imgs/chapter03/ch03_09.png" alt="Figure 3.9: y = sine(x)"/>
<figcaption/>
</figure>
<p>You’ll notice that the output of the sine function is a smooth curve alternating between –1 and 1.  This type of a behavior is known as <strong><em>oscillation</em></strong>, a periodic movement between two points.  Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—these are all examples of oscillating motion.</p>

<p><a data-type="indexterm" data-primary=""oscillation"" data-secondary=""simulating with sine curves"">&nbsp;</a></p>

<p>And so we happily discover that we can simulate oscillation in a Processing sketch by assigning the output of the sine function to an object’s location.  Note that this will follow the same methodology we applied to Perlin noise in the <a href="#intro_section6">Introduction</a>.</p>

<p>Let’s begin with a really basic scenario.  We want a circle to oscillate from the left side to the right side of a Processing window.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_05_simple_harmonic_motion/_3_05_simple_harmonic_motion.pde">
<img src="imgs/chapter03/ch03_ex05.png" alt="ch03 ex05"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""oscillation"" data-secondary=""simple harmonic motion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""simple harmonic motion"">&nbsp;</a></p>

<p>This is what is known as <strong><em>simple harmonic motion</em></strong> (or, to be fancier, “the periodic sinusoidal oscillation of an object”).   It&#8217;s going to be a simple program to write, but before we get into the code, let’s familiarize ourselves with some of the terminology of oscillation (and waves).</p>

<p>Simple harmonic motion can be expressed as any location (in our case, the <strong var>x</strong> location) as a function of time, with the following two elements:</p>

<p><a data-type="indexterm" data-primary=""amplitude"">&nbsp;</a>
<a data-type="indexterm" data-primary=""oscillation"" data-secondary=""amplitude"">&nbsp;</a>
<a data-type="indexterm" data-primary=""oscillation"" data-secondary=""period"">&nbsp;</a>
<a data-type="indexterm" data-primary=""period"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Amplitude</em></strong>: The distance from the center of motion to either extreme<br/></p></li>
<li>
<p><strong><em>Period</em></strong>: The amount of time it takes for one complete cycle of motion</p></li>
</ul>

<p>Looking at the graph of sine (Figure 3.9), we can see that the amplitude is 1 and the period is <strong var>TWO_PI</strong>; the output of sine never rises above 1 or below -1; and every <strong var>TWO_PI</strong> radians (or 360 degrees) the wave pattern repeats.</p>

<p>Now, in the Processing world we live in, what is amplitude and what is period?  Amplitude can be measured rather easily in pixels.   In the case of a window 200 pixels wide, we would oscillate from the center 100 pixels to the right and 100 pixels to the left. Therefore:</p>

<pre data-type="programlisting" data-code-language="java">// Our amplitude is measured in pixels.
float amplitude = 100;</pre>

<p><a data-type="indexterm" data-primary=""millis() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""measuring time in"">&nbsp;</a>
<a data-type="indexterm" data-primary=""time"" data-secondary=""millis() function" data-tertiary="measuring with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""period"">&nbsp;</a></p>

<p><em>Period</em> is the amount of time it takes for one cycle, but what is time in our Processing world?  I mean, certainly we could say we want the circle to oscillate every three seconds.  And we could track the milliseconds—using <strong function>millis()</strong> —in Processing and come up with an elaborate algorithm for oscillating an object according to real-world time.   But for us, real-world time doesn’t really matter. The real measure of time in Processing is in frames.  The oscillating motion should repeat every 30 frames, or 50 frames, or 1000 frames, etc.</p>

<pre data-type="programlisting" data-code-language="java">// Our period is measured in frames (our unit of time for animation).
float period = 120;</pre>

<p>Once we have the amplitude and period, it’s time to write a formula to calculate x as a function of time, which we now know is the current frame count.</p>

<pre data-type="programlisting" data-code-language="java">float x = amplitude * cos(TWO_PI * frameCount / period);</pre>

<p><a data-type="indexterm" data-primary=""map() function (Processing)"" data-secondary=""oscillation and"">&nbsp;</a></p>

<p>Let’s dissect the formula a bit more and try to understand each component.   The first is probably the easiest.   Whatever comes out of the cosine function we multiply by amplitude.   We know that cosine will oscillate between -1 and 1. If we take that value and multiply it by amplitude then we’ll get the desired result: a value oscillating between -amplitude and amplitude.   (Note: this is also a place where we could use Processing’s <strong function>map()</strong> function to map the output of cosine to a custom range.)</p>

<p>Now, let’s look at what is inside the cosine function:</p>

<p><strong formula>TWO_PI <code>*</code> frameCount / period</strong></p>

<p>What’s going on here?   Let’s start with what we know.  We know that cosine will repeat every 2*PI radians—i.e. it will start at 0 and repeat at 2*PI, 4*PI, 6*PI, etc.   If the period is 120, then we want the oscillating motion to repeat when the <strong var>frameCount</strong> is at 120 frames, 240 frames, 360 frames, etc.  <strong var>frameCount</strong> is really the only variable; it starts at 0 and counts upward.   Let’s take a look at what the formula yields with those values.</p>

<table>

<thead>
<tr>
<th>frameCount</th>
<th>frameCount / period</th>
<th>TWO_PI * frameCount / period</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr>
<td><p>60</p></td>
<td><p>0.5</p></td>
<td><p>PI</p></td>
</tr>
<tr>
<td><p>120</p></td>
<td><p>1</p></td>
<td><p>TWO_PI</p></td>
</tr>
<tr>
<td><p>240</p></td>
<td><p>2</p></td>
<td><p>2 * TWO_PI (or 4* PI)</p></td>
</tr>
<tr>
<td><p>etc.</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p><strong var>frameCount</strong> divided by <strong var>period</strong> tells us how many cycles we’ve completed—are we halfway through the first cycle?  Have we completed two  cycles?  By multiplying that number by <strong var>TWO_PI</strong>, we get the result we want, since <strong var>TWO_PI</strong> is the number of radians required for one cosine (or sine) to complete one cycle.</p>

<p>Wrapping this all up, here’s the Processing example that oscillates the <strong var>x</strong> location of a circle with an amplitude of 100 pixels and a period of 120 frames.</p>

<p><strong example>Example 3.5: Simple Harmonic Motion</strong></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
}

void draw() {
  background(255);

  float period = 120;
  float amplitude = 100;
  //[offset-down] Calculating horizontal location according to the formula for simple harmonic motion
  float x = amplitude * cos(TWO_PI * frameCount / period);
  stroke(0);
  fill(175);
  translate(width/2,height/2);
  line(0,0,x,0);
  ellipse(x,0,20,20);
}</pre>

<p><a data-type="indexterm" data-primary=""frequency (of oscillations)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""oscillation"" data-secondary=""frequency of"">&nbsp;</a></p>

<p>It’s also worth mentioning the term <strong><em>frequency</em></strong>: the number of cycles per time unit.  Frequency is equal to 1 divided by <strong var>period</strong>.  If the period is 120 frames, then only 1/120th of a cycle is completed in one frame, and so frequency = 1/120.   In the above example, we simply chose to define the rate of oscillation in terms of period and therefore did not need a variable for frequency.</p>

<div id="chapter03_exercise6" data-type="example">
<h5>Exercise 3.6</h5>
<p>Using the sine function, create a simulation of a weight (sometimes referred to as a “bob”) that hangs from a spring from the top of the window.  Use the <strong function>map()</strong> function to calculate the vertical location of the bob.  Later in this chapter, we’ll see how to recreate this same simulation by modeling the forces of a spring according to Hooke’s law.</p>
</div>
</section>







<section data-type="sect1" id="chapter03_section7">
<h1>3.7 Oscillation with Angular Velocity</h1>
<p><a data-type="indexterm" data-primary=""angular velocity" data-secondary="oscillation with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""oscillation"" data-secondary=""angular velocity and"">&nbsp;</a></p>

<p>An understanding of the concepts of oscillation, amplitude, and frequency/period is often required in the course of simulating real-world behaviors.  However, there is a slightly easier way to rewrite the above example with the same result.  Let’s take one more look at our oscillation formula:</p>

<pre data-type="programlisting" data-code-language="java">float x = amplitude * cos(TWO_PI * frameCount / period);</pre>

<p>And let’s rewrite it a slightly different way:</p>

<pre data-type="programlisting" data-code-language="java">float x = amplitude * cos ( some value that increments slowly );</pre>

<p>If we care about precisely defining the period of oscillation in terms of frames of animation, we might need the formula the way we first wrote it, but we can just as easily rewrite our example using the concept of angular velocity (and acceleration) from <a href="#chapter03_section2">section 3.2</a>.  Assuming:</p>

<pre data-type="programlisting" data-code-language="java">float angle = 0;
float aVelocity = 0.05;</pre>

<p>in <strong function>draw()</strong>, we can simply say:</p>

<pre data-type="programlisting" data-code-language="java">angle += aVelocity;
float x = amplitude * cos(angle);</pre>

<p><strong var>angle</strong> is our “some value that increments slowly.”</p>

<p><strong example>Example 3.6: Simple Harmonic Motion II</strong></p>

<pre data-type="programlisting" data-code-language="java">float angle = 0;
float aVelocity = 0.05;

void setup() {
  size(640,360);
}

void draw() {
  background(255);

  float amplitude = 100;
  float x = amplitude * cos(angle);
  // Using the concept of angular velocity to increment an angle variable
  angle += aVelocity;

  ellipseMode(CENTER);
  stroke(0);
  fill(175);
  translate(width/2,height/2);
  line(0,0,x,0);
  ellipse(x,0,20,20);
}</pre>

<p>Just because we’re not referencing it directly doesn’t mean that we’ve eliminated the concept of <strong var>period</strong>.  After all, the greater the angular velocity, the faster the circle will oscillate (therefore lowering the period).   In fact, the number of times it takes to add up the angular velocity to get to <strong var>TWO_PI</strong> is the period or:</p>

<p><strong formula>period = TWO_PI / angular velocity</strong></p>

<p><a data-type="indexterm" data-primary=""oscillation"" data-secondary=""on two axes"">&nbsp;</a></p>

<p>Let’s expand this example a bit more and create an <strong klass>Oscillator</strong> class.  And let’s assume we want the oscillation to happen along both the x-axis (as above) and the y-axis.  To do this, we’ll need two angles, two angular velocities, and two amplitudes (one for each axis).   Another perfect opportunity for <strong klass>PVector</strong>!</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_07_oscillating_objects/_3_07_oscillating_objects.pde processingjs/chapter03/_3_07_oscillating_objects/Oscillator.pde">
<img src="imgs/chapter03/ch03_ex07.png" alt="ch03 ex07"/>
<figcaption/>
</figure>
<p><strong example>Example 3.7: Oscillator objects</strong></p>

<pre data-type="programlisting" data-code-language="java">class Oscillator  {

  // Using a PVector to track two angles!
  PVector angle;
  PVector velocity;
  PVector amplitude;

  Oscillator()  {
    angle = new PVector();
    velocity = new PVector(random(-0.05,0.05),random(-0.05,0.05));
    //[offset-down] Random velocities and amplitudes
    amplitude = new PVector(random(width/2),random(height/2));
  }

  void oscillate()  {
    angle.add(velocity);
  }

  void display()  {
    // Oscillating on the x-axis
    float x = sin(angle.x)*amplitude.x;
    // Oscillating on the y-axis
    float y = sin(angle.y)*amplitude.y;

    pushMatrix();
    translate(width/2,height/2);
    stroke(0);
    fill(175);
    // Drawing the Oscillator as a line connecting a circle
    line(0,0,x,y);
    ellipse(x,y,16,16);
    popMatrix();
  }
}</pre>

<div id="chapter03_exercise7" data-type="example">
<h5>Exercise 3.7</h5>
<p>Try initializing each <strong klass>Oscillator</strong> object with velocities and amplitudes that are not random to create some sort of regular pattern.  Can you make the oscillators appear to be the legs of a insect-like creature?</p>
</div>

<div id="chapter03_exercise8" data-type="example">
<h5>Exercise 3.8</h5>
<p>Incorporate angular acceleration into the <strong klass>Oscillator</strong> object.</p>
</div>
</section>







<section data-type="sect1" id="chapter03_section8">
<h1>3.8 Waves</h1>
<p><a data-type="indexterm" data-primary=""oscillation"" data-secondary=""waves"">&nbsp;</a>
<a data-type="indexterm" data-primary=""waves"">&nbsp;</a></p>

<p>If you’re saying to yourself, “Um, this is all great and everything, but what I really want is to draw a wave onscreen,” well, then, the time has come.   The thing is, we’re about 90% there.  When we oscillate a single circle up and down according to the sine function, what we are doing is looking at a single point along the x-axis of a wave pattern.  With a little panache and a <strong function>for</strong> loop, we can place a whole bunch of these oscillating circles next to each other.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_09_wave/_3_09_wave.pde">
<img src="imgs/chapter03/ch03_ex09.png" alt="ch03 ex09"/>
<figcaption/>
</figure>
<p>This wavy pattern could be used in the design of the body or appendages of a creature, as well as to simulate a soft surface (such as water).</p>

<p><a data-type="indexterm" data-primary=""period"" data-secondary=""defined in pixels rather than frames"">&nbsp;</a>
<a data-type="indexterm" data-primary=""waves"" data-secondary=""angular velocity" data-tertiary="defining with"">&nbsp;</a></p>

<p>Here, we’re going to encounter the same questions of amplitude (height of pattern) and period.  Instead of period referring to time, however, since we’re looking at the full wave, we can talk about period as the width (in pixels) of a full wave cycle.    And just as with simple oscillation, we have the option of computing the wave pattern according to a precise period or simply following the model of angular velocity.</p>

<p>Let’s go with the simpler case, angular velocity.   We know we need to start with an angle, an angular velocity, and an amplitude:</p>

<pre data-type="programlisting" data-code-language="java">float angle = 0;
float angleVel = 0.2;
float amplitude = 100;</pre>

<p>Then we’re going to loop through all of the <strong var>x</strong> values where we want to draw a point of the wave.  Let’s say every 24 pixels for now.  In that loop, we’re going to want to do three things:</p>

<ol>
<li>
<p>Calculate the y location according to amplitude and sine of the angle.</p></li>
<li>
<p>Draw a circle at the <em>(x,y)</em> location.</p></li>
<li>
<p>Increment the angle according to angular velocity.</p></li>
</ol>

<pre data-type="programlisting" data-code-language="java">  for (int x = 0; x &lt;= width; x += 24) {

    // 1) Calculate the y location according to
    // amplitude and sine of the angle.
    float y = amplitude*sin(angle);

    // 2) Draw a circle at the (x,y) location.
    ellipse(x,y+height/2,48,48);

    // 3) Increment the angle according to angular velocity.
    angle += angleVel;
  }</pre>

<p>Let’s look at the results with different values for <strong var>angleVel</strong>:</p>

<figure class="three-col" data-pde="processingjs/chapter03/_3_09_wave_a/_3_09_wave_a.pde">
<img src="imgs/chapter03/ch03_ex09a.png" alt="angleVel = 0.05"/>
<figcaption/>
</figure>
<figure class="three-col" data-pde="processingjs/chapter03/_3_09_wave_b/_3_09_wave_b.pde">
<img src="imgs/chapter03/ch03_ex09b.png" alt="angleVel = 0.2"/>
<figcaption/>
</figure>
<figure class="three-col" data-pde="processingjs/chapter03/_3_09_wave_c/_3_09_wave_c.pde">
<img src="imgs/chapter03/ch03_ex09c.png" alt="angleVel = 0.4"/>
<figcaption/>
</figure>
<p>Notice how, although we’re not precisely computing the period of the wave, the higher the angular velocity, the shorter the period.  It’s also worth noting that as the period becomes shorter, it becomes more and more difficult to make out the wave itself as the distance between the individual points increases.  One option we have is to use <strong function>beginShape()</strong> and <strong function>endShape()</strong> to connect the points with a line.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_08_static_wave_lines/_3_08_static_wave_lines.pde">
<img src="imgs/chapter03/ch03_ex08.png" alt="ch03 ex08"/>
<figcaption/>
</figure>
<p><strong example>Example 3.8: Static wave drawn as a continuous line</strong></p>

<pre data-type="programlisting" data-code-language="java">float angle = 0;
float angleVel = 0.2;
float amplitude = 100;

size(400,200);
background(255);

stroke(0);
strokeWeight(2);
noFill();

beginShape();
for (int x = 0; x &lt;= width; x += 5) {
  // Here’s an example of using the map() function
  // instead.
  float y = map(sin(angle),-1,1,0,height);
  // With beginShape() and endShape(), you call
  // vertex() to set all the vertices of your shape.
  vertex(x,y);
  angle +=angleVel;
}
endShape();</pre>

<p><a data-type="indexterm" data-primary=""oscillation"" data-secondary=""varying"">&nbsp;</a>
<a data-type="indexterm" data-primary=""waves"" data-secondary=""varying"">&nbsp;</a></p>

<p>You may have noticed that the above example is static.  The wave never changes, never undulates.   This additional step is a bit tricky.  Your first instinct might be to say: “Hey, no problem, we’ll just let theta be a global variable and let it increment from one cycle through <strong function>draw()</strong> to another.”</p>

<p>While it’s a nice thought, it doesn’t work.   If you look at the wave, the righthand edge doesn’t match the lefthand; where it ends in one cycle of <strong function>draw()</strong> can’t be where it starts in the next.  Instead, what we need to do is have a variable dedicated entirely to tracking what value of angle the wave should start with.   This angle (which we’ll call <strong var>startAngle</strong>) increments with its own angular velocity.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_09_wave/_3_09_wave.pde">
<img src="imgs/chapter03/ch03_ex09.png" alt="ch03 ex09"/>
<figcaption/>
</figure>
<p><strong example>Example 3.9: The Wave</strong></p>

<pre data-type="programlisting" data-code-language="java">float startAngle = 0;
float angleVel = 0.1;

void setup() {
  size(400,200);
}

void draw() {
  background(255);

  //[full] In order to move the wave, we start at a different theta value each frame.  startAngle += 0.02;
float angle = startAngle;
  //[end]

  for (int x = 0; x &lt;= width; x += 24) {
    float y = map(sin(angle),-1,1,0,height);
    stroke(0);
    fill(0,50);
    ellipse(x,y,48,48);
    angle += angleVel;
  }
}</pre>

<div id="chapter03_exercise9" data-type="example">
<h5>Exercise 3.9</h5>
<p>Try using the Perlin noise function instead of sine or cosine with the above example.</p>
</div>

<div id="chapter03_exercise10" data-type="example">
<h5>Exercise 3.10</h5>
<p>Encapsulate the above examples into a <strong klass>Wave</strong> class and create a sketch that displays two waves (with different amplitudes/periods) as in the screenshot below.  Move beyond plain circles and lines and try visualizing the wave in a more creative way.</p>

<figure data-pde="processingjs/chapter03/Ex_3_10_OOPWave/Ex_3_10_OOPWave.pde processingjs/chapter03/Ex_3_10_OOPWave/Wave.pde">
<img src="imgs/chapter03/ch03_exc10.png" alt="ch03 exc10"/>
<figcaption/>
</figure></div>

<div id="chapter03_exercise11" data-type="example">
<h5>Exercise 3.11</h5>
<p>More complex waves can be produced by the values of multiple waves together.  Create a sketch that implements this, as in the screenshot below.</p>

<figure data-pde="processingjs/chapter03/Ex_3_11_AdditiveWave/Ex_3_11_AdditiveWave.pde">
<img src="imgs/chapter03/ch03_exc11.png" alt="ch03 exc11"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter03_section9">
<h1>3.9 Trigonometry and Forces: The Pendulum</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""trigonometry and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""pivots" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""pivots" data-secondary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trigonometry"" data-secondary=""forces and"">&nbsp;</a></p>

<p>Do you miss Newton’s laws of motion?  I know I sure do.  Well, lucky for you, it’s time to bring it all back home.  After all, it’s been nice learning about triangles and tangents and waves, but really, the core of this book is about simulating the physics of moving bodies.  Let’s take a look at how trigonometry can help us with this pursuit.</p>

<figure id="chapter03_figure10" class="two-col-borderless">
<img src="imgs/chapter03/ch03_10.png" alt="Figure 3.10"/>
<figcaption/>
</figure>
<figure id="chapter03_figure11" class="two-col-borderless">
<img src="imgs/chapter03/ch03_11.png" alt="Figure 3.11"/>
<figcaption/>
</figure>
<p>A pendulum is a bob suspended from a pivot.  Obviously a real-world pendulum would live in a 3D space, but we’re going to look at a simpler scenario, a pendulum in a 2D space—a Processing window (see Figure 3.10).</p>

<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""angular" data-tertiary="determining"">&nbsp;</a>
<a data-type="indexterm" data-primary=""angular acceleration"">&nbsp;</a></p>

<p>In Chapter 2, we learned how a force (such as the force of gravity in Figure 3.11) causes an object to accelerate. <strong mono>F = M <code>*</code> A</strong> or <strong mono>A = F / M</strong>.  In this case, however, the pendulum bob doesn’t simply fall to the ground because it is attached by an arm to the pivot point.  And so, in order to determine its <em>angular</em> acceleration, we not only need to look at the force of gravity, but also the force at the angle of the pendulum’s arm (relative to a pendulum at rest with an angle of 0).</p>

<p>In the above case, since the pendulum’s arm is of fixed length, the only variable in the scenario is the angle.  We are going to simulate the pendulum’s motion through the use of angular velocity and acceleration.   The angular acceleration will be calculated using Newton’s second law with a little trigonometry twist.</p>

<p>Let’s zoom in on the right triangle from the pendulum diagram.</p>

<figure id="chapter03_figure12" class="half-width-right">
<img src="imgs/chapter03/ch03_12.png" alt="Figure 3.12"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""modeling with trigonometry"">&nbsp;</a></p>

<p>We can see that the force of the pendulum (<strong var>F<sub>p</sub></strong>) should point perpendicular to the arm of the pendulum in the direction that the pendulum is swinging.  After all, if there were no arm, the bob would just fall straight down.  It’s the tension force of the arm that keeps the bob accelerating towards the pendulum’s rest state. Since the force of gravity (<strong var>F<sub>g</sub></strong>) points downward, by making a right triangle out of these two vectors, we’ve accomplished something quite magnificent.  We’ve made the force of gravity the hypotenuse of a right triangle and separated the vector into two components, one of which represents the force of the pendulum.   Since sine equals opposite over hypotenuse, we have:</p>

<p><strong formula>sine(θ) = F<sub>p</sub> / F<sub>g</sub></strong></p>

<p>Therefore:</p>

<p><strong formula>F<sub>p</sub> = F<sub>g</sub> <code>*</code> sine(θ)</strong></p>

<p>Lest we forget, we’ve been doing all of this with a single question in mind:  What is the angular acceleration of the pendulum?    Once we have the angular acceleration, we’ll be able to apply our rules of motion to find the new angle for the pendulum.</p>

<p><strong formula>angular velocity = angular velocity + angular acceleration</strong><br/>
<strong formula>angle = angle + angular velocity</strong></p>

<p>The good news is that with Newton’s second law, we know that there is a relationship between force and acceleration, namely F = M * A, or A = F / M.  So if the force of the pendulum is equal to the force of gravity times sine of the angle, then:</p>

<p><strong formula>pendulum angular acceleration = acceleration due to gravity <code>*</code> sine (θ)</strong></p>

<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""modeling reality vs. arbitrary values"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""modeling reality vs. arbitrary values"">&nbsp;</a></p>

<p>This is a good time to remind ourselves that we’re Processing programmers and not physicists.   Yes, we know that the acceleration due to gravity on earth is 9.8 meters per second squared.  But this number isn’t relevant to us.  What we have here is just an arbitrary constant (we’ll call it <strong var>gravity</strong>), one that we can use to scale the acceleration to something that feels right.</p>

<p><strong formula>angular acceleration = gravity <code>*</code> sine(θ)</strong></p>

<p>Amazing.  After all that, the formula is so simple.  You might be wondering, why bother going through the derivation at all?  I mean, learning is great and all, but we could have easily just said, "Hey, the angular acceleration of a pendulum is some constant times the sine of the angle."   This is just another moment in which we remind ourselves that the purpose of the book is not to learn how pendulums swing or gravity works.  The point is to think creatively about how things can move about the screen in a computationally based graphics system.  The pendulum is just a case study.   If you can understand the approach to programming a pendulum, then however you choose to design your onscreen world, you can apply the same techniques.</p>

<p>Of course, we’re not finished yet.  We may be happy with our simple, elegant formula, but we still have to apply it in code.   This is most definitely a good time to practice our object-oriented programming skills and create a <strong klass>Pendulum</strong> class.  Let’s think about all the properties we’ve encountered in our pendulum discussion that the class will need:</p>

<ul>
<li>
<p>arm length</p></li>
<li>
<p>angle</p></li>
<li>
<p>angular velocity</p></li>
<li>
<p>angular acceleration</p></li>
</ul>

<pre data-type="programlisting" data-code-language="java">class Pendulum  {

  // Length of arm
  float r;
  // Pendulum arm angle
  float angle;
  // Angular velocity
  float aVelocity;
  // Angular acceleration
  float aAcceleration;</pre>

<p>We’ll also need to write a function <strong function>update()</strong> to update the pendulum’s angle according to our formula&#8230;</p>

<pre data-type="programlisting" data-code-language="java">  void update() {
    // Arbitrary constant
    float gravity = 0.4;
    // Calculate acceleration according to our formula.
    aAcceleration = -1 * gravity * sin(angle);
    // Increment velocity.
    aVelocity += aAcceleration;
    // Increment angle.
    angle += aVelocity;
  }</pre>

<figure id="chapter03_figure13" class="half-width-right">
<img src="imgs/chapter03/ch03_13.png" alt="Figure 3.13"/>
<figcaption/>
</figure>
<p>&#8230;as well as a function <strong function>display()</strong> to draw the pendulum in the window. This begs the question: “Um, where do we draw the pendulum?”  We know the angle and the arm length, but how do we know the <em>x,y</em> (Cartesian!) coordinates for both the pendulum’s pivot point (let’s call it origin) and bob location (let’s call it location)?  This may be getting a little tiring, but the answer, yet again, is trigonometry.</p>

<p>The origin is just something we make up, as is the arm length.  Let’s say:</p>

<pre data-type="programlisting" data-code-language="java">PVector origin = new PVector(100,10);
float r = 125;</pre>

<p>We’ve got the current angle stored in our variable <strong var>angle</strong>.   So relative to the origin, the pendulum’s location is a polar coordinate: <em>(r,angle)</em>.  And we need it to be Cartesian.  Luckily for us, we just spent some time (section 3.5) deriving the formula for converting from polar to Cartesian.  And so:</p>

<pre data-type="programlisting" data-code-language="java">PVector location = new PVector(r*sin(angle),r*cos(angle));</pre>

<p>Since the location is relative to wherever the origin happens to be, we can just add origin to the location <strong klass>PVector</strong>:</p>

<pre data-type="programlisting" data-code-language="java">location.add(origin);</pre>

<p>And all that remains is the little matter of drawing a line and ellipse (you should be more creative, of course).</p>

<pre data-type="programlisting" data-code-language="java">stroke(0);
fill(175);
line(origin.x,origin.y,location.x,location.y);
ellipse(location.x,location.y,16,16);</pre>

<p>Before we put everything together, there’s one last little detail I neglected to mention.  Let’s think about the pendulum arm for a moment.  Is it a metal rod?  A string?  A rubber band?  How is it attached to the pivot point?  How long is it?  What is its mass?  Is it a windy day?  There are a lot of questions that we could continue to ask that would affect the simulation.  We’re living, of course, in a fantasy world, one where the pendulum’s arm is some idealized rod that never bends and the mass of the bob is concentrated in a single, infinitesimally small point.   Nevertheless, even though we don’t want to worry ourselves with all of the questions, we should add one more variable to our calculation of angular acceleration.   To keep things simple, in our derivation of the pendulum’s acceleration, we assumed that the length of the pendulum’s arm is 1.   In fact, the length of the pendulum’s arm affects the acceleration greatly: the longer the arm, the slower the acceleration.  To simulate a pendulum more accurately, we divide by that length, in this case <strong var>r</strong>.  For a more involved explanation, visit <a href="http://calculuslab.deltacollege.edu/ODE/7-A-2/7-A-2-h.html">The Simple Pendulum website</a>.</p>

<pre data-type="programlisting" data-code-language="java">aAcceleration = (-1 * G * sin(angle)) / r;</pre>

<p><a data-type="indexterm" data-primary=""acceleration"" data-secondary=""damping"">&nbsp;</a>
<a data-type="indexterm" data-primary=""damping"">&nbsp;</a>
<a data-type="indexterm" data-primary=""forces"" data-secondary=""damping"">&nbsp;</a>
<a data-type="indexterm" data-primary=""friction"" data-secondary=""damping"">&nbsp;</a></p>

<p>Finally, a real-world pendulum is going to experience some amount of friction (at the pivot point) and air resistance.   With our code as is, the pendulum would swing forever, so to make it more realistic we can use a “damping” trick.  I say <em>trick</em> because rather than model the resistance forces with some degree of accuracy (as we did in Chapter 2), we can achieve a similar result by simply reducing the angular velocity during each cycle.  The following code reduces the velocity by 1% (or multiplies it by 99%) during each frame of animation:</p>

<pre data-type="programlisting" data-code-language="java">aVelocity *= 0.99;</pre>

<p>Putting everything together, we have the following example (with the pendulum beginning at a 45-degree angle).</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_10_PendulumExample/_3_10_PendulumExample.pde processingjs/chapter03/_3_10_PendulumExample/Pendulum.pde">
<img src="imgs/chapter03/ch03_ex10.png" alt="ch03 ex10"/>
<figcaption/>
</figure>
<p><strong example>Example 3.10: Swinging pendulum</strong></p>

<pre data-type="programlisting" data-code-language="java">Pendulum p;

void setup() {
  size(640,360);
  // We make a new Pendulum object with
  // an origin location and arm length.
  p = new Pendulum(new PVector(width/2,10),125);
}

void draw() {
  background(255);
  p.go();
}

class Pendulum  {
  //[full] Many, many variables to keep track of the Pendulum’s various properties
  PVector location;    // Location of bob
  PVector origin;      // Location of arm origin
  float r;             // Length of arm
  float angle;         // Pendulum arm angle
  float aVelocity;     // Angle velocity
  float aAcceleration; // Angle acceleration
  float damping;       // Arbitrary damping amount
  //[end]

  Pendulum(PVector origin_, float r_) {
    origin = origin_.get();
    location = new PVector();
    r = r_;
    angle = PI/4;

    aVelocity = 0.0;
    aAcceleration = 0.0;
    // An arbitrary damping so that the Pendulum slows
    // over time
    damping = 0.995;
  }

  void go() {
    update();
    display();
  }

  void update() {
    float gravity = 0.4;
    //[offset-up] Formula we worked out for angular acceleration
    aAcceleration = (-1 * gravity / r) * sin(angle);

    //[full] Standard angular motion algorithm
    aVelocity += aAcceleration;
    angle += aVelocity;
    //[end]

    // Apply some damping.
    aVelocity *= damping;
  }

  void display() {
    // Where is the bob relative to the origin?
    // Polar to Cartesian coordinates will tell us!
    location.set(r*sin(angle),r*cos(angle),0);
    location.add(origin);

    stroke(0);
    // The arm
    line(origin.x,origin.y,location.x,location.y);
    fill(175);
    // The bob
    ellipse(location.x,location.y,16,16);
  }
}</pre>

<p><em>(Note that the version of the example posted on the website has additional code to allow the user to grab the pendulum and swing it with the mouse.)</em></p>

<div id="chapter03_exercise12" data-type="example">
<h5>Exercise 3.12</h5>
<p>String together a series of pendulums so that the endpoint of one is the origin point of another.  Note that doing this may produce intriguing results but will be wildly inaccurate physically.  Simulating an actual double pendulum involves sophisticated equations, which you can read about here: <a href="http://scienceworld.wolfram.com/physics/DoublePendulum.html"><em class="hyperlink">http://scienceworld.wolfram.com/physics/DoublePendulum.html</em></a>.</p>
</div>

<div id="chapter03_exercise13" data-type="example">
<h5>Exercise 3.13</h5>
<figure class="half-width-right">
<img src="imgs/chapter03/ch03_exc13.png" alt="ch03 exc13"/>
<figcaption/>
</figure>
<p>Using trigonometry, what is the magnitude of the normal force in the illustration on the right (the force perpendicular to the incline on which the sled rests)?   Note that, as indicated, the “normal” force is a component of the force of gravity.</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<div id="chapter03_exercise14" data-type="example">
<h5>Exercise 3.14</h5>
<p>Create an example that simulates a box sliding down the incline with friction.  Note that the magnitude of the friction force is equal to the normal force.</p>
</div>
</section>







<section data-type="sect1" id="chapter03_section10">
<h1>3.10 Spring Forces</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""springs"">&nbsp;</a>
<a data-type="indexterm" data-primary=""springs"">&nbsp;</a></p>

<p>In <a href="#chapter03_section6">section 3.6</a>, we looked at modeling simple harmonic motion by mapping the sine wave to a pixel range. <a href="#chapter03_exercise6">Exercise 3.6</a> asked you to use this technique to create a simulation of a bob hanging from a spring.  While using the <strong function>sin()</strong> function is a quick-and-dirty, one-line-of-code way of getting something up and running, it won’t do if what we really want is to have a bob hanging from a spring in a two-dimensional space that responds to other forces in the environment (wind, gravity, etc.)  To accomplish a simulation like this (one that is identical to the pendulum example, only now the arm is a springy connection), we need to model the forces of a spring using <strong klass>PVector</strong>.</p>

<figure id="chapter03_figure14">
<img src="imgs/chapter03/ch03_14.png" alt="Figure 3.14"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""Hooke's law"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Hooke's law"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Hooke" data-secondary="Robert"">&nbsp;</a>
<a data-type="indexterm" data-primary=""springs"" data-secondary=""Hooke's law"">&nbsp;</a></p>

<p>The force of a spring is calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the formula in 1660.  Hooke originally stated the law in Latin:  "<em>Ut tensio, sic vis</em>," or “As the extension, so the force.”   Let’s think of it this way:</p>

<p><strong highlight>The force of the spring is directly proportional to the extension of the spring.</strong></p>

<figure id="chapter03_figure15" class="half-width-right">
<img src="imgs/chapter03/ch03_15.png" alt="Figure 3.15: x = current length - rest length"/>
<figcaption/>
</figure>
<p>In other words, if you pull on the bob a lot, the force will be strong; if you pull on the bob a little, the force will be weak.  Mathematically, the law is stated as follows:</p>

<p><a data-type="indexterm" data-primary=""Hooke's law"" data-secondary=""formula for expressing"">&nbsp;</a></p>

<p><strong formula>F<sub>spring</sub> = - k <code>*</code> x</strong></p>

<ul>
<li>
<p><strong var>k</strong> is constant and its value will ultimately scale the force.  Is the spring highly elastic or quite rigid?</p></li>
<li>
<p><strong var>x</strong> refers to the displacement of the spring, i.e. the difference between the current length and the rest length.  The rest length is defined as the length of the spring in a state of equilibrium.</p></li>
</ul>

<p>Now remember, force is a vector, so we need to calculate both magnitude and direction.  Let’s look at one more diagram of the spring and label all the givens we might have in a Processing sketch.</p>

<figure id="chapter03_figure16">
<img src="imgs/chapter03/ch03_16.png" alt="Figure 3.16"/>
<figcaption/>
</figure>
<p>Let’s establish the following three variables as shown in Figure 3.16.</p>

<pre data-type="programlisting" data-code-language="java">PVector anchor;
PVector location;
float restLength;</pre>

<p><a data-type="indexterm" data-primary=""springs"" data-secondary=""magnitude of force" data-tertiary="determining"">&nbsp;</a></p>

<p>First, let’s use Hooke’s law to calculate the magnitude of the force.  We need to know <strong var>k</strong> and <strong var>x</strong>.  <strong var>k</strong> is easy; it’s just a constant, so let’s make something up.</p>

<pre data-type="programlisting" data-code-language="java">float k = 0.1;</pre>

<p><a data-type="indexterm" data-primary=""springs"" data-secondary=""rest length"">&nbsp;</a></p>

<p><strong var>x</strong> is perhaps a bit more difficult.  We need to know the “difference between the current length and the rest length.”  The rest length is defined as the variable <strong var>restLength</strong>.  What’s the current length?  The distance between the anchor and the bob.  And how can we calculate that distance?    How about the magnitude of a vector that points from the anchor to the bob?  (Note that this is exactly the same process we employed when calculating distance in Example 2.9: gravitational attraction.)</p>

<pre data-type="programlisting" data-code-language="java">// A vector pointing from anchor to bob
// gives us the current length of the spring.
PVector dir = PVector.sub(bob,anchor);
float currentLength = dir.mag();
float x = restLength - currentLength;</pre>

<p><a data-type="indexterm" data-primary=""springs"" data-secondary=""direction of force" data-tertiary="determining"">&nbsp;</a></p>

<p>Now that we’ve sorted out the elements necessary for the magnitude of the force (-1 * <strong var>k</strong> * <strong var>x</strong>), we need to figure out the direction, a unit vector pointing in the direction of the force.  The good news is that we already have this vector.  Right?  Just a moment ago we thought to ourselves: “How we can calculate that distance?  How about the magnitude of a vector that points from the anchor to the bob?”  Well, that is the direction of the force!</p>

<figure id="chapter03_figure17">
<img src="imgs/chapter03/ch03_17.png" alt="Figure 3.17"/>
<figcaption/>
</figure>
<p>In Figure 3.17, we can see that if we stretch the spring beyond its rest length, there should be a force pulling it back towards the anchor.  And if it shrinks below its rest length, the force should push it away from the anchor.   This reversal of direction is accounted for in the formula with the -1.  And so all we need to do is normalize the <strong klass>PVector</strong> we used for the distance calculation!  Let’s take a look at the code and rename that <strong klass>PVector</strong> variable as “force.”</p>

<pre data-type="programlisting" data-code-language="java">// Magnitude of spring force according to Hooke’s law
float k = 0.1;
PVector force = PVector.sub(bob,anchor);
float currentLength = force.mag();
float x = restLength - currentLength;

// Direction of spring force (unit vector)
force.normalize();

// Putting it together: direction and magnitude!
force.mult(-1 * k * x);</pre>

<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""structures" data-tertiary="choosing between"">&nbsp;</a></p>

<p>Now that we have the algorithm worked out for computing the spring force vector, the question remains: what object-oriented programming structure should we use?   This, again, is one of those situations in which there is no “correct” answer.  There are several possibilities; which one we choose depends on the program’s goals and one’s own personal coding style.   Still, since we’ve been working all along with a <strong klass>Mover</strong> class, let’s keep going with this same framework.  Let’s think of our <strong klass>Mover</strong> class as the spring’s “bob.”  The bob needs <strong var>location</strong>, <strong var>velocity</strong>, and <strong var>acceleration</strong> vectors to move about the screen.  Perfect—we’ve got that already!  And perhaps the bob experiences a gravity force via the <strong function>applyForce()</strong> function.  Just one more step—we need to apply the spring force:</p>

<pre data-type="programlisting" data-code-language="java">Bob bob;

void setup() {
  bob = new Bob();
}

void draw()  {
  // Our Chapter 2 “make-up-a-gravity force”
  PVector gravity = new PVector(0,1);
  bob.applyForce(gravity);
  //[full] We need to also calculate and apply a spring force!
  PVector springForce = _______________????  //[bold]
  bob.applyForce(spring); //[bold]
  //[end]

  // Our standard update() and display() functions
  bob.update();
  bob.display();
}</pre>

<figure id="chapter03_figure18">
<img src="imgs/chapter03/ch03_18.png" alt="Figure 3.18"/>
<figcaption/>
</figure>
<p>One option would be to write out all of the spring force code in the main <strong function>draw()</strong> loop.  But thinking ahead to when you might have multiple bobs and multiple spring connections, it makes a good deal of sense to write an additional class, a <strong klass>Spring</strong> class.  As shown in Figure 3.18, the <strong klass>Bob</strong> class keeps track of the movements of the bob; the <strong klass>Spring</strong> class keeps track of the spring’s anchor and its rest length and calculates the spring force on the bob.</p>

<p>This allows us to write a lovely main program as follows:</p>

<pre data-type="programlisting" data-code-language="java">Bob bob;
// Adding a Spring object
Spring spring;  //[bold]

void setup() {
  bob = new Bob();
  spring = new Spring();
}

void draw()  {
  PVector gravity = new PVector(0,1);
  bob.applyForce(gravity);

  // This new function in the Spring class will take care of
  // computing the force of the spring on the bob.
  spring.connect(bob); //[bold]

  bob.update();
  bob.display();
  spring.display();
}</pre>

<p>You may notice here that this is quite similar to what we did in <a href="#chapter02_example6">Example 2.6</a> with an attractor.   There, we said something like:</p>

<pre data-type="programlisting" data-code-language="java">  PVector force = attractor.attract(mover);
  mover.applyForce(force);</pre>

<p>The analogous situation here with a spring would be:</p>

<pre data-type="programlisting" data-code-language="java">  PVector force = spring.connect(bob);
  bob.applyForce(force);</pre>

<p>Nevertheless, in this example all we said was:</p>

<pre data-type="programlisting" data-code-language="java">  spring.connect(bob);</pre>

<p>What gives?   Why don’t we need to call <strong function>applyForce()</strong> on the bob?  The answer is, of course, that we do need to call <strong function>applyForce()</strong> on the bob.  Only instead of doing it in <strong function>draw()</strong>, we’re just demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the <strong function>connect()</strong> function to internally handle calling <strong function>applyForce()</strong> on the bob.</p>

<pre data-type="programlisting" data-code-language="java">  void connect(Bob b) {
    PVector force = some fancy calculations

    // The function connect() takes care of calling applyForce()
    // and therefore doesn’t have to return a vector to the calling
    // area.
    b.applyForce(force);
  }</pre>

<p>Why do it one way with the <strong klass>Attractor</strong> class and another way with the <strong klass>Spring</strong> class?    When we were first learning about forces, it was a bit clearer to show all the forces being applied in the main <strong function>draw()</strong> loop, and hopefully this helped you learn about force accumulation.  Now that we’re more comfortable with that, perhaps it’s simpler to embed some of the details inside the objects themselves.</p>

<p>Let’s take a look at the rest of the elements in the <strong klass>Spring</strong> class.</p>

<figure class="screenshot" data-pde="processingjs/chapter03/_3_11_spring/_3_11_spring.pde processingjs/chapter03/_3_11_spring/Mover.pde processingjs/chapter03/_3_11_spring/Spring.pde">
<img src="imgs/chapter03/ch03_ex11.png" alt="ch03 ex11"/>
<figcaption/>
</figure>
<p><strong example>Example 3.11: A Spring connection</strong></p>

<pre data-type="programlisting" data-code-language="java">class Spring {

  // We need to keep track of the spring’s anchor location.
  PVector anchor;

  // Rest length and spring constant variables
  float len;
  float k = 0.1;

  //[full] The constructor initializes the anchor point and rest length.
  Spring(float x, float y, int l) {
    anchor = new PVector(x,y);
    len = l;
  }
  //[end]

  // Calculate spring force—our implementation of Hooke’s Law.
  void connect(Bob b) {

    //[full] Get a vector pointing from anchor to Bob location.
    PVector force = //[bold]
      PVector.sub(b.location,anchor); //[bold]
    //[end]
    float d = force.mag(); //[bold]
    // Calculate the displacement between
    // distance and rest length.
    float stretch = d - len; //[bold]

    //[full] Direction and magnitude together!
    force.normalize(); //[bold]
    force.mult(-1 * k * stretch); //[bold]
    //[end]

    // Call applyForce() right here!
    b.applyForce(force);
  }

  //[full] Draw the anchor.
  void display() {
    fill(100);
    rectMode(CENTER);
    rect(anchor.x,anchor.y,10,10);
  }
  //[end]

  //[full] Draw the spring connection between Bob location and anchor.
  void displayLine(Bob b) {
    stroke(255);
    line(b.location.x,b.location.y,anchor.x,anchor.y);
  }
  //[end]

}</pre>

<p>The full code for this example is included on the book website, and the Web version also incorporates two additional features: (1) the <strong klass>Bob</strong> class includes functions for mouse interactivity so that the bob can be dragged around the window, and (2) the <strong klass>Spring</strong> object includes a function to constrain the connection’s length between a minimum and a maximum.</p>

<div id="chapter03_exercise15" data-type="example">
<h5>Exercise 3.15</h5>
<p>Before running to see the example online, take a look at this constrain function and see if you can fill in the blanks.</p>

<pre data-type="programlisting" data-code-language="java">void constrainLength(Bob b, float minlen, float maxlen) {
  // Vector pointing from Bob to Anchor
  PVector dir = PVector.sub(______,______);
  float d = dir.mag();

  // Is it too short?
  if (d &lt; minlen) {
    dir.normalize();
    dir.mult(________);
    // Keep location within constraint.
    b.location = PVector.add(______,______);
    b.velocity.mult(0);
  // Is it too long?
  } else if (____________) {
    dir.normalize();
    dir.mult(_________);
    // Keep location within constraint.
    b.location = PVector.add(______,______);
    b.velocity.mult(0);
  }
}</pre>
</div>

<div id="chapter03_exercise16" data-type="example">
<h5>Exercise 3.16</h5>
<p>Create a system of multiple bobs and spring connections.  How would you have a bob connected to a bob with no fixed anchor?</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 3 Exercise:</p>

<p>Take one of your creatures and incorporate oscillation into its motion.   You can use the <strong klass>Oscillator</strong> class from Example 3.7 as a model.  The <strong klass>Oscillator</strong> object, however, oscillates around a single point (the middle of the window).   Try oscillating around a moving point.   In other words, design a creature that moves around the screen according to location, velocity, and acceleration.  But that creature isn’t just a static shape, it’s an oscillating body.  Consider tying the speed of oscillation to the speed of motion.  Think of a butterfly’s flapping wings or the legs of an insect.  Can you make it appear that the creature’s internal mechanics (oscillation) drive its locomotion?   For a sample, check out the “AttractionArrayWithOscillation” example with the code download.</p>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_4_particle_systems">
<h1>Chapter 4.  Particle Systems</h1>
<blockquote data-type="epigraph"><p>“That is wise. Were I to invoke logic, however, logic clearly dictates that the needs of the many outweigh the needs of the few.”</p>
<p data-type="attribution">&#8212; — Spock</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""Lucasfilm Ltd."">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Reeves" data-secondary="William T."">&nbsp;</a>
<a data-type="indexterm" data-primary=""Star Trek II: The Wrath of Khan (1982)"">&nbsp;</a></p>

<p>In 1982, William T. Reeves, a researcher at Lucasfilm Ltd., was working on the film <em>Star Trek II: The Wrath of Khan</em>.   Much of the movie revolves around the Genesis Device, a torpedo that when shot at a barren, lifeless planet has the ability to reorganize matter and create a habitable world for colonization. During the sequence, a wall of fire ripples over the planet while it is being “terraformed.”   The term <strong><em>particle system</em></strong>, an incredibly common and useful technique in computer graphics, was coined in the creation of this particular effect.</p>

<blockquote >
“A particle system is a collection of many many minute particles that together represent a fuzzy object. Over a period of time, particles are generated into a system, move and change from within the system, and die from the system.”
<span class="attribution">
—William Reeves, "Particle Systems—A Technique for Modeling a Class of Fuzzy Objects," <span style="font-style:normal">ACM Transactions on Graphics</span> 2:2 (April 1983), 92.
</span>
</blockquote>
<p>Since the early 1980s, particle systems have been used in countless video games, animations, digital art pieces, and installations to model various irregular types of natural phenomena, such as fire, smoke, waterfalls, fog, grass, bubbles, and so on.</p>

<p>This chapter will be dedicated to looking at implementation strategies for coding a particle system. How do we organize our code? Where do we store information related to individual particles versus information related to the system as a whole?  The examples we’ll look at will focus on managing the data associated with a particle system. They&#8217;ll use simple shapes for the particles and apply only the most basic behaviors (such as gravity). However, by using this framework and building in more interesting ways to render the particles and compute behaviors, you can achieve a variety of effects.</p>




<section data-type="sect1" id="chapter04_section1">
<h1>4.1 Why We Need Particle Systems</h1>
<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""purpose of"">&nbsp;</a></p>

<p>We’ve defined a particle system to be a collection of independent objects, often represented by a simple shape or dot.  Why does this matter?    Certainly, the prospect of modeling some of the phenomena we listed (explosions!) is attractive and potentially useful.  But really, there’s an even better reason for us to concern ourselves with particle systems.  If we want to get anywhere in this nature of code life, we’re going to need to work with systems of <em>many</em> things.   We’re going to want to look at balls bouncing, birds flocking, ecosystems evolving, all sorts of things in plural.</p>

<p>Just about every chapter after this one is going to need to deal with a list of objects.  Yes, we’ve done this with an array in some of our first vector and forces examples.   But we need to go where no array has gone before.</p>

<p>First, we’re going to want to deal with flexible quantities of elements.  Sometimes we’ll have zero things, sometimes one thing, sometimes ten things, and sometimes ten thousand things. Second, we’re going to want to take a more sophisticated object-oriented approach.  Instead of simply writing a class to describe a single particle, we’re also going to want to write a class that describes the collection of particles—the particle system itself.   The goal here is to be able to write a main program that looks like the following:</p>

<pre data-type="programlisting" data-code-language="java">//[full] Ah, isn’t this main program so simple and lovely?
ParticleSystem ps;

void setup() {
  size(640,360);
  ps = new ParticleSystem();
}

void draw() {
  background(255);
  ps.run();
}
//[end]</pre>

<p>No single particle is ever referenced in the above code, yet the result will be full of particles flying all over the screen.   Getting used to writing Processing sketches with multiple classes, and classes that keep lists of instances of other classes, will prove very useful as we get to more advanced chapters in this book.</p>

<p><a data-type="indexterm" data-primary=""inheritance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""inheritance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""polymorphism"">&nbsp;</a>
<a data-type="indexterm" data-primary=""polymorphism"">&nbsp;</a></p>

<p>Finally, working with particle systems is also a good excuse for us to tackle two other advanced object-oriented programming techniques: inheritance and polymorphism.   With the examples we’ve seen up until now, we’ve always had an array of a single type of object, like "movers" or “oscillators.”  With inheritance (and polymorphism), we’ll learn a convenient way to store a single list that contains objects of different types.  This way, a particle system need not only be a system of a single type of particle.</p>

<p>Though it may seem obvious to you, I’d also like to point out that there are typical implementations of particle systems, and that’s where we will begin in this chapter.   However, the fact that the particles in this chapter look or behave a certain way should not limit your imagination.   Just because particle systems tend to look sparkly, fly forward, and fall with gravity doesn’t mean that those are the characteristics yours should have.</p>

<p>The focus here is really just how to keep track of a system of many elements.  What those elements do and how those elements look is up to you.</p>
</section>







<section data-type="sect1" id="chapter04_section2">
<h1>4.2 A Single Particle</h1>
<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""particles in"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particles"">&nbsp;</a></p>

<p>Before we can get rolling on the system itself, we have to write the class that will describe a single particle.  The good news: we’ve done this already.    Our <strong klass>Mover</strong> class from Chapter 2 serves as the perfect template.  For us, a particle is an independent body that moves about the screen.  It has <strong var>location</strong>, <strong var>velocity</strong>, and <strong var>acceleration</strong>, a constructor to initialize those variables, and functions to <strong function>display()</strong> itself and <strong function>update()</strong> its location.</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  //[full] A “Particle” object is just another name for our “Mover.” It has location, velocity, and acceleration.
  PVector location;
  PVector velocity;
  PVector acceleration;
  //[end]

  Particle(PVector l) {
    location = l.get();
    acceleration = new PVector();
    velocity = new PVector();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,8,8);
  }
}</pre>

<p>This is about as simple as a particle can get.  From here, we could take our particle in several directions.  We could add an <strong function>applyForce()</strong> function to affect the particle’s behavior (we’ll do precisely this in a future example).  We could add variables to describe color and shape, or reference a <strong klass>PImage</strong> to draw the particle.   For now, however, let’s focus on adding just one additional detail: <strong><em>lifespan</em></strong>.</p>

<p><a data-type="indexterm" data-primary=""emitter"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""emitter"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""lifespan of particles"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particles"" data-secondary=""lifespan of"">&nbsp;</a></p>

<p>Typical particle systems involve something called an <strong><em>emitter</em></strong>.  The emitter is the source of the particles and controls the initial settings for the particles, location, velocity, etc.  An emitter might emit a single burst of particles, or a continuous stream of particles, or both.  The point is that for a typical implementation such as this, a particle is born at the emitter but does not live forever.  If it were to live forever, our Processing sketch would eventually grind to a halt as the number of particles increases to an unwieldy number over time.   As new particles are born, we need old particles to die.  This creates the illusion of an infinite stream of particles, and the performance of our program does not suffer.   There are many different ways to decide when a particle dies.  For example, it could come into contact with another object, or it could simply leave the screen.   For our first <strong klass>Particle</strong> class, however, we’re simply going to add a <strong var>lifespan</strong> variable.   The timer will start at 255 and count down to 0, when the particle will be considered “dead.”  And so we expand the <strong klass>Particle</strong> class as follows:</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // A new variable to keep track of how long the particle
  // has been “alive”
  float lifespan; //[bold]

  Particle(PVector l) {
    location = l.get();
    acceleration = new PVector();
    velocity = new PVector();
    // We start at 255 and count down for convenience
    lifespan = 255; //[bold]
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    // Lifespan decreases
    lifespan -= 2.0; //[bold]
  }

  void display() {
    //[full] Since our life ranges from 255 to 0 we can use it for alpha
    stroke(0,lifespan); //[bold]
    fill(175,lifespan); //[bold]
    //[end]
    ellipse(location.x,location.y,8,8);
  }
}</pre>

<p>The reason we chose to start the lifespan at 255 and count down to 0 is for convenience.  With those values, we can assign <strong var>lifespan</strong> to act as the alpha transparency for the ellipse as well.   When the particle is “dead” it will also have faded away onscreen.</p>

<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""dead particles" data-tertiary="checking for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particles"" data-secondary=""death" data-tertiary="checking for"">&nbsp;</a></p>

<p>With the addition of the <strong var>lifespan</strong> variable, we’ll also need one additional function—a function that can be queried (for a true or false answer) as to whether the particle is alive or dead.  This will come in handy when we are writing the <strong klass>ParticleSystem</strong> class, whose task will be to manage the list of particles themselves.  Writing this function is pretty easy; we just need to check and see if the value of <strong var>lifespan</strong> is less than 0.  If it is we <strong var>return true</strong>, if not we <strong var>return false</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  boolean isDead() {
    //[full] Is the particle still alive?
    if (lifespan &lt; 0.0) {
      return true;
    } else {
      return false;
    }
    //[end]
  }</pre>

<p><a data-type="indexterm" data-primary=""particles"" data-secondary=""testing"">&nbsp;</a></p>

<p>Before we get to the next step of making many particles, it’s worth taking a moment to make sure our particle works correctly and create a sketch with one single <strong klass>Particle</strong> object.  Here is the full code below, with two small additions.  We add a convenience function called <strong function>run()</strong> that simply calls both <strong function>update()</strong> and <strong function>display()</strong> for us.  In addition, we give the particle a random initial velocity as well as a downward acceleration (to simulate gravity).</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_01_SingleParticle/_4_01_SingleParticle.pde processingjs/chapter04/_4_01_SingleParticle/Particle.pde">
<img src="imgs/chapter04/ch04_ex01.png" alt="ch04 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 4.1: A single particle</strong></p>

<pre data-type="programlisting" data-code-language="java">Particle p;

void setup() {
  size(640,360);
  p = new Particle(new PVector(width/2,10));
}

void draw() {
  background(255);
  // Operating the single Particle
  p.run();
  if (p.isDead()) {
    println("Particle dead!");
  }
}

class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  Particle(PVector l) {
    //[offset-up] For demonstration purposes we assign the Particle an initial velocity and constant acceleration.
    acceleration = new PVector(0,0.05);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }

  // Sometimes it’s convenient to have a “run”
  // function that calls all the other functions we need.
  void run() {
    update();
    display();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    lifespan -= 2.0;
  }

  void display() {
    stroke(0,lifespan);
    fill(0,lifespan);
    ellipse(location.x,location.y,8,8);
  }

  // Is the Particle alive or dead?
  boolean isDead() {
    if (lifespan &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }
}</pre>

<div id="chapter04_exercise1" data-type="example">
<h5>Exercise 4.1</h5>
<p>Rewrite the example so that the particle can respond to force vectors via an <strong function>applyForce()</strong> function.</p>
</div>

<div id="chapter04_exercise2" data-type="example">
<h5>Exercise 4.2</h5>
<p>Add angular velocity (rotation) to the particle.  Create your own non-circle particle design.</p>
</div>

<p>Now that we have a class to describe a single particle, we’re ready for the next big step.  How do we keep track of many particles, when we can’t ensure exactly how many particles we might have at any given time?</p>
</section>







<section data-type="sect1" id="chapter04_section3">
<h1>4.3 The ArrayList</h1>
<p><a data-type="indexterm" data-primary=""ArrayList class (Java)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""contract() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""expand() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""ArrayList" data-tertiary="using"">&nbsp;</a>
<a data-type="indexterm" data-primary=""splice() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""subset() function (Processing)"">&nbsp;</a></p>

<p>In truth, we could use a simple array to manage our <strong klass>Particle</strong> objects.  Some particle systems might have a fixed number of particles, and arrays are magnificently efficient in those instances.  Processing also offers <strong function>expand()</strong>, <strong function>contract()</strong>, <strong function>subset()</strong>, <strong function>splice()</strong>, and other methods for resizing arrays.   However, for these examples, we’re going to take a more sophisticated approach and use the Java class <strong klass>ArrayList</strong>, found in the java.util package <a href="http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html">ArrayList Documentation</a>.</p>

<p>Using an <strong klass>ArrayList</strong> follows the same idea as using a standard array, but with different syntax. The following two code examples (which assume the existence of a generic <strong klass>Particle</strong> class) produce the same result: first with an array, and second with an <strong klass>ArrayList</strong>.</p>

<p>The standard array way:</p>

<pre data-type="programlisting" data-code-language="java">int total = 10;
Particle[] parray = new Particle[total];

void setup() {
  //[full] This is what we’re used to, accessing elements on the array via an index and brackets—&amp;#91; &amp;#93;.
  for (int i = 0; i &lt; parray.length; i++) {
    parray[i] = new Particle();
  }
  //[end]
}

void draw() {
  for (int i = 0; i &lt; parray.length; i++) {
    Particle p = parray[i];
    p.run();
  }
}</pre>

<p><a data-type="indexterm" data-primary=""ArrayList class (Java)"" data-secondary=""generics" data-tertiary="using"">&nbsp;</a>
<a data-type="indexterm" data-primary=""for loops"" data-secondary=""ArrayList objects and"">&nbsp;</a></p>

<p>The new <strong klass>ArrayList</strong> way:</p>

<pre data-type="programlisting" data-code-language="java">int total = 10;

//[offset-up] Have you ever seen this syntax before? This is a new feature in Java 1.6 (called "generics") that Processing now supports. It allows us to specify in advance what type of object we intend to put in the ArrayList.
ArrayList&lt;Particle&gt; plist = new ArrayList&lt;Particle&gt;();
void setup() {
  for (int i = 0; i &lt; total; i++) {
    // An object is added to an ArrayList with add().
    plist.add(new Particle());
  }
}

void draw() {
  // The size of the ArrayList is returned by size().
  for (int i = 0; i &lt; plist.size(); i++) {
    // An object is accessed from the ArrayList with get().  Because we are using generics, we do not need to specify a type when we pull objects out of the ArrayList.
    Particle p = plist.get(i);
    p.run();
  }
}</pre>

<p>This last <strong function>for</strong> loop looks pretty similar to our code that looped through a regular array by accessing each index.  We initialize a variable called <strong var>i</strong> to 0 and count up by 1, accessing each element of the <strong klass>ArrayList</strong> until we get to the end. However, this is a good time to mention the “enhanced <strong function>for</strong> loop” available in Java (and Processing), which is a bit more concise. The enhanced loop works with both <strong klass>ArrayList</strong><code>s</code> and regular arrays and looks like this:</p>

<p><a data-type="indexterm" data-primary=""for loops"" data-secondary=""enhanced"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();

for (Particle p: particles) {
  p.run();
}</pre>

<p>Let’s translate that.  Say “for each” instead of “for” and say “in” instead of “:”.  Now you have:</p>

<p>“For each Particle p in particles, run that Particle p!”</p>

<p>I know.  You cannot contain your excitement.  I can’t.  I know it’s not necessary, but I just have to type that again.</p>

<pre data-type="programlisting" data-code-language="java">// This enhanced loop also works for regular arrays!
for (Particle p : particles) {
  p.run();
}</pre>

<p>Simple, elegant, concise, lovely.   Take a moment.   Breathe.   I have some bad news.  Yes, we love that enhanced loop and we will get to use it.  But not right now.  Our particle system examples will require a feature that makes using that loop impossible.  Let’s continue.</p>

<p><a data-type="indexterm" data-primary=""ArrayList class (Java)"" data-secondary=""resizability of"">&nbsp;</a></p>

<p>The code we’ve written above doesn’t take advantage of the <strong klass>ArrayList</strong><code>’s</code> resizability, and it uses a fixed size of 10.   We need to design an example that fits with our particle system scenario, where we emit a continuous stream of <strong klass>Particle</strong> objects, adding one new particle with each cycle through <strong function>draw()</strong>.   We’ll skip rehashing the <strong klass>Particle</strong> class code here, as it doesn’t need to change.</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Particle&gt; particles;

void setup() {
  size(640,360);
  particles = new ArrayList&lt;Particle&gt;();
}

void draw() {
  background(255);
  //[offset-down] A new Particle object is added to the ArrayList every cycle through draw().
  particles.add(new Particle(new PVector(width/2,50)));

  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
  }
}</pre>

<p>Run the above code for a few minutes and you’ll start to see the frame rate slow down further and further until the program grinds to a halt (my tests yielded horrific performance after fifteen minutes).  The issue of course is that we are creating more and more particles without removing any.</p>

<p><a data-type="indexterm" data-primary=""remove() function (ArrayList class)"">&nbsp;</a></p>

<p>Fortunately, the <strong klass>ArrayList</strong> class has a convenient <strong function>remove()</strong> function that allows us to delete a particle (by referencing its index).    This is why we cannot use the new enhanced <strong function>for</strong> loop we just learned; the enhanced loop provides no means for deleting elements while iterating.  Here, we want to call <strong function>remove()</strong> when the particle’s <strong function>isDead()</strong> function returns true.</p>

<pre data-type="programlisting" data-code-language="java">  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
    //[full] If the particle is “dead,” we can go ahead and delete it from the list.
    if (p.isDead()) {
      particles.remove(i);
    }
    //[end]
  }</pre>

<p>Although the above code will run just fine (and the program will never grind to a halt), we have opened up a medium-sized can of worms.  Whenever we manipulate the contents of a list while iterating through that very list, we can get ourselves into trouble.    Take, for example, the following code.</p>

<pre data-type="programlisting" data-code-language="java">  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
    //[offset-down] Adding a new Particle to the list while iterating?
    particles.add(new Particle(new PVector(width/2,50)));
  }</pre>

<p><a data-type="indexterm" data-primary=""size() function (ArrayList class)"">&nbsp;</a></p>

<p>This is a somewhat extreme example (with flawed logic), but it proves the point.  In the above case, for each particle in the list, we add a new particle to the list (manipulating the <strong function>size()</strong> of the <strong klass>ArrayList</strong>).  This will result in an infinite loop, as <strong var>i</strong> can never increment past the size of the <strong klass>ArrayList</strong>.</p>

<p><a data-type="indexterm" data-primary=""iterating"" data-secondary=""removing elements in for loops"">&nbsp;</a></p>

<p>While removing elements from the <strong klass>ArrayList</strong> during a loop doesn’t cause the program to crash (as it does with adding), the problem is almost more insidious in that it leaves no evidence.  To discover the problem we must first establish an important fact.  When an object is removed from the <strong klass>ArrayList</strong>, all elements are shifted one spot to the left.  Note the diagram below where particle C (index 2) is removed.  Particles A and B keep the same index, while particles D and E shift from 3 and 4 to 2 and 3, respectively.</p>

<figure id="chapter04_figure1">
<img src="imgs/chapter04/ch04_01.png" alt="Figure 4.1"/>
<figcaption/>
</figure>
<p>Let’s pretend we are <strong var>i</strong> looping through the <strong klass>ArrayList</strong>.</p>

<p><strong formula>when i = 0 &#8594; Check particle A &#8594; Do not delete</strong><br/>
<strong formula>when i = 1 &#8594; Check particle B &#8594; Do not delete</strong><br/>
<strong formula>when i = 2 &#8594; Check particle C &#8594; Delete!</strong> <br/>
<strong formula2>Slide particles D and E back from slots 3 and 4 to 2 and 3</strong><br/>
<strong formula>when i = 3 &#8594; Check particle E &#8594; Do not delete</strong></p>

<p>Notice the problem?  We never checked particle D!  When C was deleted from slot #2, D moved into slot #2, but i has already moved on to slot # 3.  This is not a disaster, since particle D will get checked the next time around. Still, the expectation is that we are writing code to iterate through every single element of the <strong klass>ArrayList</strong>.   Skipping an element is unacceptable.</p>

<p>There are two solutions to this problem.   The first solution is to simply iterate through the <strong klass>ArrayList</strong> backwards.  If you are sliding elements from right to left as elements are removed, it’s impossible to skip an element by accident.  Here’s how the code would look:</p>

<pre data-type="programlisting" data-code-language="java">  // Looping through the list backwards
  for (int i = particles.size()-1; i &gt;= 0; i--) { //[bold]
    Particle p = (Particle) particles.get(i);
    p.run();
    if (p.isDead()) {
      particles.remove(i);
    }
  }</pre>

<p><a data-type="indexterm" data-primary=""ArrayList class (Java)"" data-secondary=""Iterator class and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""iterating"" data-secondary=""Iterator class (Java)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Iterator class (Java)"">&nbsp;</a></p>

<p>This is a perfectly fine solution in ninety-nine cases out of a hundred.  But sometimes, the order in which the elements are drawn could be important and you may not want to iterate backwards.  Java provides a special class—<strong klass>Iterator</strong><code>—</code>that takes care of all of the details of iteration for you.  You get to say:</p>

<p><em>Hey, I’d like to iterate through this <strong klass>ArrayList</strong>.  Could you continue to give me the next element in the list one at a time until we get to the end?  And if I remove elements or move them around in the list while we’re iterating, will you make sure I don’t look at any elements twice or skip any by accident?</em></p>

<p>An <strong klass>ArrayList</strong> can produce an <strong klass>Iterator</strong> object for you.</p>

<pre data-type="programlisting" data-code-language="java">// Note that with the Iterator object, we can also
// use the new &amp;lt;ClassName&amp;gt; generics syntax and
// specify the type that the Iterator will
// reference.
Iterator&lt;Particle&gt; it = particles.iterator();</pre>

<p>Once you’ve got the iterator, the <strong function>hasNext()</strong> function will tell us whether there is a <strong klass>Particle</strong> for us to run and the <strong function>next()</strong> function will grab that <strong klass>Particle</strong> object itself.</p>

<pre data-type="programlisting" data-code-language="java">  //[full] An Iterator object doing the iterating for you
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
  //[end]</pre>

<p>And if you call the <strong function>remove()</strong> function on the <strong klass>Iterator</strong> object during the loop, it will delete the current <strong klass>Particle</strong> object (and not skip ahead past the next one, as we saw with counting forward through the <strong klass>ArrayList</strong>).</p>

<pre data-type="programlisting" data-code-language="java">    if (p.isDead()) {
      // An Iterator object doing the deleting for you
      it.remove();
    }
  }</pre>

<p>Putting it all together, we have:</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_02_ArrayListParticles/_4_02_ArrayListParticles.pde processingjs/chapter04/_4_02_ArrayListParticles/Particle.pde">
<img src="imgs/chapter04/ch04_ex02.png" alt="ch04 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 4.2: ArrayList of particles with Iterator</strong></p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Particle&gt; particles;

void setup() {
  size(640,360);
  particles = new ArrayList&lt;Particle&gt;();
}

void draw() {
  background(255);

  particles.add(new Particle(new PVector(width/2,50)));

  Iterator&lt;Particle&gt; it = particles.iterator();
  //[full] Using an Iterator object instead of counting with int i
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
    if (p.isDead()) {
       it.remove();
    }
  }
  //[end]
}</pre>
</section>







<section data-type="sect1" id="chapter04_section4">
<h1>4.4 The Particle System Class</h1>
<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""classes of user-defined objects" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""class for" data-tertiary="creating"">&nbsp;</a></p>

<p>OK. Now we’ve done two things.  We’ve written a class to describe an individual <strong klass>Particle</strong> object.  We’ve conquered the <strong klass>ArrayList</strong> and used it to manage a list of many <strong klass>Particle</strong> objects (with the ability to add and delete at will).</p>

<p>We could stop here. However, one additional step we can and should take is to write a class to describe the list of <strong klass>Particle</strong> objects itself—the <strong klass>ParticleSystem</strong> class.  This will allow us to remove the bulky logic of looping through all particles from the main tab, as well as open up the possibility of having more than one particle system.</p>

<p>If you recall the goal we set at the beginning of this chapter, we wanted our main tab to look like this:</p>

<pre data-type="programlisting" data-code-language="java">// Just one wee ParticleSystem!
ParticleSystem ps;

void setup() {
  size(640,360);
  ps = new ParticleSystem();
}

void draw() {
  background(255);
  ps.run();
}</pre>

<p>Let’s take the code from Example 4.2 and review a bit of object-oriented programming, looking at how each piece from the main tab can fit into the <strong klass>ParticleSystem</strong> class.</p>

<table class="code">
<tr>
<th>ArrayList in the main tab</th>
<th>ArrayList in the ParticleSystem class</th>
</tr>
<tr>
<td>
<pre>

<b>ArrayList&lt;Particle&gt; particles;</b>

void setup() {
  size(640,360);
  <b>particles = new ArrayList&lt;Particle&gt;();</b>
}

void draw() {
  background(255);

  <b>particles.add(new Particle());</b>



  <b>Iterator&lt;Particle&gt; it =
      particles.iterator();
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
    if (p.isDead()) {
      it.remove();
    }
  }</b>
}
</pre>
</td>
<td>
<pre>

class ParticleSystem {
  <b>ArrayList&lt;Particle&gt; particles;</b>


  ParticleSystem() {
    <b>particles = new ArrayList&lt;Particle&gt;();</b>
  }



  void addParticle() {
    <b>particles.add(new Particle());</b>
  }

  void run() {
    <b>Iterator&lt;Particle&gt; it =
        particles.iterator();
    while (it.hasNext()) {
      Particle p = it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }</b>
  }
}
</pre>
</td>
</tr>
</table>
<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""origin point (of particles)"">&nbsp;</a></p>

<p>We could also add some new features to the particle system itself.  For example, it might be useful for the <strong klass>ParticleSystem</strong> class to keep track of an origin point where particles are made.  This fits in with the idea of a particle system being an “emitter,” a place where particles are born and sent out into the world.    The origin point should be initialized in the constructor.</p>

<p><strong example>Example 4.3: Simple Single Particle System</strong></p>

<pre data-type="programlisting" data-code-language="java">class ParticleSystem {
  ArrayList particles;
  // This particular ParticleSystem implementation
  // includes an origin point where each Particle begins.
  PVector origin; //[bold]

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList();
  }

  void addParticle() {
    // The origin is passed to each Particle when it is added.
    particles.add(new Particle(origin)); //[bold]
  }</pre>

<div id="chapter04_exercise3" data-type="example">
<h5>Exercise 4.3</h5>
<p>Make the origin point move dynamically.  Have the particles emit from the mouse location or use the concepts of velocity and acceleration to make the system move autonomously.</p>
</div>

<div id="chapter04_exercise4" data-type="example">
<h5>Exercise 4.4</h5>
<p>Building off Chapter 3’s “Asteroids” example, use a particle system to emit particles from the ship’s “thrusters” whenever a thrust force is applied.  The particles’ initial velocity should be related to the ship’s current direction.</p>
</div>
</section>







<section data-type="sect1" id="chapter04_section5">
<h1>4.5 A System of Systems</h1>
<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""multiple systems" data-tertiary="organizing"">&nbsp;</a></p>

<p>Let’s review for a moment where we are.  We know how to talk about an individual <strong klass>Particle</strong> object.  We also know how to talk about a system of <strong klass>Particle</strong> objects, and this we call a “particle system.”  And we’ve defined a particle system as a collection of independent objects.  But isn’t a particle system itself an object?   If that’s the case (which it is), there’s no reason why we couldn’t also have a collection of many particle systems, i.e. a system of systems.</p>

<p>This line of thinking could of course take us even further, and you might lock yourself in a basement for days sketching out a diagram of a system of systems of systems of systems of systems of systems.  Of systems.   After all, this is how the world works.  An organ is a system of cells, a human body is a system of organs, a neighborhood is a system of human bodies, a city is a system of neighborhoods, and so on and so forth.   While this is an interesting road to travel down, it’s a bit beyond where we need to be right now.   It is, however, quite useful to know how to write a Processing sketch that keeps track of many particle systems, each of which keep track of many particles.  Let’s take the following scenario.</p>

<p>You start with a blank screen.</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_04_SystemofSystems/_4_04_SystemofSystems.pde processingjs/chapter04/_4_04_SystemofSystems/Particle.pde processingjs/chapter04/_4_04_SystemofSystems/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex04a.png" alt="ch04 ex04a"/>
<figcaption/>
</figure>
<p>You click the mouse and generate a particle system at the mouse’s location.</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_04_SystemofSystems_b/_4_04_SystemofSystems_b.pde processingjs/chapter04/_4_04_SystemofSystems_b/Particle.pde processingjs/chapter04/_4_04_SystemofSystems_b/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex04b.png" alt="ch04 ex04b"/>
<figcaption/>
</figure>
<p>Each time you click the mouse, a new particle system is created at the mouse’s location.</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_04_SystemofSystems_c/_4_04_SystemofSystems_c.pde processingjs/chapter04/_4_04_SystemofSystems_c/Particle.pde processingjs/chapter04/_4_04_SystemofSystems_c/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex04c.png" alt="ch04 ex04c"/>
<figcaption/>
</figure>
<p>In Example <a href="#chapter04_example3">4.3</a>, we stored a single reference to a <strong klass>ParticleSystem</strong> object in the variable <strong var>ps</strong>.</p>

<pre data-type="programlisting" data-code-language="java">ParticleSystem ps;

void setup() {
  size(640,360);
  ps = new ParticleSystem(1,new PVector(width/2,50));
}

void draw() {
  background(255);
  ps.run();
  ps.addParticle();
}</pre>

<p>For this new example, what we want to do instead is create an <strong klass>ArrayList</strong> to keep track of multiple instances of particle systems.  When the program starts, i.e. in <strong function>setup()</strong>, the <strong klass>ArrayList</strong> is empty.</p>

<p><strong example>Example 4.4: System of systems</strong></p>

<pre data-type="programlisting" data-code-language="java">// This time, the type of thing we are putting
// in the ArrayList is a ParticleSystem itself!
ArrayList&lt;ParticleSystem&gt; systems;
void setup() {
  size(600,200);
  systems = new ArrayList&lt;ParticleSystem&gt;();
}</pre>

<p>Whenever the mouse is pressed, a new <strong klass>ParticleSystem</strong> object is created and placed into the <strong klass>ArrayList</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void mousePressed() {
  systems.add(new ParticleSystem(new PVector(mouseX,mouseY)));
}</pre>

<p>And in <strong function>draw()</strong>, instead of referencing a single <strong klass>ParticleSystem</strong> object, we now look through all the systems in the <strong klass>ArrayList</strong> and call <strong function>run()</strong> on each of them.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);
  // Since we aren’t deleting elements, we
  // can use our enhanced loop!
  for (ParticleSystem ps: systems) {
    ps.run();
    ps.addParticle();
  }
}</pre>

<div id="chapter04_exercise5" data-type="example">
<h5>Exercise 4.5</h5>
<p>Rewrite Example 4.4 so that each particle system doesn’t live forever.  When a particle system is empty (i.e. has no particles left in its <strong klass>ArrayList</strong>), remove it from the <strong klass>ArrayList</strong> <strong var>systems</strong>.</p>
</div>

<div id="chapter04_exercise6" data-type="example">
<h5>Exercise 4.6</h5>
<p>Create a simulation of an object shattering into many pieces. How can you turn one large shape into many small particles? What if there are several large shapes on the screen and they shatter when you click on them?</p>
</div>
</section>







<section data-type="sect1" id="chapter04_section6">
<h1>4.6 Inheritance and Polymorphism: An Introduction</h1>
<p><a data-type="indexterm" data-primary=""<em>Learning Processing</em> (Shiffman)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""inheritance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""inheritance"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""polymorphism"">&nbsp;</a>
<a data-type="indexterm" data-primary=""polymorphism"">&nbsp;</a></p>

<p>You may have encountered the terms <em>inheritance</em> and <em>polymorphism</em> in your programming life before this book.  After all, they are two of the three fundamental principles behind the theory of object-oriented programming (the other being <em>encapsulation</em>).   If you’ve read other Processing or Java programming books, chances are it’s been covered.   My beginner text, <em>Learning Processing</em>, has close to an entire chapter (#22) dedicated to these two topics.</p>

<p>Still, perhaps you’ve only learned about it in the abstract sense and never had a reason to really use inheritance and polymorphism.  If this is true, you’ve come to the right place.  Without these two topics, your ability to program a variety of particles and particle systems is extremely limited.   (In the next chapter, we’ll also see how understanding these topics will help us to use physics libraries.)</p>

<p>Imagine the following.   It’s a Saturday morning, you’ve just gone out for a lovely jog, had a delicious bowl of cereal, and are sitting quietly at your computer with a cup of warm chamomile tea.  It’s your old friend So and So’s birthday and you’ve decided you’d like to make a greeting card in Processing.  How about some confetti for a birthday?  Purple confetti, pink confetti, star-shaped confetti, square confetti, fast confetti, fluttery confetti, etc.  All of these pieces of confetti with different appearances and different behaviors explode onto the screen at once.</p>

<p>What we’ve got here is clearly a particle system—a collection of individual pieces of confetti (i.e. particles).  We might be able to cleverly design our <strong klass>Particle</strong> class to have variables that store its color, shape, behavior, etc.  And perhaps we initialize the values of these variables randomly.   But what if your particles are drastically different? This could become very messy, having all sorts of code for different ways of being a particle in the same class.  Well, you might consider doing the following:</p>

<pre data-type="programlisting" data-code-language="java">class HappyConfetti {

}

class FunConfetti {

}

class WackyConfetti {

}</pre>

<p>This is a nice solution: we have three different classes to describe the different kinds of pieces of confetti that could be part of our particle system.   The <strong klass>ParticleSystem</strong> constructor could then have some code to pick randomly from the three classes when filling the <strong klass>ArrayList</strong>.  Note that this probabilistic method is the same one we employed in our random walk examples in the <a href="#intro_section2">Introduction</a>.</p>

<pre data-type="programlisting" data-code-language="java">class ParticleSystem {
  ParticleSystem(int num) {
    particles = new ArrayList();
    for (int i = 0; i &lt; num; i++) {
      float r = random(1);
      //[full]
      // Randomly picking a "kind" of particle

      if      (r &lt; 0.33) { particles.add(new HappyConfetti()); }
      else if (r &lt; 0.67) { particles.add(new FunConfetti());   }
      else               { particles.add(new WackyConfetti()); }
      //[end]
    }
  }</pre>

<p>OK, we now need to pause for a moment.   We’ve done nothing wrong.   All we wanted to do was wish our friend a happy birthday and enjoy writing some code.  But while the reasoning behind the above approach is quite sound, we’ve opened up two major problems.</p>

<p><strong highlight>Problem #1:  Aren’t we going to be copying/pasting a lot of code between the different “confetti” classes?</strong></p>

<p><a data-type="indexterm" data-primary=""code duplication" data-secondary="inheritance and"">&nbsp;</a></p>

<p>Yes.  Even though our kinds of particles are different enough to merit our breaking them out into separate classes, there is still a ton of code that they will likely share.   They’ll all have <strong klass>PVector</strong><code>s</code> to keep track of location, velocity, and acceleration; an <strong function>update()</strong> function that implements our motion algorithm; etc.</p>

<p>This is where <strong><em>inheritance</em></strong> comes in.  Inheritance allows us to write a class that <em>inherits</em> variables and functions from another class, all the while implementing its own custom features.</p>

<p><strong highlight>Problem #2:  How will the ArrayList know which objects are which type?</strong></p>

<p>This is a pretty serious problem.  Remember, we were using generics to tell the <strong klass>ArrayList</strong> what type of objects we’re going to put inside it.  Are we suddenly going to need three different <strong klass>ArrayList</strong><code>s</code>?</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;HappyConfetti&gt; a1 = new ArrayList&lt;HappyConfetti&gt;();
ArrayList&lt;FunConfetti&gt;   a2 = new ArrayList&lt;FunConfetti&gt;();
ArrayList&lt;WackyConfetti&gt; a3 = new ArrayList&lt;WackyConfetti&gt;();</pre>

<p>This seems awfully inconvenient, given that we really just want one list to keep track of all the stuff in the particle system.  That can be made possible with polymorphism.  Polymorphism will allow us to consider objects of different types as the same type and store them in a single <strong klass>ArrayList</strong>.</p>

<p>Now that we understand the problem, let’s look at these two concepts in a bit more detail and then create a particle system example that implements both inheritance and polymorphism.</p>
</section>







<section data-type="sect1" id="chapter04_section7">
<h1>4.7 Inheritance Basics</h1>
<p>Let’s take a different example, the world of animals: dogs, cats, monkeys, pandas, wombats, and sea nettles.   We&#8217;ll start by programming a <strong klass>Dog</strong> class.   A <strong klass>Dog</strong> object will have an age variable (an integer), as well as <strong function>eat()</strong>, <strong function>sleep()</strong>, and <strong function>bark()</strong> functions.</p>

<pre data-type="programlisting" data-code-language="java">class Dog {
  int age;
  //[full] Dogs and cats have the same variables (age) and functions (eat, sleep).
  Dog() {
    age = 0;
  }

  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }
  //[end]

  //[full] A unique function for barking.
  void bark() {
    println("WOOF!");
  }
  //[end]
}</pre>

<p>Now, let&#8217;s move on to cats.</p>

<pre data-type="programlisting" data-code-language="java">class Cat {
  int age;

  Cat() {
    age = 0;
  }

  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }

  void meow() {
    println("MEOW!");
  }
}</pre>

<p>As we rewrite the same code for fish, horses, koalas, and lemurs, this process will become rather tedious.  Instead, let&#8217;s develop a generic <strong klass>Animal</strong> class that can describe any type of animal.  All animals eat and sleep, after all.  We could then say:</p>

<ul>
<li>
<p>A dog is an animal and has all the properties of animals and can do all the things animals do. Also, a dog can bark.</p></li>
<li>
<p>A cat is an animal and has all the properties of animals and can do all the things animals do. Also, a cat can meow.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""inheritance"" data-secondary=""subclass"">&nbsp;</a>
<a data-type="indexterm" data-primary=""inheritance"" data-secondary=""superclasses"">&nbsp;</a>
<a data-type="indexterm" data-primary=""subclass"">&nbsp;</a>
<a data-type="indexterm" data-primary=""superclasses"">&nbsp;</a></p>

<p>Inheritance makes this all possible.  With inheritance, classes can inherit properties (variables) and functionality (methods) from other classes.  A <strong klass>Dog</strong> class is a child (<strong><em>subclass</em></strong>) of an <strong klass>Animal</strong> class.  Children will automatically inherit all variables and functions from the parent (<strong><em>superclass</em></strong>), but can also include functions and variables not found in the parent.  Like a phylogenetic "tree of life," inheritance follows a tree structure.    Dogs inherit from canines, which inherit from mammals, which inherit from animals, etc.</p>

<figure id="chapter04_figure2">
<img src="imgs/chapter04/ch04_02.png" alt="Figure 4.2"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""inheritance"" data-secondary=""syntax for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""class inheritance" data-tertiary="syntax for"">&nbsp;</a></p>

<p>Here is how the syntax works with inheritance.</p>

<pre data-type="programlisting" data-code-language="java">// The Animal class is the parent (or super) class.
class Animal {
  // Dog and Cat inherit the variable age.
  int age;

  Animal() {
    age = 0;
  }

  //[full] Dog and Cat inherit the functions eat() and sleep().
  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }
  //[end]
}

// The Dog class is the child (or sub) class, indicated by the code "extends Animal".
class Dog extends Animal { //[bold]
  Dog() {
    // super() executes code found in the parent class.
    super(); //[bold]
  }
  // We define bark() in the child class, since it isn't part of the parent class.
  void bark() {
    println("WOOF!");
  }
}

class Cat extends Animal {
  Cat() {
    super();
  }
  void meow() {
    println("MEOW!");
  }
}</pre>

<p>This brings up two new terms:</p>

<p><a data-type="indexterm" data-primary=""extends keyword (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""inheritance"" data-secondary=""extends keyword (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""inheritance"" data-secondary=""super() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""super() function(Processing)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>extends</em></strong> – This keyword is used to indicate a parent for the class being defined.  Note that classes can only extend <em>one</em> class.   However, classes can extend classes that extend other classes, i.e.  <strong klass>Dog extends Animal</strong>, <strong klass>Terrier extends Dog</strong>.  Everything is inherited all the way down the line.</p></li>
<li>
<p><strong><em>super()</em></strong> – This calls the constructor in the parent class.   In other words, whatever you do in the parent constructor, do so in the child constructor as well.   Other code can be written into the constructor in addition to <strong function>super()</strong>.   <strong function>super()</strong> can also receive arguments if there is a parent constructor defined with matching arguments.</p></li>
</ul>

<p>A subclass can be expanded to include additional functions and properties beyond what is contained in the superclass.  For example, let’s assume that a <strong klass>Dog</strong> object has a haircolor variable in addition to age, which is set randomly in the constructor.  The class would now look like this:</p>

<pre data-type="programlisting" data-code-language="java">class Dog extends Animal {
  // A child class can introduce new variables not
  // included in the parent.
  color haircolor;
  Dog() {
    super();
    haircolor = color(random(255));
  }

  void bark() {
    println("WOOF!");
  }
}</pre>

<p><a data-type="indexterm" data-primary=""inheritance"" data-secondary=""overriding superclass functions"">&nbsp;</a>
<a data-type="indexterm" data-primary=""superclasses"" data-secondary=""overriding functions from"">&nbsp;</a></p>

<p>Note how the parent constructor is called via <strong function>super()</strong>, which sets the age to 0, but the haircolor is set inside the <strong klass>Dog</strong> constructor itself.    If a <strong klass>Dog</strong> object eats differently than a generic <strong klass>Animal</strong> object, parent functions can be <em>overridden</em> by rewriting the function inside the subclass.</p>

<pre data-type="programlisting" data-code-language="java">class Dog extends Animal {
  color haircolor;

  Dog() {
     super();
     haircolor = color(random(255));
  }

  // A child can override a parent function if necessary.
  void eat() {
    // A Dog's specific eating characteristics
    println("Woof! Woof! Slurp.")
  }

  void bark() {
    println("WOOF!");
  }
}</pre>

<p><a data-type="indexterm" data-primary=""inheritance"" data-secondary=""adding functionality to superclass objects"">&nbsp;</a>
<a data-type="indexterm" data-primary=""subclass"" data-secondary=""adding functionality to superclass objects"">&nbsp;</a>
<a data-type="indexterm" data-primary=""superclasses"" data-secondary=""adding functionality within subclasses"">&nbsp;</a></p>

<p>But what if a dog eats the same way as a generic animal, just with some extra functionality?  A subclass can both run the code from a parent class and incorporate custom code.</p>

<pre data-type="programlisting" data-code-language="java">class Dog extends Animal {
   color haircolor;

   Dog() {
     super();
     haircolor = color(random(255));
   }

   void eat() {
     // Call eat() from Animal.
     // A child can execute a function from the parent
     // while adding its own code.
     super.eat(); //[bold]
     // Add some additional code
     // for a Dog's specific eating characteristics.
     println("Woof!!!");
   }

   void bark() {
    println("WOOF!");
  }
}</pre>
</section>







<section data-type="sect1" id="chapter04_section8">
<h1>4.8 Particles with Inheritance</h1>
<p><a data-type="indexterm" data-primary=""inheritance"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Now that we&#8217;ve had an introduction to the theory of inheritance and its syntax, we can develop a working example in Processing based on our <strong klass>Particle</strong> class.</p>

<p>Let’s review a simple <strong klass>Particle</strong> implementation, further simplified from <a href="#chapter04_example1">Example 4.1</a>:</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;

  Particle(PVector l) {
    acceleration = new PVector(0,0.05);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
  }

  void run() {
    update();
    display();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
  }

  void display() {
    fill(0);
    ellipse(location.x,location.y,8,8);
  }
}</pre>

<p>Next, we create a subclass from <strong klass>Particle</strong> (let’s call it <strong klass>Confetti</strong>). It will inherit all the instance variables and methods from <strong klass>Particle</strong>. We write a new constructor with the name <strong klass>Confetti</strong> and execute the code from the parent class by calling <strong function>super()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Confetti extends Particle {

  // We could add variables for only Confetti here.

  Confetti(PVector l) {
    super(l);
  }

  // There is no code here because we inherit update() from parent.


  //[full] Override the display method.
  void display() {
    rectMode(CENTER);
    fill(175);
    stroke(0);
    rect(location.x,location.y,8,8);
  }
  //[end]
}</pre>

<p>Let’s make this a bit more sophisticated.  Let’s say we want to have the <strong klass>Confetti</strong> particle rotate as it flies through the air.  We could, of course, model angular velocity and acceleration as we did in Chapter 3.  Instead, we’ll try a quick and dirty solution.</p>

<p>We know a particle has an <em>x</em> location somewhere between 0 and the width of the window.   What if we said: when the particle’s <em>x</em> location is 0, its rotation should be 0; when its <em>x</em> location is equal to the width, its rotation should be equal to <strong var>TWO_PI</strong>?  Does this ring a bell?  Whenever we have a value with one range that we want to map to another range, we can use Processing’s <strong function>map()</strong> function, which we learned about in the <a href="#intro_section6">Introduction</a>!</p>

<pre data-type="programlisting" data-code-language="java">float angle = map(location.x,0,width,0,TWO_PI);</pre>

<p>And just to give it a bit more spin, we can actually map the angle’s range from 0 to <strong var>TWO_PI</strong>*2.  Let’s look at how this code fits into the <strong function>display()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    float theta = map(location.x,0,width,0,TWO_PI*2);

    rectMode(CENTER);
    fill(0,lifespan);
    stroke(0,lifespan);
    //[full] If we rotate() a shape in Processing, we need to familiarize ourselves with transformations. For more, visit: http://processing.org/learning/transform2d/
    pushMatrix();
    translate(location.x,location.y);
    rotate(theta);
    rect(0,0,8,8);
    popMatrix();
    //[end]
  }</pre>

<div id="chapter04_exercise7" data-type="example">
<h5>Exercise 4.7</h5>
<p>Instead of using <strong function>map()</strong> to calculate theta, how would you model angular velocity and acceleration?</p>
</div>

<p>Now that we have a <strong klass>Confetti</strong> class that extends our base <strong klass>Particle</strong> class, we need to figure out how our <strong klass>ParticleSystem</strong> class can manage particles of different types within the same system.  To accomplish this goal, let’s return to the animal kingdom inheritance example and see how the concept extends into the world of polymorphism.</p>
</section>







<section data-type="sect1" id="chapter04_section9">
<h1>4.9 Polymorphism Basics</h1>
<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""instances of subclasses" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""polymorphism"">&nbsp;</a>
<a data-type="indexterm" data-primary=""polymorphism"">&nbsp;</a></p>

<p>With the concept of inheritance under our belts, we can imagine how we would program a diverse animal kingdom using <strong klass>ArrayList</strong><code>s</code>—an array of dogs, an array of cats, of turtles, of kiwis, etc. frolicking about.</p>

<pre data-type="programlisting" data-code-language="java">//[full] Separate ArrayLists for each animal
ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();
ArrayList&lt;Cat&gt; cats = new ArrayList&lt;Cat&gt;();
ArrayList&lt;Turtle&gt; turtles = new ArrayList&lt;Turtle&gt;();
ArrayList&lt;Kiwi&gt; kiwis = new ArrayList&lt;Kiwi&gt;();
//[end]

for (int i = 0; i &lt; 10; i++) {
  dogs.add(new Dog());
}
for (int i = 0; i &lt; 15; i++) {
  cats.add(new Cat());
}
for (int i = 0; i &lt; 6; i++) {
  turtles.add(new Turtle());
}
for (int i = 0; i &lt; 98; i++) {
  kiwis.add(new Kiwi());
}</pre>

<p>As the day begins, the animals are all pretty hungry and are looking to eat.  So it’s off to looping time (enhanced looping time!)&#8230;</p>

<pre data-type="programlisting" data-code-language="java">//[full] Separate loops for each animal
for (Dog d: dogs) {
  d.eat();
}
for (Cat c: cats) {
  c.eat();
}
for (Turtle t: turtles) {
  t.eat();
}
for (Kiwi k: kiwis) {
  k.eat();
}
//[end]</pre>

<p><a data-type="indexterm" data-primary=""superclasses"" data-secondary=""polymorphism and"">&nbsp;</a></p>

<p>This works well, but as our world expands to include many more animal species, we’re going to get stuck writing a lot of individual loops.  Is this really necessary?  After all, the creatures are all animals, and they all like to eat.  Why not just have one <strong klass>ArrayList</strong> of <strong klass>Animal</strong> objects and fill it with all different <em>kinds</em> of animals?</p>

<pre data-type="programlisting" data-code-language="java">//[offset-down] Just one ArrayList for all the animals!
ArrayList&lt;Animal&gt; kingdom = new ArrayList&lt;Animal&gt;();

for (int i = 0; i &lt; 1000; i++) {
  if (i &lt; 100) kingdom.add(new Dog());
  else if (i &lt; 400) kingdom.add(new Cat());
  else if (i &lt; 900) kingdom.add(new Turtle());
  else kingdom.add(new Kiwi());
}

for (Animal a: kingdom) {
  a.eat();
}</pre>

<p>The ability to treat a <strong klass>Dog</strong> object as either a member of the <strong klass>Dog</strong> class or the <strong klass>Animal</strong> class (its parent) is an example of polymorphism.  <strong><em>Polymorphism</em></strong> (from the Greek <em>polymorphos</em>, meaning many forms) refers to the treatment of a single instance of an object in multiple forms.    A dog is certainly a dog, but since <strong klass>Dog extends Animal</strong>, it can also be considered an animal.  In code, we can refer to it both ways.</p>

<p><a data-type="indexterm" data-primary=""polymorphism"" data-secondary=""creating object instances with"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">Dog rover = new Dog();
Animal spot = new Dog();</pre>

<p>Although the second line of code might initially seem to violate syntax rules, both ways of declaring a <strong klass>Dog</strong> object are legal.  Even though we declare <strong var>spot</strong> as an <strong klass>Animal</strong> object, we’re really making a <strong klass>Dog</strong> object and storing it in the <strong var>spot</strong> variable.  And we can safely call all of the <strong klass>Animal</strong> class methods on spot because the rules of inheritance dictate that a dog can do anything an animal can.</p>

<p><a data-type="indexterm" data-primary=""superclasses"" data-secondary=""overriding functions from"">&nbsp;</a></p>

<p>What if the <strong klass>Dog</strong> class, however, overrides the <strong function>eat()</strong> function in the <strong klass>Animal</strong> class?  Even if spot is declared as an <strong klass>Animal</strong>, Java will determine that its true identity is that of a <strong klass>Dog</strong> and run the appropriate version of the <strong function>eat()</strong> function.</p>

<p>This is particularly useful when we have an array or <strong klass>ArrayList</strong>.</p>
</section>







<section data-type="sect1" id="chapter04_section10">
<h1>4.10 Particle Systems with Polymorphism</h1>
<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""polymorphism" data-tertiary="using"">&nbsp;</a></p>

<p>Let’s pretend for a moment that polymorphism doesn’t exist and rewrite a <strong klass>ParticleSystem</strong> class to include many <strong klass>Particle</strong> objects and many <strong klass>Confetti</strong> objects.</p>

<pre data-type="programlisting" data-code-language="java">class ParticleSystem {
  //[full] We’re stuck doing everything twice with two lists!
  ArrayList&lt;Particle&gt; particles; //[bold]
  ArrayList&lt;Confetti&gt; confetti; //[bold]
  //[end]
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    //[full] We’re stuck doing everything twice with two lists!
    particles = new ArrayList&lt;Particle&gt;(); //[bold]
    confetti = new ArrayList&lt;Confetti&gt;(); //[bold]
    //[end]
  }

  void addParticle() {
    //[full] We’re stuck doing everything twice with two lists!
    particles.add(new Particle(origin)); //[bold]
    particles.add(new Confetti(origin)); //[bold]
    //[end]
  }

  void run() {
    //[full] We’re stuck doing everything twice with two lists!
    Iterator&lt;Particle&gt; it = particles.iterator(); //[bold]
    while (it.hasNext()) {
      Particle p = it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
    it = confetti.iterator(); //[bold]
    while (it.hasNext()) {
      Confetti c = it.next();
      c.run();
      if (c.isDead()) {
        it.remove();
      }
    }
    //[end]
  }
}</pre>

<p>Notice how we have two separate lists, one for particles and one for confetti.  Every action we want to perform we have to do twice!   Polymorphism allows us to simplify the above by just making one <strong klass>ArrayList</strong> of particles that contains both standard <strong klass>Particle</strong> objects as well as <strong klass>Confetti</strong> objects.  We don’t have to worry about which are which; this will all be taken care of for us!  (Also, note that the code for the main program and the classes has not changed, so we aren’t including it here.  See the website for the full example.)</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/_4_05_ParticleSystemInheritancePolymorphism.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/Confetti.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/Particle.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex05.png" alt="ch04 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 4.5: Particle system inheritance and polymorphism</strong></p>

<pre data-type="programlisting" data-code-language="java">class ParticleSystem {
  // One list, for anything that is a Particle
  // or extends Particle
  ArrayList&lt;Particle&gt; particles;  //[bold]
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    float r = random(1);
    // We have a 50% chance of adding each kind of Particle.
    if (r &lt; 0.5) {
      particles.add(new Particle(origin));  //[bold]
    } else {
      particles.add(new Confetti(origin));  //[bold]
    }
  }

  void run() {
    Iterator&lt;Particle&gt; it = particles.iterator();
    while (it.hasNext()) {
      // Polymorphism allows us to treat everything as a
      // Particle, whether it is a Particle or a Confetti.
      Particle p = it.next(); //[bold]
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
  }
}</pre>

<div id="chapter04_exercise8" data-type="example">
<h5>Exercise 4.8</h5>
<p>Create a particle system with different “kinds” of particles in the same system.  Try varying more than just the look of the particles.  How do you deal with different behaviors using inheritance?</p>
</div>
</section>







<section data-type="sect1" id="chapter04_section11">
<h1>4.11 Particle Systems with Forces</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""particle systems with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""forces and"">&nbsp;</a></p>

<p>So far in this chapter, we’ve been focusing on structuring our code in an object-oriented way to manage a collection of particles.   Maybe you noticed, or maybe you didn’t, but during this process we unwittingly took a couple steps backward from where we were in previous chapters.  Let’s examine the constructor of our simple <strong klass>Particle</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">  Particle(PVector l) {
    // We’re setting acceleration to a constant value!
    acceleration = new PVector(0,0.05); //[bold]

    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }</pre>

<p>And now let’s look at the <strong function>update()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">  void update() {
    velocity.add(acceleration);
    location.add(velocity);

    [inline]// Where is the line of code to clear acceleration?

    lifespan -= 2.0;
  }</pre>

<p>Our <strong klass>Particle</strong> class is structured to have a constant acceleration, one that never changes.  A much better framework would be to follow Newton’s second law (F = M* A) and incorporate the force accumulation algorithm we worked so hard on in <a href="#chapter02_section3">Chapter 2</a>.</p>

<p>Step 1 would be to add in the <strong function>applyForce()</strong> function. (Remember, we need to make a copy of the <strong klass>PVector</strong> before we divide it by mass.)</p>

<pre data-type="programlisting" data-code-language="java">  void applyForce(PVector force) {
    PVector f = force.get();
    f.div(mass);
    acceleration.add(f);
  }</pre>

<p>Once we have this, we can add in one more line of code to clear the acceleration at the end of <strong function>update()</strong>.</p>

<pre data-type="programlisting" data-code-language="java"> void update() {
   velocity.add(acceleration);
   location.add(velocity);
   // There it is!
   acceleration.mult(0);
   lifespan -= 2.0;
  }</pre>

<p>And our <strong klass>Particle</strong> class is complete!</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  // We could vary mass for more interesting results.
  float mass = 1;

  Particle(PVector l) {
    // We now start with acceleration of 0.
    acceleration = new PVector(0,0);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }

  void run() {
    update();
    display();
  }

  //[full] Newton’s second law &amp; force accumulation
  void applyForce(PVector force) {
    PVector f = force.get();
    f.div(mass);
    acceleration.add(f);
  }
  //[end]

  //[full] Standard update
  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
    lifespan -= 2.0;
  }
  //[end]

  //[full] Our Particle is a circle.
  void display() {
    stroke(255,lifespan);
    fill(255,lifespan);
    ellipse(location.x,location.y,8,8);
  }
  //[end]

  //[full] Should the Particle be deleted?
  boolean isDead() {
    if (lifespan &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }
  //[end]
}</pre>

<p>Now that the <strong klass>Particle</strong> class is completed, we have a very important question to ask.  Where do we call the <strong function>applyForce()</strong> function?  Where in the code is it appropriate to apply a force to a particle?   The truth of the matter is that there’s no right or wrong answer; it really depends on the exact functionality and goals of a particular Processing sketch.  Still, we can create a generic situation that would likely apply to most cases and craft a model for applying forces to individual particles in a system.</p>

<p>Let’s consider the following goal: Apply a force globally every time through <strong function>draw()</strong> to all particles. We&#8217;ll pick an easy one for now: a force pointing down, like gravity.</p>

<pre data-type="programlisting" data-code-language="java">PVector gravity = new PVector(0,0.1);</pre>

<p>We said it should always be applied, i.e. in <strong function>draw()</strong>, so let’s take a look at our <strong function>draw()</strong> function as it stands.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(100);
  ps.addParticle();
  ps.run();
}</pre>

<p>Well, it seems that we have a small problem.  <strong function>applyForce()</strong> is a method written inside the <strong klass>Particle</strong> class, but we don’t have any reference to the individual particles themselves, only the <strong klass>ParticleSystem</strong> object: the variable <strong var>ps</strong>.</p>

<p>Since we want all particles to receive the force, however, we can decide to apply the force to the particle system and let it manage applying the force to all the individual particles:</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(100);

  PVector gravity = new PVector(0,0.1);
  // Applying a force to the system as a whole
  ps.applyForce(gravity);
  ps.addParticle();
  ps.run();
}</pre>

<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""maintaining encapsulation"">&nbsp;</a></p>

<p>Of course, if we call a new function on the <strong klass>ParticleSystem</strong> object in <strong function>draw()</strong>, well, we have to write that function in the <strong klass>ParticleSystem</strong> class.   Let’s describe the job that function needs to perform: receive a force as a <strong klass>PVector</strong> and apply that force to all the particles.</p>

<p>Now in code:</p>

<pre data-type="programlisting" data-code-language="java">  void applyForce(PVector f) {
    for (Particle p: particles) {
      p.applyForce(f);
    }
  }</pre>

<p>It almost seems silly to write this function.   What we’re saying is “apply a force to a particle system so that the system can apply that force to all of the individual particles.”   Nevertheless, it’s really quite reasonable.  After all, the <strong klass>ParticleSystem</strong> object is in charge of managing the particles, so if we want to talk to the particles, we’ve got to talk to them through their manager.  (Also, here’s a chance for the enhanced loop since we aren’t deleting particles!)</p>

<p>Here is the full example (assuming the existence of the <strong klass>Particle</strong> class written above; no need to include it again since nothing has changed):</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_06_ParticleSystemForces/_4_06_ParticleSystemForces.pde processingjs/chapter04/_4_06_ParticleSystemForces/Particle.pde processingjs/chapter04/_4_06_ParticleSystemForces/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex06.png" alt="ch04 ex06"/>
<figcaption/>
</figure>
<p><strong example>Example 4.6: Particle system with forces</strong></p>

<pre data-type="programlisting" data-code-language="java">ParticleSystem ps;

void setup() {
  size(640,360);
  ps = new ParticleSystem(new PVector(width/2,50));
}

void draw() {
  background(100);

  // Apply a force to all particles.
  PVector gravity = new PVector(0,0.1); //[bold]
  ps.applyForce(gravity); //[bold]

  ps.addParticle();
  ps.run();
}


class ParticleSystem {
  ArrayList&lt;Particle&gt; particles;
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    particles.add(new Particle(origin));
  }

  void applyForce(PVector f) {
    //[full] Using an enhanced loop to apply the force to all particles
    for (Particle p: particles) {
      p.applyForce(f);
    }
    //[end]
  }

  void run() {
    //[full] Can’t use the enhanced loop because we want to check for particles to delete.
    Iterator&lt;Particle&gt; it = particles.iterator();
    while (it.hasNext()) {
      Particle p = (Particle) it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
    //[end]
  }
}</pre>
</section>







<section data-type="sect1" id="chapter04_section12">
<h1>4.12 Particle Systems with Repellers</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""applying to single objects in a system"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""applying force to single particles in"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particles"" data-secondary=""applying force to single particles in"">&nbsp;</a></p>

<p>What if we wanted to take this example one step further and add a <strong klass>Repeller</strong> object—the inverse of the <strong klass>Attractor</strong> object we covered in <a href="#chapter02_section9">Chapter 2</a> that pushes any particles away that get close?  This requires a bit more sophistication because, unlike the gravity force, each force an attractor or repeller exerts on a particle must be calculated for each particle.</p>

<figure id="chapter04_figure3" class="two-col-borderless">
<img src="imgs/chapter04/ch04_03.png" alt="Figure 4.3: Gravity force—vectors are all identical"/>
<figcaption/>
</figure>
<figure id="chapter04_figure4" class="two-col-borderless">
<img src="imgs/chapter04/ch04_04.png" alt="Figure 4.4: Attractor force—vectors are all different"/>
<figcaption/>
</figure>
<p>Let’s start solving this problem by examining how we would incorporate a new <strong klass>Repeller</strong> object into our simple particle system plus forces example.  We’re going to need two major additions to our code:</p>

<ol>
<li>
<p>A <strong klass>Repeller</strong> object (declared, initialized, and displayed).</p></li>
<li>
<p>A function that passes the <strong klass>Repeller</strong> object into the <strong klass>ParticleSystem</strong> so that it can apply a force to each particle object.</p></li>
</ol>

<pre data-type="programlisting" data-code-language="java">ParticleSystem ps;
// New thing: we declare a Repeller object.
Repeller repeller; //[bold]

void setup() {
  size(640,360);
  ps = new ParticleSystem(new PVector(width/2,50));
  // New thing: we initialize a Repeller object.
  repeller = new Repeller(width/2-20,height/2); //[bold]
}

void draw() {
  background(100);
  ps.addParticle();

  PVector gravity = new PVector(0,0.1);
  ps.applyForce(gravity);

  // New thing: we need a function to apply a force from a repeller.
  ps.applyRepeller(repeller); //[bold]

  ps.run();
  // New thing: we display the Repeller object.
  repeller.display(); //[bold]
}</pre>

<p>Making a <strong klass>Repeller</strong> object is quite easy; it’s a duplicate of the <strong klass>Attractor</strong> class from Chapter 2, Example 2.6 <a data-type="xref" href="#chapter02_example6"/>.</p>

<pre data-type="programlisting" data-code-language="java">class Repeller {
  // A Repeller doesn’t move, so you just need location.
  PVector location;
  float r = 10;

  Repeller(float x, float y)  {
    location = new PVector(x,y);
  }

  void display() {
    stroke(255);
    fill(255);
    ellipse(location.x,location.y,r*2,r*2);
  }
}</pre>

<p>The more difficult question is, how do we write the <strong function>applyRepeller()</strong> function?  Instead of passing a <strong klass>PVector</strong> into a function like we do with <strong function>applyForce()</strong>, we’re going to instead pass a <strong klass>Repeller</strong> object into <strong function>applyRepeller()</strong> and ask that function to do the work of calculating the force between the repeller and all particles.  Let’s look at both of these functions side by side.</p>

<table class="code">
<tr>
<th>applyForce()</th>
<th>applyRepeller</th>
</tr>
<tr>
<td>
<pre>
void applyForce(PVector f) {
  for (Particle p: particles) {
    p.applyForce(f);
  }
}
</pre>
</td>
<td>
<pre>
void applyRepeller(Repeller r) {
  for (Particle p: particles) {
    PVector force = r.repel(p);
    p.applyForce(force);
  }
}
</pre>
</td>
</tr>
</table>
<p>The functions are almost identical.  There are only two differences. One we mentioned before—a <strong klass>Repeller</strong> object is the argument, not a <strong klass>PVector</strong>.  The second difference is the important one.   We must calculate a custom <strong klass>PVector</strong> force for each and every particle and apply that force.  How is that force calculated?   In a function called <strong function>repel()</strong>, which is the inverse of the <strong function>attract()</strong> function we wrote for the <strong klass>Attractor</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">   // All the same steps we had to calculate an attractive force, only pointing in the opposite direction.
  PVector repel(Particle p) {
    //[full] 1) Get force direction.
    PVector dir =
      PVector.sub(location,p.location);
    //[end]
    //[full] 2) Get distance (constrain distance).
    float d = dir.mag();
    d = constrain(d,5,100);
    //[end]
    dir.normalize();
    // 3) Calculate magnitude.
    float force = -1 * G / (d * d);
    // 4) Make a vector out of direction and magnitude.
    dir.mult(force);
    return dir;
  }</pre>

<p>Notice how throughout this entire process of adding a repeller to the environment, we’ve never once considered editing the <strong klass>Particle</strong> class itself.   A particle doesn’t actually have to know anything about the details of its environment; it simply needs to manage its location, velocity, and acceleration, as well as have the ability to receive an external force and act on it.</p>

<p>So we can now look at this example in its entirety, again leaving out the <strong klass>Particle</strong> class, which hasn’t changed.</p>

<figure class="screenshot" data-pde="processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/_4_07_ParticleSystemForcesRepeller.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/Repeller.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/Particle.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex07.png" alt="ch04 ex07"/>
<figcaption/>
</figure>
<p><strong example>Example 4.7: ParticleSystem with repeller</strong></p>

<pre data-type="programlisting" data-code-language="java">// One ParticleSystem
ParticleSystem ps;
// One repeller
Repeller repeller;

void setup() {
  size(640,360);
  ps = new ParticleSystem(new PVector(width/2,50));
  repeller = new Repeller(width/2-20,height/2);
}

void draw() {
  background(100);
  ps.addParticle();
  // We’re applying a universal gravity.
  PVector gravity = new PVector(0,0.1);
  ps.applyForce(gravity);
  // Applying the repeller
  ps.applyRepeller(repeller);

  ps.run();
  repeller.display();
}


// The ParticleSystem manages all the Particles.
class ParticleSystem {
  ArrayList&lt;Particle&gt; particles;
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    particles.add(new Particle(origin));
  }

  // Applying a force as a PVector
  void applyForce(PVector f) {
    for (Particle p: particles) {
      p.applyForce(f);
    }
  }

  void applyRepeller(Repeller r) {
    //[full] Calculating a force for each Particle based on a Repeller
    for (Particle p: particles) {
      PVector force = r.repel(p);
      p.applyForce(force);
    }
    //[end]
  }

  void run() {
    Iterator&lt;Particle&gt; it = particles.iterator();
    while (it.hasNext()) {
      Particle p = (Particle) it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
  }
}

class Repeller {

  // How strong is the repeller?
  float strength = 100;
  PVector location;
  float r = 10;

  Repeller(float x, float y)  {
    location = new PVector(x,y);
  }

  void display() {
    stroke(255);
    fill(255);
    ellipse(location.x,location.y,r*2,r*2);
  }

  PVector repel(Particle p) {
    //[full] This is the same repel algorithm we used in Chapter 2: forces based on gravitational attraction.
    PVector dir = PVector.sub(location,p.location);
    float d = dir.mag();
    dir.normalize();
    d = constrain(d,5,100);
    float force = -1 * strength / (d * d);
    dir.mult(force);
    return dir;
    //[end]
  }
}</pre>

<div id="chapter04_exercise9" data-type="example">
<h5>Exercise 4.9</h5>
<p>Expand the above example to include many repellers (using an array or <strong klass>ArrayList</strong>).</p>
</div>

<div id="chapter04_exercise10" data-type="example">
<h5>Exercise 4.10</h5>
<p>Create a particle system in which each particle responds to every other particle.  (Note that we’ll be going through this in detail in Chapter 6.)</p>
</div>
</section>







<section data-type="sect1" id="chapter04_section13">
<h1>4.13 Image Textures and Additive Blending</h1>
<p><a data-type="indexterm" data-primary=""image textures"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""incorporating images into projects"">&nbsp;</a></p>

<p>Even though this book is really about behaviors and algorithms rather than computer graphics and design, I don’t think we would be able to live with ourselves if we went through a discussion of particle systems and never once looked at an example that involves texturing each particle with an image.  The way you choose to draw a particle is a big part of the puzzle in terms of designing certain types of visual effects.</p>

<p>Let’s try to create a smoke simulation in Processing.  Take a look at the following two images:</p>

<figure class="two-col-borderless" data-pde="processingjs/chapter04/_4_08_ParticleSystemSmoke_b/_4_08_ParticleSystemSmoke_b.pde processingjs/chapter04/_4_08_ParticleSystemSmoke_b/Particle.pde processingjs/chapter04/_4_08_ParticleSystemSmoke_b/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex08b.png" alt="White circles"/>
<figcaption/>
</figure>
<figure class="two-col-borderless" data-pde="processingjs/chapter04/_4_08_ParticleSystemSmoke/_4_08_ParticleSystemSmoke.pde processingjs/chapter04/_4_08_ParticleSystemSmoke/Particle.pde processingjs/chapter04/_4_08_ParticleSystemSmoke/ParticleSystem.pde">
<img src="imgs/chapter04/ch04_ex08a.png" alt="Fuzzy images with transparency"/>
<figcaption/>
</figure>
<p>Both of these images were generated from identical algorithms. The only difference is that a white circle is drawn in image A for each particle and a “fuzzy” blob is drawn for each in B.</p>

<figure id="chapter04_figure5">
<img src="imgs/chapter04/ch04_05.png" alt="Figure 4.5"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""image textures"" data-secondary=""PNG format and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PNG graphic file format"">&nbsp;</a></p>

<p>The good news here is that you get a lot of bang for very little buck.   Before you write any code, however, you’ve got to make your image texture!  I recommend using PNG format, as Processing will retain the alpha channel (i.e. transparency) when drawing the image, which is needed for blending the texture as particles layer on top of each other.  Once you’ve made your PNG and deposited it in your sketch’s “data” folder, you are on your way with just a few lines of code.</p>

<p><a data-type="indexterm" data-primary=""image textures"" data-secondary=""PImage objects (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PImage objects (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""PImage objects"">&nbsp;</a></p>

<p>First, we’ll need to declare a <strong klass>PImage</strong> object.</p>

<p><strong example>Example 4.8: Image texture particle system</strong></p>

<pre data-type="programlisting" data-code-language="java">PImage img;</pre>

<p>Load the image in <strong function>setup()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  // Loading the PNG
  img = loadImage("texture.png");
}</pre>

<p>And when it comes time to draw the particle, we’ll use the image reference instead of drawing an ellipse or rectangle.</p>

<pre data-type="programlisting" data-code-language="java">  void render() {
    imageMode(CENTER);
    // Note how tint() is the image equivalent of shape’s fill().
    tint(255,lifespan);
    image(img,loc.x,loc.y);
  }</pre>

<p><a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""smoke" data-tertiary="modeling with particle systems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""smoke" data-tertiary="modeling"">&nbsp;</a></p>

<p>Incidentally, this smoke example is a nice excuse to revisit the Gaussian number distributions from the <a href="#intro_section4">Introduction</a>.  To make the smoke appear a bit more realistic, we don’t want to launch all the particles in a purely random direction.  Instead, by creating initial velocity vectors mostly around a mean value (with a lower probability of outliers), we’ll get an effect that appears less fountain-like and more like smoke (or fire).</p>

<p>Assuming a <strong klass>Random</strong> object called “generator”, we could create initial velocities as follows:</p>

<pre data-type="programlisting" data-code-language="java">    float vx = (float) generator.nextGaussian()*0.3;
    float vy = (float) generator.nextGaussian()*0.3 - 1.0;
    vel = new PVector(vx,vy);</pre>

<p>Finally, in this example, a wind force is applied to the smoke mapped from the mouse’s horizontal location.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(0);

  float dx = map(mouseX,0,width,-0.2,0.2);
  // Wind force points towards mouseX.
  PVector wind = new PVector(dx,0);
  ps.applyForce(wind);
  ps.run();
  //[full] Two particles are added each cycle through draw().
  for (int i = 0; i &lt; 2; i++) {
    ps.addParticle();
  }
  //[end]
}</pre>

<div id="chapter04_exercise11" data-type="example">
<h5>Exercise 4.11</h5>
<p>Try creating your own textures for different types of effects.  Can you make it look like fire, instead of smoke?</p>
</div>

<div id="chapter04_exercise12" data-type="example">
<h5>Exercise 4.12</h5>
<p>Use an array of images and assign each <strong klass>Particle</strong> object a different image.  Even though single images are drawn by multiple particles, make sure you don’t call <strong function>loadImage()</strong> any more than you need to, i.e. once for each image file.</p>
</div>

<p><a data-type="indexterm" data-primary=""blend modes"">&nbsp;</a>
<a data-type="indexterm" data-primary=""image textures"" data-secondary=""blend modes"">&nbsp;</a></p>

<p>Finally, it’s worth noting that there are many different algorithms for blending colors in computer graphics. These are often referred to as “blend modes.”  By default, when we draw something on top of something else in Processing, we only see the top layer—this is commonly referred to as a “normal” blend mode.  When the pixels have alpha transparency (as they do in the smoke example), Processing uses an alpha compositing algorithm that combines a percentage of the background pixels with the new foreground pixels based on the alpha values.</p>

<p><a data-type="indexterm" data-primary=""additive blend mode"">&nbsp;</a>
<a data-type="indexterm" data-primary=""blend modes"" data-secondary=""additive"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Hodgin" data-secondary="Robert"">&nbsp;</a>
<a data-type="indexterm" data-primary=""iTunes visualizer"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Magnetosphere"">&nbsp;</a></p>

<p>However, it’s possible to draw using other blend modes, and a much loved blend mode for particle systems is “additive.”  Additive blending in Processing was pioneered by <a href="http://roberthodgin.com/">Robert Hodgin</a> in his famous particle system and forces exploration, Magnetosphere, which later became the iTunes visualizer.  For more see: <a href="http://roberthodgin.com/magnetosphere-part-2/">Magnetosphere</a>.</p>

<p>Additive blending is in fact one of the simplest blend algorithms and involves adding the pixel values of one layer to another (capping all values at 255 of course).  This results in a space-age glow effect due to the colors getting brighter and brighter with more layers.</p>

<figure>
<img src="imgs/chapter04/ch04_ex09.png" alt="ch04 ex09"/>
<figcaption/>
</figure>
<p>To achieve additive blending in Processing, you’ll need to use the <strong var>P2D</strong> or <strong var>P3D</strong> renderer.</p>

<p><strong example>Example 4.9: Additive blending</strong></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  // Using the P2D  renderer
  size(640,360,P2D);
}</pre>

<p>Then, before you go to draw anything, you set the blend mode using <strong function>blendMode()</strong>:</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  // Additive blending
  blendMode(ADD);

  // Note that the “glowing” effect of additive
  // blending will not work with a white
  // (or very bright) background.
  background(0);

  // All your other particle stuff would go here.

}</pre>

<div id="chapter04_exercise13" data-type="example">
<h5>Exercise 4.13</h5>
<p>Use <strong function>tint()</strong> in combination with additive blending to create a rainbow effect.</p>
</div>

<p><a data-type="indexterm" data-primary=""blend modes"" data-secondary=""list of"">&nbsp;</a></p>

<div id="chapter04_exercise14" data-type="example">
<h5>Exercise 4.14</h5>
<p>Try blending with other modes, such as <strong var>SUBTRACT</strong>, <strong var>LIGHTEST</strong>, <strong var>DARKEST</strong>, <strong var>DIFFERENCE</strong>, <strong var>EXCLUSION</strong>,or <strong var>MULTIPLY</strong>.</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 4 Exercise:</p>

<p>Take your creature from Step 3 and build a system of creatures.   How can they interact with each other?  Can you use inheritance and polymorphism to create a variety of creatures, derived from the same code base?   Develop a methodology for how they compete for resources (for example, food).   Can you track a creature’s “health” much like we tracked a particle’s lifespan, removing creatures when appropriate?  What rules can you incorporate to control how creatures are born?</p>

<p>(Also, you might consider using a particle system itself in the design of a creature.  What happens if your emitter is tied to the creature’s location?)</p>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_5_physics_libraries">
<h1>Chapter 5.  Physics Libraries</h1>
<blockquote data-type="epigraph"><p>“A library implies an act of faith/Which generations still in darkness hid/Sign in their night in witness of the dawn.”</p>
<p data-type="attribution">&#8212; — Victor Hugo</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""physics"" data-secondary=""open-source libraries for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""physics libraries"">&nbsp;</a></p>

<p>Before we move on to anything else, let’s revisit some of the things we’ve done in the first four chapters. We have:</p>

<ol>
<li>
<p>Learned about concepts from the world of physics — What is a vector? What is a force? What is a wave? etc.</p></li>
<li>
<p>Understood the math and algorithms behind such concepts.</p></li>
<li>
<p>Implemented the algorithms in Processing with an object-oriented approach.</p></li>
</ol>

<p>These activities have yielded a set of motion simulation examples, allowing us to creatively define the physics of the worlds we build (whether realistic or fantastical).  Of course, we aren’t the first to try this. The world of computer graphics and programming is full of source code dedicated to simulation. Just try Googling “open-source physics engine” and you could spend the rest of your day pouring over rich and complex code.    And so we must ask the question: If a code library will take care of physics simulation, why should we bother learning how to write any of the algorithms ourselves?</p>

<p>Here is where the philosophy behind this book comes into play.  While many of the libraries out there give us physics (and super awesome advanced physics at that) for free, there are significant reasons for learning the fundamentals from scratch before diving into libraries. First, without an understanding of vectors, forces, and trigonometry, we’d be completely lost just reading the documentation of a library.   Second, even though a library may take care of the math for us, it won’t necessarily simplify our code.  As we’ll see in a moment, there can be a great deal of overhead in simply understanding how a library works and what it expects from you code-wise.  Finally, as wonderful as a physics engine might be, if you look deep down into your hearts, it’s likely that you seek to create worlds and visualizations that stretch the limits of imagination. A library is great, but it provides a limited set of features. It’s important to know both when to live within limitations in the pursuit of a Processing project and when those limits prove to be confining.</p>

<p>This chapter is dedicated to examining two open-source physics libraries—Box2D and toxiclibs’ VerletPhysics engine.   With each library, we’ll evaluate its pros and cons and look at reasons why you might choose one of these libraries for a given project.</p>




<section data-type="sect1" id="chapter05_section1">
<h1>5.1 What Is Box2D and When Is It Useful?</h1>
<p><a data-type="indexterm" data-primary=""Angry Birds"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Box2D"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Catto" data-secondary="Erin"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Crayon Physics"">&nbsp;</a>
<a data-type="indexterm" data-primary=""physics libraries"" data-secondary=""Box2D"">&nbsp;</a></p>

<p>Box2D began as a set of physics tutorials written in C++ by Erin Catto for the Game Developer’s Conference in 2006. Over the last five years it has evolved into an rich and elaborate open-source physics engine.   It’s been used for countless projects, most notably highly successful games such as the award-winning puzzle game Crayon Physics and the runaway mobile and tablet hit Angry Birds.</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""overhead with"">&nbsp;</a></p>

<p>One of the key things to realize about Box2D is that it is a true physics engine.  Box2D knows nothing about computer graphics and the world of pixels; it is simply a library that takes in numbers and spits out more numbers. And what are those numbers?  Meters, kilograms, seconds, etc.  All of Box2D’s measurements and calculations are for real-world measurements—only its “world” is a two-dimensional plane with top, bottom, left, and right edges.  You tell it things like: “The gravity of our world is 9.81 newtons per kilogram, and a circle with a radius of four meters and a mass of fifty kilograms is located ten meters above the world’s bottom.”   Box2D will then tell you things like: “One second later, the rectangle is at five meters from the bottom; two seconds later, it is ten meters below,” etc.  While this provides for an amazing and realistic physics engine, it also necessitates lots of complicated code in order to translate back and forth between the physics “world” (a key term in Box2D) and the world we want to draw on —the “pixel” world of Processing.</p>

<p>So when is it worth it to have this additional overhead?  If I just want to simulate a circle falling down a Processing window with gravity, do I really need to write all the extra Box2D code just to get that effect?  Certainly, the answer is no.  We saw how to do this rather easily in the first chapter of this book.    Let’s consider another scenario.  What if I want to have a hundred of those circles falling?  And what if those circles aren’t circles at all, but irregularly shaped polygons?  And what if I want these polygons to bounce off each other in a realistic manner when they collide?</p>

<p><a data-type="indexterm" data-primary=""collisions"">&nbsp;</a>
<a data-type="indexterm" data-primary=""physics"" data-secondary=""collisions"">&nbsp;</a></p>

<p>You may have noticed that the first four chapters of this book, while covering motion and forces in detail, has skipped over a rather important aspect of physics simulation—<em>collisions</em>.   Let’s pretend for a moment that you aren’t reading a chapter about libraries and that we decided right now to cover how to handle collisions in a particle system.   We’d have to evaluate and learn two distinct algorithms that address these questions:</p>

<ol>
<li>
<p>How do I determine if two shapes are colliding (i.e. intersecting)?</p></li>
<li>
<p>How do I determine the shapes’ velocity after the collision?</p></li>
</ol>

<p>If we’re thinking about shapes like rectangles or circles, question #1 isn’t too tough.  You’ve likely encountered this before.  For example, we know two circles are intersecting if the distance between them is less than the sum of their radii.</p>

<figure id="chapter05_figure1">
<img src="imgs/chapter05/ch05_01.png" alt="Figure 5.1"/>
<figcaption/>
</figure>
<p>OK. Now that we know how to determine if two circles are colliding, how do we calculate their velocities after the collision?   This is where we’re going to stop our discussion.   Why, you ask?  It’s not that understanding the math behind collisions isn’t important or valuable.  (In fact, I’m including additional examples on the website related to collisions without a physics library.)  The reason for stopping is that life is short (let this also be a reason for you to consider going outside and frolicking instead of programming altogether).  We can’t expect to master every detail of physics simulation.  And while we could continue this discussion for circles, it’s only going to lead us to wanting to work with rectangles.  And strangely shaped polygons.  And curved surfaces.  And swinging pendulums colliding with springy springs.  And and and and and.</p>

<p>Working with collisions in our Processing sketch while still having time to spend with our friends and family—that’s the reason for this chapter.   Erin Catto spent years developing solutions to these kinds of problems so you don’t need to engineer them yourselves, at least for now.</p>

<p>In conclusion, if you find yourself describing an idea for a Processing sketch and the word “collisions” comes up, then it’s likely time to learn Box2D.   (We’ll also encounter other words that might lead you down this path to Box2D, such as “joint,” “hinge,” “pulley,” “motor,” etc.)</p>
</section>







<section data-type="sect1" id="chapter05_section2">
<h1>5.2 Getting Box2D in Processing</h1>
<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""Processing and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""Box2D and"">&nbsp;</a></p>

<p>So, if Box2D is a physics engine that knows nothing about pixel-based computer graphics and is written in C++, how are we supposed to use it in Processing?</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""JBox2D and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Java"">&nbsp;</a>
<a data-type="indexterm" data-primary=""JBox2D"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""JBox2D"">&nbsp;</a></p>

<p>The good news is that Box2D is such an amazing and useful library that everyone wants to use it—Flash, Javascript, Python, Ruby programmers.  Oh, and Java programmers.  There is something called JBox2D, a Java port of Box2D.  And because Processing is built on top of Java, JBox2D can be used directly in Processing!</p>

<p>So here’s where we are so far.</p>

<ul>
<li>
<p><a href="http://www.box2d.org/">Box2D site</a> for reference.</p></li>
<li>
<p><a href="http://www.jbox2d.org/">JBox2D site</a> for Processing compatibility.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""PBox2D helper class"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PBox2D helper class"">&nbsp;</a></p>

<p>This is all you need to get started writing Box2D code in Processing.  However, as we are going to see in a moment, there are several pieces of functionality we’ll repeatedly need in our Processing code, and so it’s worth having one additional layer between our sketches and JBox2D.  I’m calling this PBox2D—a Processing Box2D “helper” library included as part of this book’s code example downloads.</p>

<ul>
<li>
<p><a href="http://github.com/shiffman/PBox2D">PBox2D GitHub repository</a></p></li>
</ul>

<p>It’s important to realize that PBox2D is not a Processing wrapper for all of Box2D.   After all, Box2D is a thoughtfully organized and well-structured API and there’s no reason to take it apart and re-implement it.  However, it’s useful to have a small set of functions that help you get your Box2D world set up, as well as help you figure out where to draw your Box2D shapes.  And this is what PBox2D will provide.</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""Fisica"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Fisica"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Marxer" data-secondary="Ricard"">&nbsp;</a></p>

<p>I should also mention before we move forward that there are other Processing libraries that wrap Box2D for you. One I would recommend taking a look at is <a href="http://www.ricardmarxer.com/fisica/">Fisica</a> by Ricard Marxer.</p>
</section>







<section data-type="sect1" id="chapter05_section3">
<h1>5.3 Box2D Basics</h1>
<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""usage"">&nbsp;</a></p>

<p>Do not despair! We really are going to get to the code very soon, and in some ways we’ll blow our previous work out of the water.  But before we’re ready to do that, it’s important to walk through the overall process of using Box2D in Processing.   Let’s begin by writing a pseudocode generalization of all of our examples in Chapters 1 through 4.</p>

<p><strong><em>SETUP:</em></strong></p>

<ol>
<li>
<p>Create all the objects in our world.</p></li>
</ol>

<p><strong><em>DRAW:</em></strong></p>

<ol>
<li>
<p>Calculate all the forces in our world.</p></li>
<li>
<p>Apply all the forces to our objects (F = M * A).</p></li>
<li>
<p>Update the locations of all the objects based on their acceleration.</p></li>
<li>
<p>Draw all of our objects.</p></li>
</ol>

<p>Great.  Let’s rewrite this pseudocode as it will appear in our Box2D examples.</p>

<p><strong><em>SETUP:</em></strong></p>

<ol>
<li>
<p>Create all the objects in our world.</p></li>
</ol>

<p><strong><em>DRAW:</em></strong></p>

<ol>
<li>
<p>Draw all of our objects.</p></li>
</ol>

<p>This, of course, is the fantasy of Box2D.  We’ve eliminated all of those painful steps of figuring out how the objects are moving according to velocity and acceleration.  Box2D is going to take care of this for us!   The good news is that this does accurately reflect the overall process.  Let’s imagine Box2D as a magic box.</p>

<p>In <strong function>setup()</strong>, we’re going to say to Box2D: “Hello there. Here are all of the things I want in my world.”  In <strong function>draw()</strong>, we’re going to politely ask Box2D: “Oh, hello again. If it’s not too much trouble, I’d like to draw all of those things in my world.  Could you tell me where they are?”</p>

<p>The bad news: it’s not as simple as the above explanation would lead you to believe.   For one, making the stuff that goes in the Box2D world involves wading through the documentation for how different kinds of shapes are built and configured.  Second, we have to remember that we can’t tell Box2D anything about pixels, as it will simply get confused and fall apart.  Before we tell Box2D what we want in our world, we have to convert our pixel units to Box2D “world” units.  And the same is true when it comes time to draw our stuff. Box2D is going to tell us the location of the things in its world, which we then have to translate for the pixel world.</p>

<ol>
<li>
<p>Create everything that lives in our pixel world.</p></li>
<li>
<p>Translate the pixel world into the Box2D world.</p></li>
</ol>

<ol>
<li>
<p>Ask Box2D where everything is.</p></li>
<li>
<p>Translate Box2D’s answer into the pixel world.</p></li>
<li>
<p>Draw everything.</p></li>
</ol>

<p>Now that we understand that anything we create in our Processing sketch has to be placed into the Box2D world, let’s look at an overview of the elements that make up that world.</p>

<p><a data-type="indexterm" data-primary=""body (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Box2D"" data-secondary=""core elements"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fixture (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""joint (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""shape (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Vec2 (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""Vec2 (Box2D element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""World class (Box2D)"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>World</em></strong>: Manages the physics simulation.  It knows everything about the overall coordinate space and also stores lists of every element in the world (see 2-4 below).</p></li>
<li>
<p><strong><em>Body</em></strong>: Serves as the primary element in the Box2D world. It has a location. It has a velocity. Sound familiar? The <strong klass>Body</strong> is essentially the class we’ve been writing on our own in our vectors and forces examples.</p></li>
<li>
<p><strong><em>Shape</em></strong>: Keeps track of all the necessary collision geometry attached to a body.</p></li>
<li>
<p><strong><em>Fixture</em></strong>:  Attaches a shape to a body and sets properties such as density, friction, and restitution.</p></li>
<li>
<p><strong><em>Joint</em></strong>: Acts as a connection between two bodies (or between one body and the world itself).</p></li>
</ol>

<p>In the next four sections, we are going to walk through each of the above elements in detail, building several examples along the way.   But first there is one other important element we should briefly discuss.</p>

<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.&#160;&#160; <strong><em>Vec2</em></strong>: Describes a vector in the Box2D world.</p>

<p>And so here we are, arriving with trepidation at an unfortunate truth in the world of using physics libraries.   Any physics simulation is going to involve the concept of a vector.  This is the good part.  After all, we just spent several chapters familiarizing ourselves with what it means to describe motion and forces with vectors.   We don’t have to learn anything new conceptually.</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""PVector vs."">&nbsp;</a>
<a data-type="indexterm" data-primary=""PVector class (Processing)"" data-secondary=""Box2D vs."">&nbsp;</a></p>

<p>Now for the part that makes the single tear fall from my eye: we don’t get to use <strong klass>PVector</strong>. It’s nice that Processing has <strong klass>PVector</strong> for us, but anytime you use a physics library you will probably discover that the library includes its own vector implementation.  This makes sense, after all; why should Box2D be expected to know about <strong klass>PVector</strong>?   And in many cases, the physics engine will want to implement a vector class in a specific way so that it is especially compatible with the rest of the library’s code.   So while we don’t have to learn anything new conceptually, we do have to get used to some new naming conventions and syntax.  Let’s quickly demonstrate a few of the basics in <strong klass>Vec2</strong> as compared to those in <strong klass>PVector</strong>.</p>

<p>Let’s say we want to add two vectors together.</p>

<p><a data-type="indexterm" data-primary=""add() function (Vec2 class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""addLocal() function (Vec2)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Vec2 (Box2D element)"" data-secondary=""adding vectors with"">&nbsp;</a></p>

<table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
a.addLocal(b);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
Vec2 c = a.add(b);
</pre>
</td>
</tr>
</table>
<p><a data-type="indexterm" data-primary=""Vec2 (Box2D element)"" data-secondary=""multiplying vectors with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Vec2 (Box2D element)"" data-secondary=""scaling vectors with"">&nbsp;</a></p>

<p>How about if we want to multiply and scale them?</p>

<table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float n = 5;
a.mult(n);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
a.mulLocal(n);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float n = 5;
PVector c = PVector.mult(a,n);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
Vec2 c = a.mul(n);
</pre>
</td>
</tr>
</table>
<p>Magnitude and normalize?</p>

<p><a data-type="indexterm" data-primary=""Vec2 (Box2D element)"" data-secondary=""manitude" data-tertiary="finding"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Vec2 (Box2D element)"" data-secondary=""normalizing vectors"">&nbsp;</a></p>

<table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float m = a.length();
a.normalize();
</pre>
</td>
</tr>
</table>
<p><a data-type="indexterm" data-primary=""JBox2D"" data-secondary=""full documentation for"">&nbsp;</a></p>

<p>As you can see, the concepts are the same, but the function names and the arguments are slightly different.  For example, instead of static and non-static <strong function>add()</strong> and <strong function>mult()</strong>, if a <strong klass>Vec2</strong> is altered, the word “local” is included in the function name—<strong function>addLocal()</strong>, <strong function>multLocal()</strong>.</p>

<p>We’ll cover the basics of what you need to know here, but if you are looking for more, full documentation of <strong klass>Vec2</strong> can be found by downloading the <a href="http://code.google.com/p/jbox2d/">JBox2D source code</a>.</p>
</section>







<section data-type="sect1" id="chapter05_section4">
<h1>5.4 Living in a Box2D World</h1>
<p><a data-type="indexterm" data-primary=""World class (Box2D)"">&nbsp;</a></p>

<p>The Box2D <strong klass>World</strong> object is in charge of everything. It manages the coordinate space of the world, all of the stuff that lives in the world, and decides when time moves forward in the world.</p>

<p><a data-type="indexterm" data-primary=""PBox2D helper class"" data-secondary=""createWorld() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""World class (Box2D)"" data-secondary=""createWorld() function (PBox2D)"">&nbsp;</a></p>

<p>In order to have Box2D as part of our Processing sketches, the <strong klass>World</strong> is the very first thing that needs to be set up.  Here is where PBox2D comes in handy and takes care of making the world for us.</p>

<pre data-type="programlisting" data-code-language="java">PBox2D box2d;

void setup() {
  box2d = new PBox2D(this);
  // Initializes a Box2D world with default settings
  box2d.createWorld();
}</pre>

<p>When you call <strong function>createWorld()</strong>, PBox2D will set up a default gravity for you (pointing down); however, you can always alter the gravity of your world by saying:</p>

<p><a data-type="indexterm" data-primary=""setGravity() function (World class)"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">  box2d.setGravity(0, -10);</pre>

<p>It’s worth noting that gravity doesn’t have to be fixed, nor does it always have to point downwards; you can adjust the gravity vector while your program is running.  Gravity can be turned off by setting it to a (0,0) vector.</p>

<p>So, what are those numbers 0 and -10?   This should remind us of one of the most important details of using Box2D: the Box2D coordinate system is not your pixel coordinate system!   Let’s look at how Box2D and a Processing window think differently of their worlds.</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""coordinate system vs. Processing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""coordinate systems"" data-secondary=""Box2D vs. Processing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""coordinate systems vs. Box2D"">&nbsp;</a></p>

<figure id="chapter05_figure2">
<img src="imgs/chapter05/ch05_02.png" alt="Figure 5.2"/>
<figcaption/>
</figure>
<p>Notice how in Box2D <em>(0,0)</em> is in the center and <em>up</em> is the positive direction along the y-axis!   Box2D’s coordinate system is just like that lovely old-fashioned Cartesian one with <em>(0,0)</em> in the center and <em>up</em> pointing in a positive direction.  Processing, on the other hand, uses a traditional computer graphics coordinate system where <em>(0,0)</em> is in the top left corner and <em>down</em> is the positive direction along the y-axis.  This is why if we want objects to fall down with gravity, we need to give Box2D a gravity force with a negative y-value.</p>

<pre data-type="programlisting" data-code-language="java">Vec2 gravity = new Vec2(0, -10);</pre>

<p>Luckily for us, if we prefer to think in terms of pixel coordinates (which as Processing programmers, we are likely to do), PBox2D offers a series of helper functions that convert between pixel space and Box2D space.  Before we move onto the next section and begin creating Box2D bodies, let’s take a look at how these helper functions work.</p>

<p><a data-type="indexterm" data-primary=""coordPixelsToWorld() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PBox2D helper class"" data-secondary=""coordinate systems" data-tertiary="converting between"">&nbsp;</a></p>

<p>Let’s say we want to tell Box2D where the mouse is in its world.  We know the mouse is located at <strong var>(mouseX,mouseY)</strong> in Processing.  To convert it, we say we want to convert a “coordinate” from “pixels” to “world”—<strong function>coordPixelsToWorld()</strong>.  Or:</p>

<pre data-type="programlisting" data-code-language="java">// Convert mouseX,mouseY to
// coordinate in Box2D world.
Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);</pre>

<p>What if we had a Box2D world coordinate and wanted to translate it to our pixel space?</p>

<pre data-type="programlisting" data-code-language="java">// To demonstrate, let’s just make up a world position.
Vec2 worldPos = new Vec2(-10,25);

// Convert to pixel space.
// This is necessary because ultimately we
// are going to want to draw the elements in our window.
Vec2 pixelPos = box2d.coordWorldToPixels(worldPos);
ellipse(pixelPos.x, pixelPos.y,16,16);</pre>

<p>PBox2D has a set of functions to take care of translating back and forth between the Box2D world and pixels.  It’s probably easier to learn about all of these functions during the course of actually implementing our examples, but let’s quickly look over the list of the possibilities.</p>

<p><a data-type="indexterm" data-primary=""coordWorldToPixels() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""scalarPixelsToWorld() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""scalarWorldToPixels() function (PBox2D)"">&nbsp;</a></p>

<table class="code">
<tr>
<th>Task</th>
<th>Function</th>
</tr>
<tr>
<td>Convert location from World to Pixels</td>
<td><pre>Vec2 coordWorldToPixels(Vec2 world)</pre></td>
</tr>
<tr>
<td>Convert location from World to Pixels</td>
<td><pre>Vec2 coordWorldToPixels(float worldX, float worldY)</pre></td>
</tr>
<tr>
<td>Convert location from Pixels to World</td>
<td><pre>Vec2 coordPixelsToWorld(Vec2 screen)</pre></td>
</tr>
<tr>
<td>Convert location from Pixels to World</td>
<td><pre>Vec2 coordPixelsToWorld(float pixelX, float pixelY)</pre></td>
</tr>

<tr>
<td>Scale a dimension (such as height, width, or radius) from Pixels to World</td>
<td><pre>float scalarPixelsToWorld(float val)</pre></td>
</tr>

<tr>
<td>Scale a dimension from World to Pixels</td>
<td><pre>float scalarWorldToPixels(float val)</pre></td>
</tr>

</table>
<p>There are also additional functions that allow you to pass or receive a <strong klass>PVector</strong> when translating back and forth, but since we are only working with Box2D in the examples in this chapter, it’s easiest to stick with the <strong klass>Vec2</strong> class for all vectors.</p>

<p>Once the world is initialized, we are ready to actually put stuff in the world—Box2D bodies.</p>
</section>







<section data-type="sect1" id="chapter05_section5">
<h1>5.5 Building a Box2D Body</h1>
<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""building"">&nbsp;</a></p>

<p>A Box2D body is the primary element in the Box2D world.  It’s the equivalent to the <strong klass>Mover</strong> class we built on our own in previous chapters—the thing that moves around the space and experiences forces. It can also be static (meaning fixed and not moving). It’s important to note, however, that a body has no geometry; it isn’t anything physical.   Rather, bodies have Box2D shapes attached to them. (This way, a body can be a single rectangle or a rectangle attached to a circle, etc.) We’ll look at shapes in a moment; first, let’s build a body.</p>





<section data-type="sect2" id="_step_1_define_a_body">
<h2>Step 1:  Define a body.</h2>
<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""BodyDef type"">&nbsp;</a>
<a data-type="indexterm" data-primary=""BodyDef type (body element)"">&nbsp;</a></p>

<p>The first thing we have to do is create a “body definition.” This will let us define the properties of the body we intend to make.  This may seem a bit awkward at first, but it’s how Box2D is structured.  Anytime you want to make a “thing,” you have to make a “thing definition” first.  This will hold true for bodies, shapes, and joints.</p>

<pre data-type="programlisting" data-code-language="java">// Make a body definition before making a Body.
BodyDef bd = new BodyDef();</pre>
</section>







<section data-type="sect2" id="_step_2_configure_the_body_definition">
<h2>Step 2:  Configure the body definition.</h2>
<p><a data-type="indexterm" data-primary=""BodyDef type (body element)"" data-secondary=""configuring"">&nbsp;</a></p>

<p>The body definition is where we can set specific properties or attributes of the body we intend to make.  One attribute of a body, for example, is its starting location.  Let’s say we want to position the body in the center of the Processing window.</p>

<pre data-type="programlisting" data-code-language="java">// A Vec2 in the center of the Processing window
Vec2 center = new Vec2(width/2,height/2);</pre>

<p>Danger, danger!  I’m not going to address this with every single example, but it’s important to at least point out the perilous path we are taking with the above line of code.  Remember, if we are going to tell Box2D where we want the body to start, we must give Box2D a world coordinate!  Yes, we want to think of its location in terms of pixels, but Box2D doesn’t care.  And so before we pass that position to the body definition, we must make sure to use one of our helper conversion functions.</p>

<pre data-type="programlisting" data-code-language="java">// A Vec2 in the center of the
// Processing window converted to Box2D World coordinates!
Vec2 center = box2d.coordPixelsToWorld(width/2,height/2));
// Setting the position attribute of the Box2D body definition
bd.position.set(center);</pre>

<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""types of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""dynamic (body type)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""kinematic (body type)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""static (body type)"">&nbsp;</a></p>

<p>The body definition must also specify the “type” of body we want to make.  There are three possibilities:</p>

<ul>
<li>
<p><strong><em>Dynamic.</em></strong>  This is what we will use most often—a “fully simulated” body.  A dynamic body moves around the world, collides with other bodies, and responds to the forces in its environment.</p></li>
<li>
<p><strong><em>Static.</em></strong> A static body is one that cannot move (as if it had an infinite mass).  We’ll use static bodies for fixed platforms and boundaries.</p></li>
<li>
<p><strong><em>Kinematic.</em></strong>  A kinematic body can be moved manually by setting its velocity directly.  If you have a user-controlled object in your world, you can use a kinematic body.   Note that kinematic bodies collide only with dynamic bodies and not with other static or kinematic ones.</p></li>
</ul>

<p>There are several other properties you can set in the body definition.  For example, if you want your body to have a fixed rotation (i.e. never rotate), you can say:</p>

<pre data-type="programlisting" data-code-language="java">bd.fixedRotation = true;</pre>

<p>You can also set a value for linear or angular damping, so that the object continuously slows as if there is friction.</p>

<pre data-type="programlisting" data-code-language="java">bd.linearDamping = 0.8;
bd.angularDamping = 0.9;</pre>

<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""bullet setting for"">&nbsp;</a></p>

<p>In addition, fast-moving objects in Box2D should be set as bullets.  This tells the Box2D engine that the object may move very quickly and to check its collisions more carefully so that it doesn’t accidentally jump over another body.</p>

<pre data-type="programlisting" data-code-language="java">bd.bullet = true;</pre>
</section>







<section data-type="sect2" id="_step_3_create_the_body">
<h2>Step 3:  Create the body.</h2>
<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""object" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""createBody() function (PBox2D)"">&nbsp;</a></p>

<p>Once we’re done with the definition (<strong klass>BodyDef</strong>), we can create the <strong klass>Body</strong> object itself.  PBox2D provides a helper function for this—<strong function>createBody</strong>().</p>

<pre data-type="programlisting" data-code-language="java">// The Body object is created by passing in the Body
// Definition. (This allows for making multiple bodies from
// one definition.)
Body body = box2d.createBody(bd);</pre>
</section>







<section data-type="sect2" id="_step_4_set_any_other_conditions_for_the_body_s_starting_state">
<h2>Step 4:  Set any other conditions for the body’s starting state.</h2>
<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""initial settings for"">&nbsp;</a></p>

<p>Finally, though not required, if you want to set any other initial conditions for the body, such as linear or angular velocity, you can do so with the newly created <strong klass>Body</strong> object.</p>

<pre data-type="programlisting" data-code-language="java">// Setting an arbitrary initial velocity
body.setLinearVelocity(new Vec2(0,3));
// Setting an arbitrary initial angular velocity
body.setAngularVelocity(1.2);</pre>
</section>


</section>







<section data-type="sect1" id="chapter05_section6">
<h1>5.6 Three’s Company: Bodies and Shapes and Fixtures</h1>
<p><a data-type="indexterm" data-primary=""Shape (Box2D element)"">&nbsp;</a></p>

<p>A body on its own doesn’t physically exist in the world. It’s like a soul with no human form to inhabit. For a body to have mass, we must first define a shape and attach that shape to the body with something known as a fixture.</p>

<p><a data-type="indexterm" data-primary=""Shape (Box2D element)"" data-secondary=""friction attribute"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Shape (Box2D element)"" data-secondary=""restitution attribute"">&nbsp;</a></p>

<p>The job of the Box2D <strong klass>Shape</strong> class is to keep track of all the necessary collision geometry attached to a body.  A shape also has several important properties that affect the body’s motion.  There is density, which ultimately determines that body’s mass.  Shapes also have <em>friction</em> and <em>restitution</em> (“bounciness”) which will be defined through a fixture. One of the nice things about Box2D’s methodology, which separates the concepts of bodies and shapes into two separate objects, is that you can attach multiple shapes to a single body in order to create more complex forms.  We’ll see this in a future example.</p>

<p>To create a shape, we need to first decide what kind of shape we want to make.  For most non-circular shapes, a <strong klass>PolygonShape</strong> object will work just fine. For example, let’s look at how we define a rectangle.</p>





<section data-type="sect2" id="_step_1_define_a_shape">
<h2>Step 1:  Define a shape.</h2>
<p><a data-type="indexterm" data-primary=""Shape (Box2D element)"" data-secondary=""defining"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">// Define the shape: a polygon.
PolygonShape ps = new PolygonShape();</pre>

<p>Next up, we have to define the width and height of the rectangle. Let’s say we want our rectangle to be 150×100 pixels. Remember, pixel units are no good for Box2D shapes! So we have to use our helper functions to convert them first.</p>

<pre data-type="programlisting" data-code-language="java">//[full] Scale dimensions from pixels to Box2D world.
float box2Dw = box2d.scalarPixelsToWorld(150);
float box2Dh = box2d.scalarPixelsToWorld(100);
//[end]

// Use setAsBox() function to define shape as a rectangle.
ps.setAsBox(box2Dw, box2Dh);</pre>
</section>







<section data-type="sect2" id="_step_2_create_a_fixture">
<h2>Step 2:  Create a fixture.</h2>
<p><a data-type="indexterm" data-primary=""fixture (Box2D element)"" data-secondary=""creating"">&nbsp;</a></p>

<p>The shape and body are made as two separate entities.  In order to attach a shape to a body, we must make a fixture.   A fixture is created, just as with the body, via a fixture definition (i.e. <strong klass>FixtureDef</strong> class) and assigned a shape.</p>

<pre data-type="programlisting" data-code-language="java">FixtureDef fd = new FixtureDef();
// The fixture is assigned the PolygonShape we just made.
fd.shape = ps;</pre>

<p>Once we have the fixture definition, we can set parameters that affect the physics for the shape being attached.</p>

<pre data-type="programlisting" data-code-language="java">// The coefficient of friction for the
// shape, typically between 0 and 1
fd.friction = 0.3;
// The Shape’s restitution (i.e. elasticity),
// typically between 0 and 1
fd.restitution = 0.5;
// The Shape’s density, measured in
// kilograms per meter squared
fd.density = 1.0;</pre>
</section>







<section data-type="sect2" id="_step_3_attach_the_shape_to_the_body_with_the_fixture">
<h2>Step 3:  Attach the shape to the body with the fixture.</h2>
<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""attaching fixture element to"">&nbsp;</a>
<a data-type="indexterm" data-primary=""createFixture() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fixture (Box2D element)"" data-secondary=""attaching to body element"">&nbsp;</a></p>

<p>Once the fixture is defined, all we have left to do is attach the shape to the body with the fixture by calling the <strong function>createFixture()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">// Creates the Fixture and attaches the Shape to the Body object
body.createFixture(fd);</pre>

<p>I should note that Step 2 can be skipped if you do not need to set the physics properties. (Box2D will use default values.)  You can create a fixture and attach the shape all in one step by saying:</p>

<pre data-type="programlisting" data-code-language="java">// Creates the Fixture and attaches the Shape with a density of 1
body.createFixture(ps,1);</pre>

<p>While most of our examples will take care of attaching shapes only once when the body is first built, this is not a limitation of Box2D.   Box2D allows for shapes to be created and destroyed on the fly.</p>

<p>Before we put any of this code we’ve been writing into a Processing sketch, let’s review all the steps we took to construct a Body.</p>

<ol>
<li>
<p>Define a body using a <strong klass>BodyDef</strong> object (set any properties, such as location).</p></li>
<li>
<p>Create the <strong klass>Body</strong> object from the body definition.</p></li>
<li>
<p>Define a <strong klass>Shape</strong> object using <strong klass>PolygonShape</strong>, <strong klass>CircleShape</strong>, or any other shape class.</p></li>
<li>
<p>Define a fixture using <strong klass>FixtureDef</strong> and assign the fixture a shape (set any properties, such as friction, density, and restitution).</p></li>
<li>
<p>Attach the shape to the body.</p></li>
</ol>

<pre data-type="programlisting" data-code-language="java">// Step 1. Define the body.
BodyDef bd = new BodyDef();
bd.position.set(box2d.coordPixelsToWorld(width/2,height/2));

// Step 2. Create the body.
Body body = box2d.createBody(bd);

// Step 3. Define the shape.
PolygonShape ps = new PolygonShape();
float w = box2d.scalarPixelsToWorld(150);
float h = box2d.scalarPixelsToWorld(100);
ps.setAsBox(w, h);

// Step 4. Define the fixture.
FixtureDef fd = new FixtureDef();
fd.shape = ps;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

// Step 5. Attach the shape to the body with the Fixture.
body.createFixture(fd);</pre>

<div id="chapter05_exercise1" data-type="example">
<h5>Exercise 5.1</h5>
<p>Knowing what you know about Box2D so far, fill in the blank in the code below that demonstrates how to make a circular shape in Box2D.</p>

<pre data-type="programlisting" data-code-language="java">CircleShape cs = new CircleShape();
float radius = 10;
cs.m_radius = ____________________;
FixtureDef fd = new FixtureDef();
fd.shape = cs;
fd.density = 1;
fd.friction = 0.1;
fd.restitution = 0.3;

body.createFixture(fd);</pre>
</div>
</section>


</section>







<section data-type="sect1" id="chapter05_section7">
<h1>5.7  Box2D and Processing: Reunited and It Feels So Good</h1>
<p>Once a body is made, it lives in the Box2D physics world. Box2D will always know it’s there, check it for collisions, move it appropriately according to the forces, etc. It’ll do all that for you without you having to lift a finger! What it won’t do, however, is display the body for you. This is a good thing. This is your time to shine. When working with Box2D, what we’re essentially saying is, “I want to be the designer of my world, and I want you, Box2D, to compute all the physics.”</p>

<p><a data-type="indexterm" data-primary=""body lists" data-secondary="maintaining in Processing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""getBodyList() function (World class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Processing"" data-secondary=""body lists" data-tertiary="maintaining"">&nbsp;</a>
<a data-type="indexterm" data-primary=""World class (Box2D)"" data-secondary=""getBodyList() function"">&nbsp;</a></p>

<p>Now, Box2D will keep a list of all the bodies that exist in the world. This can be accessed by calling the World object’s <strong function>getBodyList()</strong> function. Nevertheless, what I’m going to demonstrate here is a technique for keeping your own body lists. Yes, this may be a bit redundant and we perhaps sacrifice a bit of efficiency. But we more than make up for that with ease of use. This methodology will allow us to program like we’re used to in Processing, and we can easily keep track of which bodies are which and render them appropriately. Let’s consider the structure of the following Processing sketch:</p>

<figure id="chapter05_figure3">
<img src="imgs/chapter05/ch05_03.png" alt="Figure 5.3"/>
<figcaption/>
</figure>
<p>This looks like any ol’ Processing sketch. We have a main tab called “Boxes” and a “Boundary” and a “Box” tab. Let’s think about the Box tab for a moment. The Box tab is where we will write a simple class to describe a <strong klass>Box</strong> object, a rectangular body in our world.</p>

<pre data-type="programlisting" data-code-language="java">class Box  {

  //[full] Our Box object has an x,y location and a width and a height.
  float x,y;
  float w,h;
  //[end]

  Box(float x_, float y_) {
    //[full] The location is initalized in the constructor via arguments
    x = x_;
    y = y_;
    //[end]
    w = 16;
    h = 16;
  }

  void display() {
    // We draw the Box object using Processing’s rect() function.
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
}</pre>

<p>Let’s write a main tab that creates a new <strong klass>Box</strong> whenever the mouse is pressed and stores all the <strong klass>Box</strong> objects in an <strong klass>ArrayList</strong>.  (This is very similar to our approach in the particle system examples from Chapter 4.)</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex01.png" alt="ch05 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 5.1: A comfortable and cozy Processing sketch that needs a little Box2D</strong></p>

<pre data-type="programlisting" data-code-language="java">// A list to store all Box objects
ArrayList&lt;Box&gt; boxes;

void setup() {
  size(400,300);
  boxes = new ArrayList&lt;Box&gt;();
}

void draw() {
  background(255);

  //[full] When the mouse is pressed, add a new Box object.
  if (mousePressed) {
    Box p = new Box(mouseX,mouseY);
    boxes.add(p);
  }
  //[end]

  //[full] Display all the Box objects.
  for (Box b: boxes) {
    b.display();
  }
  //[end]
}</pre>

<p>Now, here’s our assignment. Take the above example verbatim, but instead of drawing fixed boxes on the screen, draw boxes that experience physics (via Box2D) as soon as they appear.</p>

<p>We’ll need two major steps to accomplish our goal.</p>





<section data-type="sect2" id="_step_1_add_box2d_to_our_main_program_i_e_setup_and_draw">
<h2>Step 1: Add Box2D to our main program (i.e. setup() and draw()).</h2>
<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""Box2D objects" data-tertiary="adding to projects"">&nbsp;</a></p>

<p>This part is not too tough.  We saw this already in our discussion of building a Box2D world.  This is taken care of for us by the PBox2D helper class.  We can create a PBox2D object and initialize it in <strong function>setup()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">PBox2D box2d;

void setup() {
  //[full] Initialize and create the Box2D world.
  box2d = new PBox2D(this);
  box2d.createWorld();
  //[end]
}</pre>

<p><a data-type="indexterm" data-primary=""step() function (Box2D)"">&nbsp;</a></p>

<p>Then in <strong function>draw()</strong>, we need to make sure we call one very important function: <strong function>step()</strong>. Without this function, nothing would ever happen! <strong function>step()</strong> advances the Box2D world a step further in time. Internally, Box2D sweeps through and looks at all of the Bodies and figures out what to do with them. Just calling <strong function>step()</strong> on its own moves the Box2D world forward with default settings; however, it is customizable (and this is documented in the PBox2D source).</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  // We must always step through time!
  box2d.step();
}</pre>
</section>







<section data-type="sect2" id="_step_2_link_every_processing_box_object_with_a_box2d_body_object">
<h2>Step 2: Link every Processing Box object with a Box2D Body object.</h2>
<p>As of this moment, the <strong klass>Box</strong> class includes variables for location and width and height.  What we now want to say is:</p>

<p>“I hereby relinquish the command of this object’s position to Box2D.  I no longer need to keep track of anything related to location, velocity, and acceleration.  Instead, I only need to keep track of a Box2D body and have faith that Box2D will do the rest.”</p>

<pre data-type="programlisting" data-code-language="java">class Box  {

  // Instead of any of the usual variables,
  // we will store a reference to a Box2D body.
  Body body;
  float w;
  float h;</pre>

<p>We don’t need <em>(x,y)</em> anymore since, as we’ll see, the body itself will keep track of its location.   The body technically could also keep track of the width and height for us, but since Box2D isn’t going to do anything to alter those values over the life of the <strong klass>Box</strong> object, we might as well just hold onto them ourselves until it’s time to draw the <strong klass>Box</strong>.</p>

<p>Then, in our constructor, in addition to initializing the width and height, we can go ahead and include all of the body and shape code we learned in the previous two sections!</p>

<pre data-type="programlisting" data-code-language="java">  Box() {
    w = 16;
    h = 16;

    // Build body.
    BodyDef bd = new BodyDef();
    bd.type = BodyType.DYNAMIC;
    bd.position.set(box2d.coordPixelsToWorld(mouseX,mouseY));
    body = box2d.createBody(bd);

    // Build shape.
    PolygonShape ps = new PolygonShape();
    //[full] Box2D considers the width and height of a rectangle to be the distance from the center to the edge (so half of what we normally think of as width or height).
    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    //[end]
    ps.setAsBox(box2dW, box2dH);

    FixtureDef fd = new FixtureDef();
    fd.shape = ps;
    fd.density = 1;
    // Set physics parameters.
    fd.friction = 0.3;
    fd.restitution = 0.5;

    // Attach the Shape to the Body with the Fixture.
    body.createFixture(fd);
 }</pre>

<p>OK, we’re almost there. Before we introduced Box2D, it was easy to draw the <strong klass>Box</strong>. The object’s location was stored in variables <strong var>x</strong> and <strong var>y</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  //[full] Drawing the object using rect()
  void display() {
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
  //[end]</pre>

<p><a data-type="indexterm" data-primary=""getBodyPixelCoord() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""PBox2D helper class"" data-secondary=""getBodyPixelCoord() function (PBox2D)"">&nbsp;</a></p>

<p>But now Box2D manages the object’s motion, so we can no longer use our own variables to display the shape. Not to fear! Our <strong klass>Box</strong> object has a reference to the Box2D body associated with it. So all we need to do is politely ask the body, “Pardon me, where are you located?” Since this is a task we’ll need to do quite often, PBox2D includes a helper function: <strong function>getBodyPixelCoord()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">Vec2 pos = box2d.getBodyPixelCoord(body);</pre>

<p>Just knowing the location of a body isn’t enough; we also need to know its angle of rotation.</p>

<p><a data-type="indexterm" data-primary=""getAngle() function (PBox2D)"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">float a = body.getAngle();</pre>

<p><a data-type="indexterm" data-primary=""rotate() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""translate() function (PBox2D)"">&nbsp;</a></p>

<p>Once we have the location and angle, it’s easy to display the object using <strong function>translate()</strong> and <strong function>rotate()</strong>.  Note, however, that the Box2D coordinate system considers rotation in the opposite direction from Processing, so we need to multiply the angle by -1.</p>

<figure id="chapter05_figure4">
<img src="imgs/chapter05/ch05_04.png" alt="Figure 5.4"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">
  void display() {
    //[full] We need the Body’s location and angle.
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();
    //[end]

    pushMatrix();
    //[full] Using the Vec2 position and float angle to translate and rotate the rectangle
    translate(pos.x,pos.y);
    rotate(-a);
    //[end]
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(0,0,w,h);
    popMatrix();
  }</pre>

<p>In case we want to have objects that can be removed from the Box2D world, it’s also useful to include a function to destroy a body, such as:</p>

<p><a data-type="indexterm" data-primary=""destroyBody() function (PBox2D)"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">  // This function removes a body from the Box2D world.
  void killBody() {
    box2d.destroyBody(body);
  }</pre>

<div id="chapter05_exercise2" data-type="example">
<h5>Exercise 5.2</h5>
<figure class="screenshot">
<img src="imgs/chapter05/ch05_exc02.png" alt="ch05 exc02"/>
<figcaption/>
</figure>
<p>In this chapter&#8217;s code downloads, find the sketch named “box2d_exercise.”  Using the methodology outlined in this chapter, add the necessary code to the main and Box tabs to implement Box2D physics.  The result should appear as in the screenshot above.   Be more creative in how you render the boxes.</p>
</div>
</section>


</section>







<section data-type="sect1" id="chapter05_section8">
<h1>5.8  Fixed Box2D Objects</h1>
<p><a data-type="indexterm" data-primary=""BodyDef type (body element)"" data-secondary=""STATIC type"">&nbsp;</a>
<a data-type="indexterm" data-primary=""boundaries"" data-secondary=""fixed"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Box2D"" data-secondary=""fixed objects in"">&nbsp;</a>
<a data-type="indexterm" data-primary=""static (body type)"">&nbsp;</a></p>

<p>In the example we just created, the <strong klass>Box</strong> objects appear at the mouse location and fall downwards due to Box2D’s default gravity force.  What if we wanted to install some immovable boundaries in the Box2D world that would block the path of the <strong klass>Box</strong> objects (as in the illustration below)?</p>

<p>Box2D makes this easy for us by providing a means to lock a body (and any associated shapes) in place.   Just set the <strong klass>BodyDef</strong> object&#8217;s type to <strong var>STATIC</strong>.</p>

<pre data-type="programlisting" data-code-language="java"> BodyDef bd = new BodyDef();
 // When BodyDef type = STATIC, the
 // Body is locked in place.
 bd.type = BodyType.STATIC;</pre>

<p>We can add this feature to our Boxes example by writing a <strong klass>Boundary</strong> class and having each boundary create a fixed Box2D body.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex02.png" alt="ch05 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 5.2: Falling boxes hitting boundaries</strong></p>

<pre data-type="programlisting" data-code-language="java">class Boundary {

  //[full] A boundary is a simple rectangle with x, y, width, and height.
  float x,y;
  float w,h;
  //[end]
  Body b;

  Boundary(float x_,float y_, float w_, float h_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;

    // Build the Box2D Body and Shape.
    BodyDef bd = new BodyDef();
    bd.position.set(box2d.coordPixelsToWorld(x,y));
    // Make it fixed by setting type to STATIC!
    bd.type = BodyType.STATIC;
    b = box2d.createBody(bd);

    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    PolygonShape ps = new PolygonShape();
    // The PolygonShape is just a box.
    ps.setAsBox(box2dW, box2dH);

    // Using the createFixture() shortcut
    b.createFixture(ps,1);
  }

  // Since we know it can never move, we can just draw it
  // the old-fashioned way, using our original
  // variables. No need to query Box2D.
  void display() {
    fill(0);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }

}</pre>
</section>







<section data-type="sect1" id="chapter05_section9">
<h1>5.9  A Curvy Boundary</h1>
<p><a data-type="indexterm" data-primary=""boundaries"" data-secondary=""curvy"">&nbsp;</a>
<a data-type="indexterm" data-primary=""ChainShape class"">&nbsp;</a></p>

<p>If you want a fixed boundary that is a curved surface (as opposed to a polygon), this can be achieved with the shape <strong klass>ChainShape</strong>.</p>

<p>The <strong klass>ChainShape</strong> class is another shape like <strong klass>PolygonShape</strong> or <strong klass>CircleShape</strong>, so to include one in our system, we follow the same steps.</p>





<section data-type="sect2" id="_step_1_define_a_body_2">
<h2>Step 1: Define a body.</h2>
<pre data-type="programlisting" data-code-language="java">// The body does not need a position; the
// EdgeShape will take care of that for us.
// It also does not need a type, as it is STATIC
// by default.
BodyDef bd = new BodyDef();
Body body = box2d.world.createBody(bd);</pre>
</section>







<section data-type="sect2" id="_step_2_define_the_shape">
<h2>Step 2: Define the Shape.</h2>
<pre data-type="programlisting" data-code-language="java">ChainShape chain = new ChainShape();</pre>
</section>







<section data-type="sect2" id="_step_3_configure_the_shape">
<h2>Step 3: Configure the Shape.</h2>
<p><a data-type="indexterm" data-primary=""ChainShape class"" data-secondary=""configuring"">&nbsp;</a></p>

<p>The <strong klass>ChainShape</strong> object is a series of connected vertices.  To create the chain, we must first specify an array of vertices (each as a <strong klass>Vec2</strong> object).  For example, if we wanted a straight line from the left-hand side of our window to the right-hand side, we would just need an array of two vertices: (0,150) and (width,150).  (Note that if you want to create a loop where the first vertex connects to the last vertex in a loop, you can use the <strong klass>ChainLoop</strong> class instead.)</p>

<pre data-type="programlisting" data-code-language="java">Vec2[] vertices = new Vec2[2];
// Adding a vertex on the right side of window
vertices[0] = box2d.coordPixelsToWorld(0,150);
// Adding a vertex on the left side of window
vertices[1] = box2d.coordPixelsToWorld(width,150);</pre>

<p>To create the chain with the vertices, the array is then passed into a function called <strong function>createChain()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// If you don’t want to use the entire array,
// you can specify a value less than length.
chain.createChain(vertices, vertices.length);</pre>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex03.png" alt="ch05 ex03"/>
<figcaption/>
</figure></section>







<section data-type="sect2" id="_step_4_attach_the_shape_to_the_body_with_a_fixture">
<h2>Step 4: Attach the Shape to the body with a Fixture.</h2>
<p>A <strong klass>Shape</strong> is not part of Box2D unless it is attached to a body.  Even if it is a fixed boundary and never moves, it must still be attached.  Just as with other shapes, a <strong klass>ChainShape</strong> object can be given properties like restitution and friction with a <strong klass>Fixture</strong>.</p>

<pre data-type="programlisting" data-code-language="java">FixtureDef fd = new FixtureDef();
// A fixture assigned to the ChainShape
fd.shape = chain;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

body.createFixture(fd);</pre>

<p>Now, if we want to include a <strong klass>ChainShape</strong> object in our sketch, we can follow the same strategy as we did with a fixed boundary.  Let’s write a class called <strong klass>Surface</strong>:</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex04.png" alt="ch05 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 5.3: ChainShape with three hard-coded vertices</strong></p>

<pre data-type="programlisting" data-code-language="java">class Surface {
  ArrayList&lt;Vec2&gt; surface;

  Surface() {

    surface = new ArrayList&lt;Vec2&gt;();
    //[full] 3 vertices in pixel coordinates
    surface.add(new Vec2(0, height/2+50));
    surface.add(new Vec2(width/2, height/2+50));
    surface.add(new Vec2(width, height/2));
    //[end]

    ChainShape chain = new ChainShape();

    // Make an array of Vec2 for the ChainShape.
    Vec2[] vertices = new Vec2[surface.size()];


    for (int i = 0; i &lt; vertices.length; i++) {
      //[offset-up] Convert each vertex to Box2D World coordinates.
      vertices[i] = box2d.coordPixelsToWorld(surface.get(i));
    }

    // Create the ChainShape with array of Vec2.
    chain.createChain(vertices, vertices.length);

    //[full] Attach the Shape to the Body.
    BodyDef bd = new BodyDef();
    Body body = box2d.world.createBody(bd);
    body.createFixture(chain, 1);
    //[end]
  }</pre>

<p>Notice how the above class includes an <strong klass>ArrayList</strong> to store a series of <strong klass>Vec2</strong> objects.   Even though we fully intend to store the coordinates of the chain in the chain shape itself, we are choosing the ease of redundancy and keeping our own list of those points as well.  Later, when we go to draw the <strong klass>Surface</strong> object, we don’t have to ask Box2D for the locations of the chain shape&#8217;s vertices.</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    strokeWeight(1);
    stroke(0);
    noFill();
    //[full] Draw the ChainShape as a series of vertices.
    beginShape();
    for (Vec2 v: surface) {
      vertex(v.x,v.y);
    }
    //[end]
    endShape();
  }
}</pre>

<p>What we need in <strong function>setup()</strong> and <strong function>draw()</strong> for the <strong klass>Surface</strong> object is quite simple, given that Box2D takes care of all of the physics for us.</p>

<pre data-type="programlisting" data-code-language="java">PBox2D box2d;

Surface surface;

void setup() {
  size(500,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  // Make a Surface object.
  surface = new Surface();
}

void draw() {
  box2d.step();

  background(255);
  // Draw the Surface.
  surface.display();
}</pre>

<div id="chapter05_exercise3" data-type="example">
<h5>Exercise 5.3</h5>
<p>Review how we learned to draw a wave pattern in Chapter 3.  Create a <strong klass>ChainShape</strong> object out of a sine wave.  Try using <a href="#intro_section6">Perlin noise</a> as well.</p>

<figure class="two-col">
<img src="imgs/chapter05/ch05_exc03a.png" alt="sine wave"/>
<figcaption/>
</figure>
<figure class="two-col">
<img src="imgs/chapter05/ch05_exc03b.png" alt="Perlin noise"/>
<figcaption/>
</figure>
<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>
</section>


</section>







<section data-type="sect1" id="chapter05_section10">
<h1>5.10  Complex Forms</h1>
<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""complex forms in"">&nbsp;</a></p>

<figure id="chapter05_figure5" class="half-width-right">
<img src="imgs/chapter05/ch05_05.png" alt="Figure 5.5"/>
<figcaption/>
</figure>
<p>Now that we’ve seen how easy it is to make simple geometric forms in Box2D, let’s imagine that you want to have a more complex form, such as a little alien stick figure.</p>

<p>There are two strategies in Box2D for making forms that are more advanced than a basic circle or square.   One is to use a <strong klass>PolygonShape</strong> in a different way.  In our previous examples, we used <strong klass>PolygonShape</strong> to generate a rectangular shape with the <strong function>setAsBox()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">  PolygonShape ps = new PolygonShape();
  ps.setAsBox(box2dW, box2dH);</pre>

<p><a data-type="indexterm" data-primary=""PolygonShape class"" data-secondary=""as list of vectors"">&nbsp;</a></p>

<p>This was a good way to start because of the inherent simplicity of working with rectangles.  However, a <strong klass>PolygonShape</strong> object can also be generated from an array of vectors, which allows you to build a completely custom shape as a series of connected vertices.  This works very similarly to the <strong klass>ChainShape</strong> class.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex05.png" alt="ch05 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 5.4: Polygon shapes</strong></p>

<pre data-type="programlisting" data-code-language="java">Vec2[] vertices = new Vec2[4];	// An array of 4 vectors
vertices[0] = box2d.vectorPixelsToWorld(new Vec2(-15, 25));
vertices[1] = box2d.vectorPixelsToWorld(new Vec2(15, 0));
vertices[2] = box2d.vectorPixelsToWorld(new Vec2(20, -15));
vertices[3] = box2d.vectorPixelsToWorld(new Vec2(-10, -10));

//[full] Making a polygon from that array
PolygonShape ps = new PolygonShape();
ps.set(vertices, vertices.length);
//[end]</pre>

<p>When building your own polygon in Box2D, you must remember two important details.</p>

<figure id="chapter05_figure6" class="half-width-left">
<img src="imgs/chapter05/ch05_06.png" alt="Figure 5.6"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""order of vertices"">&nbsp;</a></p>

<ol>
<li>
<p><strong>Order of vertices!</strong>  If you are thinking in terms of pixels (as above) the vertices should be defined in counterclockwise order.  (When they are translated to Box2D World vectors, they will actually be in clockwise order since the vertical axis is flipped.)</p></li>
<li>
<p><strong>Convex shapes only!</strong>  A concave shape is one where the surface curves inward. Convex is the opposite (see illustration below).  Note how in a convex shape every internal angle must be 180 degrees or less.  Box2D is not capable of handling collisions for concave shapes.  If you need a concave shape, you will have to build one out of multiple convex shapes (more about that in a moment).</p></li>
</ol>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""concave shapes and"">&nbsp;</a></p>

<figure id="chapter05_figure7">
<img src="imgs/chapter05/ch05_07.png" alt="Figure 5.7: A concave shape can be drawn with multiple convex shapes."/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""beginShape() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""endShape() function (Processing)"">&nbsp;</a></p>

<p>Now, when it comes time to display the shape in Processing, we can no longer just use <strong function>rect()</strong> or <strong function>ellipse()</strong>.  Since the shape is built out of custom vertices, we’ll want to use Processing’s <strong function>beginShape()</strong>, <strong function>endShape()</strong>, and <strong function>vertex()</strong> functions.   As we saw with the <strong klass>ChainShape</strong>, we could choose to store the pixel locations of the vertices in our own <strong klass>ArrayList</strong> for drawing.  However, it’s also useful to see how we can ask Box2D to report back to use the vertex locations.</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    // First we get the Fixture attached to the body...
    Fixture f = body.getFixtureList();
    // ...then the Shape attached to the Fixture.
    PolygonShape ps = (PolygonShape) f.getShape();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    beginShape();
    //[offset-up] We can loop through that array and convert each vertex from Box2D space to pixels.
    for (int i = 0; i &lt; ps.getVertexCount(); i++) {
      Vec2 v = box2d.vectorWorldToPixels(ps.getVertex(i));
      vertex(v.x,v.y);
    }
    endShape(CLOSE);
    popMatrix();
  }</pre>

<div id="chapter05_exercise4" data-type="example">
<h5>Exercise 5.4</h5>
<p>Using the <strong klass>PolygonShape</strong> class, create your own polygon design (remember, it must be convex).  Some possibilities below.</p>

<figure>
<img src="imgs/chapter05/ch05_exc04.png" alt="ch05 exc04"/>
<figcaption/>
</figure></div>

<p><a data-type="indexterm" data-primary=""body (Box2D element)"" data-secondary=""multiple shapes and"">&nbsp;</a></p>

<p>A polygon shape will get us pretty far in Box2D.  Nevertheless, the convex shape requirement will severely limit the range of possibilities.  The good news is that we can completely eliminate this restriction by creating a single Box2D body out of multiple shapes!  Let’s return to our little alien creature and simplify the shape to be a thin rectangle with a circle on top.</p>

<p>How can we build a single body with two shapes?  Let’s first review how we built a single body with one shape.</p>

<p><em>Step 1:  Define the body.</em><br/>
<em>Step 2: Create the body.</em><br/>
<strong><em>Step 3: Define the shape.</em></strong><br/>
<strong><em>Step 4: Attach the shape to the body.</em></strong><br/>
<em>Step 5: Finalize the body’s mass.</em></p>

<p>Attaching more than one shape to a body is as simple as repeating steps 3 and 4 over and over again.</p>

<p><strong><em>Step 3a: Define shape 1.</em></strong><br/>
<strong><em>Step 4a: Attach shape 1 to the body.</em></strong><br/>
<strong><em>Step 3b: Define shape 2.</em></strong><br/>
<strong><em>Step 4b: Attach shape 2 to the body.</em></strong><br/>
etc. etc. etc.<br/></p>

<p>Let’s see what this would look like with actual Box2D code.</p>

<pre data-type="programlisting" data-code-language="java">//[full] Making the body
BodyDef bd = new BodyDef();
bd.type = BodyType.DYNAMIC;
bd.position.set(box2d.coordPixelsToWorld(center));
body = box2d.createBody(bd);
//[end]

//[full] Making shape 1 (the rectangle)
PolygonShape ps = new PolygonShape();
float box2dW = box2d.scalarPixelsToWorld(w/2);
float box2dH = box2d.scalarPixelsToWorld(h/2);
sd.setAsBox(box2dW, box2dH);
//[end]

//[full] Making shape 2 (the circle)
CircleShape cs = new CircleShape();
cs.m_radius = box2d.scalarPixelsToWorld(r);
//[end]

//[full] Attach both shapes with a fixture.
body.createFixture(ps,1.0);
body.createFixture(cs, 1.0);
//[end]</pre>

<p>The above looks pretty good, but sadly, if we run it, we’ll get the following result:</p>

<figure id="chapter05_figure8">
<img src="imgs/chapter05/ch05_08.png" alt="Figure 5.8"/>
<figcaption/>
</figure>
<p>When you attach a shape to a body, by default, the center of the shape will be located at the center of the body.  But in our case, if we take the center of the rectangle to be the center of the body, we want the center of the circle to be offset along the y-axis from the body’s center.</p>

<figure id="chapter05_figure9">
<img src="imgs/chapter05/ch05_09.png" alt="Figure 5.9"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""m_p variable (Vec2 class)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Shape (Box2D element)"" data-secondary=""local position for"">&nbsp;</a></p>

<p>This is achieved by using the local position of a shape, accessed via a <strong klass>Vec2</strong> variable called <strong var>m_p</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// Our offset in pixels
Vec2 offset = new Vec2(0,-h/2);
// Converting the vector to Box2D world
offset = box2d.vectorPixelsToWorld(offset);
// Setting the local position of the circle
circle.m_p.set(offset.x,offset.y);</pre>

<p>Then, when we go to draw the body, we use both <strong function>rect()</strong> and <strong function>ellipse()</strong> with the circle offset the same way.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex06.png" alt="ch05 ex06"/>
<figcaption/>
</figure>
<p><strong example>Example 5.5: Multiple shapes on one body</strong></p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    // First the rectangle at (0,0)
    rect(0,0,w,h);
    // Then the ellipse offset at (0,-h/2)
    ellipse(0,-h/2,r*2,r*2);
    popMatrix();
  }</pre>

<p>Finishing off this section, I want to stress the following: the stuff you draw in your Processing window doesn’t magically experience physics simply because we created some Box2D bodies and shapes.  These examples work because we very carefully matched how we draw our elements with how we defined the bodies and shapes we put into the Box2D world.   If you accidentally draw your shape differently, you won’t get an error, not from Processing or from Box2D.  However, your sketch will look odd and the physics won’t work correctly.  For example, what if we had written:</p>

<pre data-type="programlisting" data-code-language="java">Vec2 offset = new Vec2(0,-h/2);</pre>

<p>when we created the shape, but:</p>

<pre data-type="programlisting" data-code-language="java">ellipse(0,h/2,r*2,r*2);</pre>

<p>when it came time to display the shape?</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex07.png" alt="ch05 ex07"/>
<figcaption/>
</figure>
<p>The results would look like the image above, where clearly, the collisions are not functioning as expected.  This is not because the physics is broken; it’s because we did not communicate properly with Box2D, either when we put stuff in the magic world or queried the world for locations.</p>

<div id="chapter05_exercise5" data-type="example">
<h5>Exercise 5.5</h5>
<p>Make your own little alien being using multiple shapes attached to a single body.  Try using more than one polygon to make a concave shape.   Remember, you aren’t limited to using the shape drawing functions in Processing; you can use images, colors, add hair with lines, etc.  Think of the Box2D shapes only as skeletons for your creative and fantastical design!</p>
</div>
</section>







<section data-type="sect1" id="chapter05_section11">
<h1>5.11 Feeling Attached—Box2D Joints</h1>
<p><a data-type="indexterm" data-primary=""joint (Box2D element)"">&nbsp;</a></p>

<figure id="chapter05_figure10" class="half-width-right">
<img src="imgs/chapter05/ch05_10.png" alt="Figure 5.10"/>
<figcaption/>
</figure>
<p>Box2D joints allow you to connect one body to another, enabling more advanced simulations of swinging pendulums, elastic bridges, squishy characters, wheels spinning on an axle, etc.  There are many different kinds of Box2D joints. In this chapter we’re going to look at three: distance joints, revolute joints, and “mouse” joints.</p>

<p><a data-type="indexterm" data-primary=""distance joints"">&nbsp;</a>
<a data-type="indexterm" data-primary=""joint (Box2D element)"" data-secondary=""distance"">&nbsp;</a></p>

<p>Let’s begin with a distance joint, a joint that connects two bodies with a fixed length.  The joint is attached to each body at a specified anchor point (a point relative to the body’s center).  For any Box2D joint, we need to follow these steps.  This, of course, is similar to the methodology we used to build bodies and shapes, with some quirks.</p>

<p><strong><em>Step 1. Make sure you have two bodies ready to go.</em></strong><br/>
<strong><em>Step 2. Define the joint.</em></strong><br/>
<strong><em>Step 3. Configure the joint’s properties (What are the bodies? Where are the anchors? What is its rest length? Is it elastic or rigid?)</em></strong><br/>
<strong><em>Step 4. Create the joint.</em></strong><br/></p>

<p>Let’s assume we have two <strong klass>Particle</strong> objects that each store a reference to a Box2D <strong klass>Body</strong> object.  We’ll call them particles <strong var>p1</strong> and <strong var>p2</strong>.</p>

<pre data-type="programlisting" data-code-language="java">Particle p1 = new Particle();
Particle p2 = new Particle();</pre>

<p><a data-type="indexterm" data-primary=""DistanceJointDef (Box2D joint type)"">&nbsp;</a></p>

<p>OK, onto Step 2.  Let’s define the joint.</p>

<pre data-type="programlisting" data-code-language="java">DistanceJointDef djd = new DistanceJointDef();</pre>

<p>Easy, right?  Now it’s time to configure the joint.   First we tell the joint which two bodies it connects:</p>

<pre data-type="programlisting" data-code-language="java">djd.bodyA = p1.body;
djd.bodyB = p2.body;</pre>

<p><a data-type="indexterm" data-primary=""rest length (Box2D joint element)"">&nbsp;</a></p>

<p>Then we set up a rest length.  Remember, if our rest length is in pixels, we need to convert it!</p>

<pre data-type="programlisting" data-code-language="java">djd.length = box2d.scalarPixelsToWorld(10);</pre>

<p><a data-type="indexterm" data-primary=""dampingRatio setting (Box2D joint element)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""frequencyHz setting (Box2D joint element)"">&nbsp;</a></p>

<p>A distance joint also includes two optional settings that can make the joint soft, like a spring connection: <strong var>frequencyHz</strong> and <strong var>dampingRatio</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  // Measured in Hz, like the frequency of harmonic
  // oscillation; try values between 1 and 5.
  djd.frequencyHz  = ___;
  // Dampens the spring; typically a number between 0 and 1.
  djd.dampingRatio = ___;</pre>

<p>Finally, we create the joint.</p>

<pre data-type="programlisting" data-code-language="java">DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);</pre>

<p>Box2D won’t keep track of what kind of joint we are making, so we have to cast it as a <strong klass>DistanceJoint</strong> upon creation.</p>

<p>We can create Box2D joints anywhere in our Processing sketch.  Here’s an example of how we might write a class to describe two Box2D bodies connected with a single joint.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex08.png" alt="ch05 ex08"/>
<figcaption/>
</figure>
<p><strong example>Example 5.6: DistanceJoint</strong></p>

<pre data-type="programlisting" data-code-language="java">class Pair {

  //[full] Two objects that each have a Box2D body
  Particle p1;
  Particle p2;
  //[end]
  // Arbitrary rest length
  float len = 32;

  Pair(float x, float y) {

    //[full]
    // Problems can result if the bodies are initialized at the same location.

    p1 = new Particle(x,y);
    p2 = new Particle(x+random(-1,1),y+random(-1,1));
    //[end]

    // Making the joint!
    DistanceJointDef djd = new DistanceJointDef();
    djd.bodyA = p1.body;
    djd.bodyB = p2.body;
    djd.length = box2d.scalarPixelsToWorld(len);
    djd.frequencyHz = 0;  // Try a value less than 5
    djd.dampingRatio = 0; // Ranges between 0 and 1

    //[offset-down] Make the joint.  Note that we aren't storing a reference to the joint anywhere! We might need to someday, but for now it's OK.
    DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);
  }

  void display() {
    Vec2 pos1 = box2d.getBodyPixelCoord(p1.body);
    Vec2 pos2 = box2d.getBodyPixelCoord(p2.body);
    stroke(0);
    line(pos1.x,pos1.y,pos2.x,pos2.y);

    p1.display();
    p2.display();
  }
}</pre>

<div id="chapter05_exercise6" data-type="example">
<h5>Exercise 5.6</h5>
<p>Create a simulation of a bridge by using distance joints to connect a sequence of circles (or rectangles) as illustrated to the right.  Assign a density of zero to lock the endpoints in place.  Experiment with different values to make the bridge more or less “springy.”   It should also be noted that the joints themselves have no physical geometry, so in order for your bridge not to have holes, spacing between the nodes will be important.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_exc06.png" alt="ch05 exc06"/>
<figcaption/>
</figure></div>

<figure id="chapter05_figure11" class="half-width-right">
<img src="imgs/chapter05/ch05_11.png" alt="Figure 5.11"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""joint (Box2D element)"" data-secondary=""revolute type"">&nbsp;</a>
<a data-type="indexterm" data-primary=""revolute joint type (Box2D)"">&nbsp;</a></p>

<p>Another joint you can create in Box2D is a <em>revolute joint</em>. A revolute joint connects two Box2D bodies at a common anchor point, which can also be referred to as a “hinge.”   The joint has an “angle” that describes the relative rotation of each body.   To use a revolute joint, we follow the same steps we did with the distance joint.</p>





<section data-type="sect2" id="_step_1_make_sure_you_have_two_bodies_ready_to_go">
<h2>Step 1: Make sure you have two bodies ready to go.</h2>
<p>Let’s assume we have two <strong klass>Box</strong> objects, each of which stores a reference to a Box2D body.</p>

<pre data-type="programlisting" data-code-language="java">Box box1 = new Box();
Box box2 = new Box();</pre>
</section>







<section data-type="sect2" id="_step_2_define_the_joint">
<h2>Step 2: Define the joint.</h2>
<p><a data-type="indexterm" data-primary=""RevoluteJointDef object (Box2D joint element)"">&nbsp;</a></p>

<p>Now we want a <strong klass>RevoluteJointDef</strong> object.</p>

<pre data-type="programlisting" data-code-language="java">RevoluteJointDef rjd = new RevoluteJointDef();</pre>
</section>







<section data-type="sect2" id="_step_3_configure_the_joint_s_properties">
<h2>Step 3: Configure the joint’s properties.</h2>
<p><a data-type="indexterm" data-primary=""revolute joint type (Box2D)"" data-secondary=""properties" data-tertiary="configuring"">&nbsp;</a></p>

<p>The most important properties of a revolute joint are the two bodies it connects as well as their mutual anchor point (i.e. where they are connected).   They are set with the function <strong function>initialize()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());</pre>

<p>Notice how the first two arguments specify the bodies and the second point specifies the anchor, which in this case is located at the center of the first body.</p>

<p>An exciting feature of a <strong klass>RevoluteJoint</strong> object is that you can motorize it so it spins autonomously.  For example:</p>

<pre data-type="programlisting" data-code-language="java">// Turn on the motor.
rjd.enableMotor = true;
 // How fast is the motor?
rjd.motorSpeed = PI*2;
// How powerful is the motor?
rjd.maxMotorTorque = 1000.0;</pre>

<p>The motor can be enabled and disabled while the program is running.</p>

<p>Finally, the ability for a revolute joint to spin can be constrained between two angles. (By default, it can rotate a full 360 degrees, or <strong var>TWO_PI</strong> radians.)</p>

<pre data-type="programlisting" data-code-language="java">rjd.enableLimit = true;
rjd.lowerAngle = -PI/8;
rjd.upperAngle = PI/8;</pre>
</section>







<section data-type="sect2" id="_step_4_create_the_joint">
<h2>Step 4: Create the joint.</h2>
<pre data-type="programlisting" data-code-language="java">RevoluteJoint joint = (RevoluteJoint) box2d.world.createJoint(rjd);</pre>

<p>Let’s take a look at all of these steps together in a class called <strong klass>Windmill</strong>, which connects two boxes with a revolute joint.  In this case, <strong var>box1</strong> has a density of zero, so only <strong var>box2</strong> spins around a fixed point.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex09.png" alt="ch05 ex09"/>
<figcaption/>
</figure>
<p><strong example>Example 5.7: Spinning Windmill</strong></p>

<pre data-type="programlisting" data-code-language="java">class Windmill {

  // Our “Windmill” is two boxes and one joint.
  RevoluteJoint joint;
  Box box1;
  Box box2;

  Windmill(float x, float y) {

    //[full] In this example, the Box class expects a boolean argument that will be used to determine if the Box is fixed or not.  See website for the Box class code.
    box1 = new Box(x,y,120,10,false);
    box2 = new Box(x,y,10,40,true);


    //[end]

    RevoluteJointDef rjd = new RevoluteJointDef();
    //[offset-down] The joint connects two bodies and is anchored at the center of the first body.
    rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());



    // A motor!
    rjd.motorSpeed = PI*2;
    rjd.maxMotorTorque = 1000.0;
    rjd.enableMotor = true;

    //[offset-down] Create the Joint.
    joint = (RevoluteJoint) box2d.world.createJoint(rjd);
  }

  //[full] Turning the motor on or off
  void toggleMotor() {
    boolean motorstatus = joint.isMotorEnabled();
    joint.enableMotor(!motorstatus);
  }
  //[end]

  void display() {
    box1.display();
    box2.display();
  }
}</pre>

<div id="chapter05_exercise7" data-type="example">
<h5>Exercise 5.7</h5>
<figure class="half-width-right">
<img src="imgs/chapter05/ch05_exc07.png" alt="ch05 exc07"/>
<figcaption/>
</figure>
<p>Use a revolute joint for the wheels of a car.  Use motors so that the car drives autonomously.  Try using a chain shape for the road’s surface.</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<p><a data-type="indexterm" data-primary=""joint (Box2D element)"" data-secondary=""mouse type"">&nbsp;</a>
<a data-type="indexterm" data-primary=""mouse joint (Box2D Joint type)"">&nbsp;</a></p>

<p>The last joint we’ll look at is a mouse joint.  A mouse joint is typically used for moving a body with the mouse.  However, it can also be used to drag an object around the screen according to some arbitrary <em>x</em> and <em>y</em>.   The joint functions by pulling the body towards a “target” position.</p>

<p><a data-type="indexterm" data-primary=""mouse joint (Box2D joint type)"" data-secondary=""setTransform() function"">&nbsp;</a>
<a data-type="indexterm" data-primary=""setTransform() function (Box2D)"">&nbsp;</a></p>

<p>Before we look at the <strong klass>MouseJoint</strong> object itself, let’s ask ourselves why we even need it in the first place.  If you look at the Box2D documentation, there is a function called <strong function>setTransform()</strong> that specifically “sets the position of the body&#8217;s origin and rotation (radians).”  If a body has a position, can’t we just assign the body’s position to the mouse?</p>

<pre data-type="programlisting" data-code-language="java">Vec2 mouse = box2d.screenToWorld(x,y);
body.setTransform(mouse,0);</pre>

<p>While this will in fact move the body, it will also have the unfortunate result of breaking the physics.  Let’s imagine you built a teleportation machine that allows you to teleport from your bedroom to your kitchen (good for late-night snacking).   Now, go ahead and rewrite Newton’s laws of motion to account for the possibility of teleportation.  Not so easy, right?  Box2D has the same problem.  If you manually assign the location of an body, it’s like saying “teleport that body” and Box2D no longer knows how to compute the physics properly.  However, Box2D does allow you to tie a rope to yourself and get a friend of yours to stand in the kitchen and drag you there.  This is what the <strong klass>MouseJoint</strong> does. It’s like a string you attach to a body and pull towards a target.</p>

<p>Let’s look at making this joint, assuming we have a <strong klass>Box</strong> object called <strong var>box</strong>.  This code will look identical to our distance joint with one small difference.</p>

<pre data-type="programlisting" data-code-language="java">// Just like before, define the Joint.
MouseJointDef md = new MouseJointDef();

// Whoa, this is new!
md.bodyA = box2d.getGroundBody(); //[bold]
// Attach the Box body.
md.bodyB = box.body;

// Set properties.
md.maxForce = 5000.0;
md.frequencyHz = 5.0;
md.dampingRatio = 0.9;

// Create the joint.
MouseJoint mouseJoint = (MouseJoint) box2d.world.createJoint(md);.</pre>

<p><a data-type="indexterm" data-primary=""getGroundBody() function (Box2D joint element)"">&nbsp;</a></p>

<p>So, what’s this line of code all about?</p>

<pre data-type="programlisting" data-code-language="java">md.bodyA = box2d.getGroundBody(); //[bold]</pre>

<p>Well, as we’ve stated, a joint is a connection between <em>two</em> bodies.  With a mouse joint, we’re saying that the second body is, well, the ground.  Hmm.  What the heck is the <em>ground</em> in Box2D?   One way to imagine it is to think of the screen as the ground.  What we’re doing is making a joint that connects a rectangle drawn on the window with the Processing window itself.  And the point in the window to which the connection is tied is a moving target.</p>

<p>Once we have a mouse joint, we’ll want to update the target location continually while the sketch is running.</p>

<pre data-type="programlisting" data-code-language="java">Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);
mouseJoint.setTarget(mouseWorld);</pre>

<p>To make this work in an actual Processing sketch, we’ll want to have the following:</p>

<ol>
<li>
<p><strong><em>Box class</em></strong><code>—</code>An object that references a Box2D body.</p></li>
<li>
<p><strong><em>Spring class</em></strong><code>—</code>An object that manages the mouse joint that drags the <strong klass>Box</strong> object around.</p></li>
<li>
<p><strong><em>Main tab</em></strong><code>—</code>Whenever <strong function>mousePressed()</strong> is called, the mouse joint is created; whenever <strong function>mouseReleased()</strong> is called, the mouse joint is destroyed.  This allows us to interact with a body only when the mouse is pressed.</p></li>
</ol>

<p>Let’s take a look at the main tab.  You can find the rest of the code for the <strong klass>Box</strong> and <strong klass>Spring</strong> classes via the book website.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex10.png" alt="ch05 ex10"/>
<figcaption/>
</figure>
<p><strong example>Example 5.8: MouseJoint demonstration</strong></p>

<pre data-type="programlisting" data-code-language="java">PBox2D box2d;

// One Box
Box box;
// Object to manage MouseJoint
Spring spring;

void setup() {
  size(400,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  box = new Box(width/2,height/2);
  // The MouseJoint is really null until we click the mouse.
  spring = new Spring();
}

void mousePressed() {
  // Was the mouse clicked inside the Box?
  if (box.contains(mouseX, mouseY)) {
    // If so, attach the MouseJoint.
    spring.bind(mouseX,mouseY,box);
  }
}

void mouseReleased() {
  // When the mouse is released, we’re done with the MouseJoint.
  spring.destroy();
}

void draw() {
  background(255);

  box2d.step();

  // We must always update the MouseJoint’s target.
  spring.update(mouseX,mouseY);

  box.display();
  spring.display();
}</pre>

<div id="chapter05_exercise8" data-type="example">
<h5>Exercise 5.8</h5>
<p>Use a mouse joint to move a Box2D body around the screen according to an algorithm or input other than the mouse.  For example, assign it a location according to Perlin noise or key presses.  Or build your own controller using an <a href="http://www.arduino.cc/">Arduino</a>.</p>
</div>

<p><a data-type="indexterm" data-primary=""kinematic (body type)"" data-secondary=""MouseJoints and"">&nbsp;</a></p>

<p>It’s worth noting that while the technique for dragging an object around using a <strong klass>MouseJoint</strong> is useful, Box2D also allows a body to have a <strong var>KINEMATIC</strong> type.</p>

<pre data-type="programlisting" data-code-language="java">BodyDef bd = new BodyDef();
// Setting the body type to Kinematic
bd.type = BodyType.KINEMATIC;</pre>

<figure id="chapter05_figure12" class="half-width-right">
<img src="imgs/chapter05/ch05_12.png" alt="Figure 5.12"/>
<figcaption/>
</figure>
<p>Kinematic bodies can be controlled by the user by setting their velocity directly.    For example, let’s say you want an object to follow a target (like your mouse).  You could create a vector that points from a body’s location to a target.</p>

<pre data-type="programlisting" data-code-language="java">Vec2 pos = body.getWorldCenter();
Vec2 target = box2d.coordPixelsToWorld(mouseX,mouseY);
// A vector pointing from the body position to the Mouse
Vec2 v = target.sub(pos);</pre>

<p>Once you have that vector, you could assign it to the body’s velocity so that it moves to the target.</p>

<pre data-type="programlisting" data-code-language="java">// Assigning a body’s velocity directly, overriding physics!
body.setLinearVelocity(v);</pre>

<p>You can also do the same with angular velocity (or leave it alone and allow the physics to take over).</p>

<p>It is important to note that kinematic bodies do not collide with other kinematic or static bodies.    In these cases, the mouse joint strategy is preferable.</p>

<div id="chapter05_exercise9" data-type="example">
<h5>Exercise 5.9</h5>
<p>Redo Exercise 5.8, but use a kinematic body instead.</p>
</div>
</section>


</section>







<section data-type="sect1" id="chapter05_section12">
<h1>5.12 Bringing It All Back Home to Forces</h1>
<p>In Chapter 2, we spent a lot of time thinking about building environments with multiple forces.  An object might respond to gravitational attraction, wind, air resistance, etc.  Clearly there are forces at work in Box2D as we watch rectangles and circles spin and fly around the screen.  But so far, we’ve only had the ability to manipulate a single global force—gravity.</p>

<pre data-type="programlisting" data-code-language="java">  box2d = new PBox2D(this);
  box2d.createWorld();
  // Setting the global gravity force
  box2d.setGravity(0, -20);</pre>

<p><a data-type="indexterm" data-primary=""applyForce() function (Box2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""forces"" data-secondary=""applyForce() function"">&nbsp;</a></p>

<p>If we want to use any of our Chapter 2 techniques with Box2D, we need look no further than our trusty <strong function>applyForce()</strong> function.   In our <strong klass>Mover</strong> class we wrote a function called <strong function>applyForce()</strong>, which received a vector, divided it by mass, and accumulated it into the mover&#8217;s acceleration.  With Box2D, the same function exists, but we don’t need to write it ourselves.  Instead, we can call the Box2D body’s <strong function>applyForce()</strong> function!</p>

<pre data-type="programlisting" data-code-language="java">class Box {
  Body body;

  void applyForce(Vec2 force) {
    Vec2 pos = body.getWorldCenter();
    // Calling the Body's applyForce() function
    body.applyForce(force, pos);
  }
}</pre>

<p>Here we are receiving a force vector and passing it along to the Box2D <strong klass>Body</strong> object.  The key difference is that Box2D is a more sophisticated engine than our examples from Chapter 2.   Our earlier forces examples assumed that the force was always applied at the mover&#8217;s center.  Here we get to specify exactly where on the body the force is applied.  In the above code, we’re just applying it to the center by asking the body for its center, but this could be adjusted.</p>

<p>Let’s say we wanted to use a gravitational attraction force.  Remember the code we wrote back in Chapter 2 in our <strong klass>Attractor</strong> class?</p>

<pre data-type="programlisting" data-code-language="java">PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  distance = constrain(distance,5.0,25.0);
  force.normalize();
  float strength = (g * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}</pre>

<p>We can rewrite the exact same function using <strong klass>Vec2</strong> instead and use it in a Box2D example.  Note how for our force calculation we can stay completely within the Box2D coordinate system and never think about pixels.</p>

<pre data-type="programlisting" data-code-language="java">Vec2 attract(Mover m) {
  // We have to ask Box2D for the locations first!
  Vec2 pos = body.getWorldCenter();
  Vec2 moverPos = m.body.getWorldCenter();
  Vec2 force = pos.sub(moverPos);
  float distance = force.length();
  distance = constrain(distance,1,5);
  force.normalize();
  float strength = (G * 1 * m.body.m_mass) / (distance * distance);
  // Remember, it’s mulLocal() for Vec2.
  force.mulLocal(strength);
  return force;
}</pre>

<div id="chapter05_exercise10" data-type="example">
<h5>Exercise 5.10</h5>
<p>Take any example you made previously using a force calculation and bring that force calculation into Box2D.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_exc10.png" alt="ch05 exc10"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter05_section13">
<h1>5.13 Collision Events</h1>
<p><a data-type="indexterm" data-primary=""collisions"" data-secondary=""Box2D and"">&nbsp;</a></p>

<p>Now we’ve seen a survey of what can be done with Box2D.   Since this book is not called “The Nature of Box2D,” it’s not my intention to cover every single possible feature of the Box2D engine.  But hopefully by looking at the basics of building bodies, shapes, and joints, when it comes time to use an aspect of Box2D that we haven’t covered, the skills we’ve gained here will make that process considerably less painful.  There is one more feature of Box2D, however, that I do think is worth covering.</p>

<p>Let’s ask a question you’ve likely been wondering about:</p>

<p><em>What if I want something to happen when two Box2D bodies collide?   I mean, don’t get me wrong—I’m thrilled that Box2D is handling all of the collisions for me. But if it takes care of everything for me, how am I supposed to know when things are happening?</em></p>

<p>Your first thoughts when considering an event during which two objects collide might be as follows:  Well, if I know all the bodies in the system, and I know where they are all located, then I can just start comparing the locations, see which ones are intersecting, and determine that they’ve collided.  That’s a nice thought, but hello??!?  The whole point of using Box2D is that Box2D will take care of that for us.  If we are going to do the geometry to test for intersection ourselves, then all we’re doing is re-implementing Box2D.</p>

<p><a data-type="indexterm" data-primary=""ContactListener class (JBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""interfaces"">&nbsp;</a>
<a data-type="indexterm" data-primary=""JBox2D"" data-secondary=""ContactListener class"">&nbsp;</a></p>

<p>Of course, Box2D has thought of this problem before.  It’s a pretty common one.  After all, if you intend to make a bajillion dollars selling some game called Angry Birds, you better well make something happen when an ill-tempered pigeon smashes into a cardboard box.   Box2D alerts you to moments of collision with something called an “interface.”  It’s worth learning about interfaces, an advanced feature of object-oriented programming. You can take a look at the <a href="http://download.oracle.com/javase/tutorial/java/concepts/interface.html">Java Interface Tutorial</a> as well as the JBox2D <strong klass>ContactListener</strong> class. (I have also included an example on the website that demonstrates using the interface directly.)</p>

<p><a data-type="indexterm" data-primary=""beginContact() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""collisions"" data-secondary=""beginContact() function (PBox2D)"">&nbsp;</a></p>

<p>If you are using PBox2D, as we are here, you don’t need to implement your own interface.  Detecting collision events is done through a callback function.  Much like <strong function>mousePressed()</strong> is triggered when the mouse is pressed, <strong function>beginContact()</strong> is triggered when two shapes collide.</p>

<pre data-type="programlisting" data-code-language="java">// The mousePressed event with which we are comfortable.
void mousePressed() {
  println("The mouse was pressed!");
}

// What our "beginContact" event looks like.
void beginContact(Contact cp) {
  println("Something collided in the Box2D World!");
}</pre>

<p>Before the above will work, you must first let PBox2D know you intend to listen for collisions. (This allows the library to reduce overhead by default; it won’t bother listening if it doesn’t have to.)</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  box2d = new PBox2D(this);
  box2d.createWorld();
  // Add this line if you want to listen for collisions.
  box2d.listenForCollisions();
}</pre>

<p>There are four collision event callbacks.</p>

<p><a data-type="indexterm" data-primary=""endContact() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""postSolve() function (PBox2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""preSolve() function (PBox2D)"">&nbsp;</a></p>

<ol>
<li>
<p><strong function>beginContact()</strong> —Triggered whenever two shapes first come into contact with each other.</p></li>
<li>
<p><strong function>endContact()</strong> —Triggered over and over again as long as shapes continue to be in contact.</p></li>
<li>
<p><strong function>preSolve()</strong> —Triggered before Box2D solves the outcome of the collision, i.e. before <strong function>beginContact()</strong>.  It can be used to disable a collision if necessary.</p></li>
<li>
<p><strong function>postSolve()</strong> —Triggered after the outcome of the collision is solved. It allows you to gather information about that “solution” (known as an “impulse”).</p></li>
</ol>

<p>The details behind <strong function>preSolve()</strong> and <strong function>postSolve()</strong> are beyond the scope of this book; however, we are going to take a close look at <strong function>beginContact()</strong>, which will cover the majority of conventional cases in which you want to trigger an action when a collision occurs.  <strong function>endContact()</strong> works identically to <strong function>beginContact()</strong>, the only difference being that it occurs the moment bodies separate.</p>

<p><strong function>beginContact()</strong> is written as follows:</p>

<pre data-type="programlisting" data-code-language="java">void beginContact(Contact cp) {

}</pre>

<p><a data-type="indexterm" data-primary=""Contact objects (PBox2D)"">&nbsp;</a></p>

<p>Notice that the function above includes an argument of type <strong klass>Contact</strong>.  A <strong klass>Contact</strong> object includes all the data associated with a collision—the geometry and the forces.  Let’s say we have a Processing sketch with <strong klass>Particle</strong> objects that store a reference to a Box2D body.    Here is the process we are going to follow.</p>





<section data-type="sect2" id="_step_1_contact_could_you_tell_me_what_two_things_collided">
<h2>Step 1: Contact, could you tell me what two things collided?</h2>
<p>Now, what has collided here?  Is it the bodies?  The shapes? The fixtures?   Box2D detects collisions between shapes; after all, these are the entities that have geometry.  However, because shapes are attached to bodies with fixtures, what we really want to ask Box2D is: “Could you tell me which two fixtures collided?”</p>

<pre data-type="programlisting" data-code-language="java">//[full] The contact stores the fixtures as A and B.
Fixture f1 = cp.getFixtureA();
Fixture f2 = cp.getFixtureB();
//[end]</pre>
</section>







<section data-type="sect2" id="_step_2_fixtures_could_you_tell_me_which_body_you_are_attached_to">
<h2>Step 2: Fixtures, could you tell me which body you are attached to?</h2>
<pre data-type="programlisting" data-code-language="java">//[full] getBody() gives us the body to which the Fixture is attached.
Body b1 = f1.getBody();
Body b2 = f2.getBody();
//[end]</pre>
</section>







<section data-type="sect2" id="_step_3_bodies_could_you_tell_me_which_particles_you_are_associated_with">
<h2>Step 3: Bodies, could you tell me which Particles you are associated with?</h2>
<p>OK, this is the harder part.  After all, Box2D doesn’t know anything about our code.  Sure, it is doing all sorts of stuff to keep track of the relationships between shapes and bodies and joints, but it’s up to us to manage our own objects and their associations with Box2D elements.   Luckily for us, Box2D provides a function that allows us to attach our Processing object (a <strong klass>Particle</strong>) to a Box2D body via the <strong function>setUserData()</strong> and <strong function>getUserData()</strong> methods.</p>

<p>Let’s take a look at the constructor in our <strong klass>Particle</strong> class where the body is made.   We are expanding our body-making procedure by one line of code, noted below.</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  Body body;

  Particle(float x, float y, float r) {
    BodyDef bd = new BodyDef();
    bd.position = box2d.coordPixelsToWorld(x, y);
    bd.type = BodyType.DYNAMIC;
    body = box2d.createBody(bd);
    CircleShape cs = new CircleShape();
    cs.m_radius = box2d.scalarPixelsToWorld(r);
    body.createFixture(fd,1);

    // "this" refers to this Particle object.
    // We are telling the Box2D Body to store a
    // reference to this Particle that we can
    // access later.
    body.setUserData(this);  //[bold]
  }</pre>

<p>Later, in our <strong function>addContact()</strong> function, once we know the body, we can access the <strong klass>Particle</strong> object with <strong function>getUserData()</strong>.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex11.png" alt="ch05 ex11"/>
<figcaption/>
</figure>
<p><strong example>Example 5.9: CollisionListening</strong></p>

<pre data-type="programlisting" data-code-language="java">void beginContact(Contact cp) {

  Fixture f1 = cp.getFixtureA();
  Fixture f2 = cp.getFixtureB();

  Body b1 = f1.getBody();
  Body b2 = f2.getBody();

  //[full] When we pull the “user data” object out of the Body object, we have to remind our program that it is a Particle object.  Box2D doesn’t know this.
  Particle p1 = (Particle) b1.getUserData();
  Particle p2 = (Particle) b2.getUserData();


  //[end]
  //[full] Once we have the particles, we can do anything to them.  Here we
  // just call a function that changes their color.
  p1.change();
  p2.change();

  //[end]
}</pre>

<p>Now, in many cases, we cannot assume that the objects that collided are all <strong klass>Particle</strong> objects.  We might have a sketch with <strong klass>Boundary</strong> objects, <strong klass>Particle</strong> objects, <strong klass>Box</strong> objects, etc.  So often we will have to query the “user data” and find out what kind of object it is before proceeding.</p>

<pre data-type="programlisting" data-code-language="java">  // Getting a generic object
  Object o1 = b1.getUserData();
  // Asking that object if it’s a Particle
  if (o1.getClass() == Particle.class) {
    Particle p = (Particle) o1;
    p.change();
  }</pre>

<p>It should also be noted that due to how Box2D triggers these callbacks, you cannot create or destroy Box2D entities inside of <strong function>beginContact()</strong>, <strong function>endContact()</strong>, <strong function>preSolve()</strong>, or <strong function>postSolve()</strong>.  If you want to do this, you’ll need to set a variable inside an object (something like: <strong function>markForDeletion = true</strong>), which you check during <strong function>draw()</strong> and then delete objects.</p>

<div id="chapter05_exercise11" data-type="example">
<h5>Exercise 5.11</h5>
<p>Consider how polymorphism could help in the above case.  Build an example in which several classes extend one class and therefore eliminate the need for such testing.</p>
</div>

<div id="chapter05_exercise12" data-type="example">
<h5>Exercise 5.12</h5>
<p>Create a simulation in which <strong klass>Particle</strong> objects disappear when they collide with one another.  Use the methodology I just described.</p>
</div>
</section>


</section>







<section data-type="sect1" id="chapter05_section14">
<h1>5.14 A Brief Interlude—Integration Methods</h1>
<p><a data-type="indexterm" data-primary=""integration"">&nbsp;</a></p>

<p>Has the following ever happened to you?  You’re at a fancy cocktail party regaling your friends with tall tales of software physics simulations.   Someone pipes up: “Enchanting! But what integration method are you using?”  “What?!” you think to yourself.  “Integration?”</p>

<p>Maybe you’ve heard the term before.  Along with “differentiation,” it’s one of the two main operations in calculus.  Right, calculus.  The good news is, we’ve gotten through about 90% of the material in this book related to physics simulation and we haven’t really needed to dive into calculus.  But as we’re coming close to finishing this topic, it’s worth taking a moment to examine the calculus behind what we have been doing and how it relates to the methodology in certain physics libraries (like Box2D and the upcoming toxiclibs).</p>

<p><a data-type="indexterm" data-primary=""derivatives"">&nbsp;</a>
<a data-type="indexterm" data-primary=""differentiation"">&nbsp;</a></p>

<p>Let’s begin by answering the question: “What does integration have to do with location, velocity, and acceleration?”   Well, first let’s define <strong><em>differentiation</em></strong>, the process of finding a “derivative.”  The derivative of a function is a measure of how a function changes over time.  Consider location and its derivative.  Location is a point in space, while velocity is change in location over time.  Therefore, velocity can be described as the “derivative” of location.   What is acceleration?  The change in velocity over time—i.e. the “derivative” of velocity.</p>

<p>Now that we understand the derivative (differentiation), we can define the integral (integration) as the inverse of the derivative.  In other words, the integral of an object&#8217;s velocity over time tells us the object’s new location when that time period ends.   Location is the integral of velocity, and velocity is the integral of acceleration.  Since our physics simulation is founded upon the process of calculating acceleration based on forces, we need integration to figure out where the object is after a certain period of time (like one frame of animation!)</p>

<p>So we’ve been doing integration all along!  It looks like this:</p>

<pre data-type="programlisting" data-code-language="java">velocity.add(acceleration);
location.add(velocity);</pre>

<p><a data-type="indexterm" data-primary=""Euler integration"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Euler" data-secondary="Leonhard"">&nbsp;</a>
<a data-type="indexterm" data-primary=""integration"" data-secondary=""Euler integration"">&nbsp;</a></p>

<p>The above methodology is known as Euler integration (named for the mathematician Leonhard Euler, pronounced “Oiler”) or the Euler method.    It’s essentially the simplest form of integration and very easy to implement in our code (see the two lines above!)  However, it is not necessarily the most efficient form, nor is it close to being the most accurate.    Why is Euler inaccurate?  Let’s think about it this way.  When you drive a car down the road pressing the gas pedal with your foot and accelerating, does the car sit in one location at time equals one second, then disappear and suddenly reappear in a new location at time equals two seconds, and do the same thing for three seconds, and four, and five?  No, of course not.  The car moves continuously down the road.  But what’s happening in our Processing sketch?  A circle is at one location at frame 0, another at frame 1, another at frame 2.  Sure, at thirty frames per second, we’re seeing the illusion of motion.  But we only calculate a new location every <strong var>N</strong> units of time, whereas the real world is perfectly continuous.   This results in some inaccuracies, as shown in the diagram below:</p>

<figure id="chapter05_figure13">
<img src="imgs/chapter05/ch05_13.png" alt="Figure 5.13"/>
<figcaption/>
</figure>
<p>The “real world” is the curve; Euler simulation is the series of line segments.</p>

<p>One option to improve on Euler is to use smaller timesteps—instead of once per frame, we could recalculate an object’s location twenty times per frame.  But this isn’t practical; our sketch would then run too slowly.</p>

<p><a data-type="indexterm" data-primary=""Euler integration"" data-secondary=""symplectic Euler (Box2D)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""symplectic Euler (Box2D)"">&nbsp;</a></p>

<p>I still believe that Euler is the best method for learning the basics, and it’s also perfectly adequate for most of the projects we might make in Processing.  Anything we lose in efficiency or inaccuracy we make up in ease of use and understandability.    For better accuracy, Box2D uses something called <a href="http://en.wikipedia.org/wiki/Symplectic_Euler_method">symplectic Euler or semi-explicit Euler</a>, a slight modification of Euler.</p>

<p><a data-type="indexterm" data-primary=""integration"" data-secondary=""Runge-Kutta method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Kutta" data-secondary="M. W."">&nbsp;</a>
<a data-type="indexterm" data-primary=""Runge" data-secondary="C."">&nbsp;</a>
<a data-type="indexterm" data-primary=""Runge-Kutta method"">&nbsp;</a></p>

<p>There is also an integration method called Runge-Kutta (named for German mathematicians C. Runge and M. W. Kutta), which is used in some physics engines.</p>

<p><a data-type="indexterm" data-primary=""particle systems"" data-secondary=""Verlet integration and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Verlet integration"">&nbsp;</a></p>

<p>A very popular integration method that our next physics library uses is known as “Verlet integration.”  A simple way to describe Verlet integration is to think of our typical motion algorithm without velocity.  After all, we don&#8217;t really need to store the velocity.  If we always know where an object was at one point in time and where it is now, we can extrapolate its velocity.  Verlet integration does precisely this, though instead of having a variable for velocity, it calculates velocity while the program is running.   Verlet integration is particularly well suited for particle systems, especially particle systems with spring connections between the particles.    We don&#8217;t need to worry about the details because toxiclibs, as we’ll see below, takes care of them for us.  However, if you are interested, here is the seminal paper on Verlet physics, from which just about every Verlet computer graphics simulation is derived: <a href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">"Advanced Character Physics"</a>. And of course, you can find out more about Verlet integration from <a href="http://en.wikipedia.org/wiki/Verlet_integration">Wikipedia</a>.</p>
</section>







<section data-type="sect1" id="chapter05_section15">
<h1>5.15 Verlet Physics with toxiclibs</h1>
<p><a data-type="indexterm" data-primary=""Processing"" data-secondary=""toxiclibs and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Schmidt" data-secondary="Karsten"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Verlet integration"" data-secondary=""toxiclibs"">&nbsp;</a></p>

<p>From toxiclibs.org:</p>

<p><em>“toxiclibs is an independent, open source library collection for computational design tasks with Java &amp; Processing developed by Karsten “toxi” Schmidt (thus far). The classes are purposefully kept fairly generic in order to maximize re-use in different contexts ranging from generative design, animation, interaction/interface design, data visualization to architecture and digital fabrication, use as teaching tool and more.”</em></p>

<p>In other words, we should thank our lucky stars for toxiclibs.  We are only going to focus on a few examples related to Verlet physics, but toxiclibs includes a suite of other wonderful packages that help with audio, color, geometry, and more.  In particular, if you are looking to work with form and fabrication in Processing, take a look at the geometry package.   Demos can be found at <a href="http://www.openprocessing.org/portal/?userID=4530">Open Processing</a>.</p>

<p>We should note that toxiclibs was designed specifically for use with Processing.  This is great news.  The trouble we had with making Box2D work in Processing (multiple coordinate systems, Box2D vs. JBox2D vs. PBox2D) is not an issue here.  toxiclibs is a library that you just download, stick in your libraries folder, and use.  And the coordinate system that we’ll use for the physics engine is the coordinate system of Processing, so no translating back and forth.   In addition, toxiclibs is not limited to a 2D world; all of the physics simulations and functions work in both two and three dimensions.  So how do you decide which library you should use?  Box2D or toxiclibs?  If you fall into one of the following two categories, your decision is a bit easier:</p>

<p><a data-type="indexterm" data-primary=""Box2D"" data-secondary=""toxiclibs vs."">&nbsp;</a>
<a data-type="indexterm" data-primary=""collisions"" data-secondary=""toxiclibs and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""Box2D vs."">&nbsp;</a></p>

<p><strong>1. My project involves collisions.   I have circles, squares, and other strangely shaped objects that knock each other around and bounce off each other.</strong></p>

<p>In this case, you are going to need Box2D.  toxiclibs does not handle collisions.</p>

<p><strong>2. My project involves lots of particles flying around the screen.  Sometimes they attract each other.  Sometimes they repel each other.  And sometimes they are connected with springs.</strong></p>

<p>In this case, toxiclibs is likely your best choice.  It is simpler to use than Box2D and particularly well suited to connected systems of particles.  toxiclibs is also very high performance, due to the speed of the Verlet integration algorithm (not to mention the fact that the program gets to ignore all of the collision geometry).</p>

<p>Here is a little chart that covers some of the features for each physics library.</p>

<table>

<thead>
<tr>
<th>Feature</th>
<th>Box2D</th>
<th>toxiclibs VerletPhysics</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Collision geometry</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p>3D physics</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Particle attraction / repulsion forces</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Spring connections</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Other connections: revolute, pulley, gear, prismatic</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p>Motors</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p>Friction</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>





<section data-type="sect2" id="_getting_toxiclibs">
<h2>Getting toxiclibs</h2>
<p><a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""downloading"">&nbsp;</a></p>

<p>Everything you need to download and install toxiclibs can be found at:</p>

<p><a href="http://toxiclibs.org/">toxiclibs</a></p>

<p>When you download the library, you’ll notice that it comes with eight modules (i.e. sub-folders), each a library in its own right.  For the examples in this chapter, you will only need “verletphysics” and “toxiclibscore”; however, I recommend you take a look at and consider using all of the modules!</p>

<p>Once you have the library installed to your <a href="http://wiki.processing.org/w/How_to_Install_a_Contributed_Library">Processing library folder</a>, you are ready to start looking at the following examples.</p>
</section>







<section data-type="sect2" id="_core_elements_of_verletphysics">
<h2>Core Elements of VerletPhysics</h2>
<p><a data-type="indexterm" data-primary=""VerletPhysics class (toxiclibs)"" data-secondary=""core elements of"">&nbsp;</a></p>

<p>We spent a lot of time working through the core elements of a Box2D world: world, body, shape, joint.   This gives us a head start on understanding toxiclibs, since it follows a similar structure.</p>

<table>

<thead>
<tr>
<th>Box2D</th>
<th>toxiclibs VerletPhysics</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>World</p></td>
<td><p>VerletPhysics</p></td>
</tr>
<tr>
<td><p>Body</p></td>
<td><p>VerletParticle</p></td>
</tr>
<tr>
<td><p>Shape</p></td>
<td><p>Nothing!  toxiclibs does not handle shape geometry</p></td>
</tr>
<tr>
<td><p>Fixture</p></td>
<td><p>Nothing!  toxiclibs does not handle shape geometry</p></td>
</tr>
<tr>
<td><p>Joint</p></td>
<td><p>VerletSpring</p></td>
</tr>
</tbody>
</table>
</section>







<section data-type="sect2" id="_vectors_with_toxiclibs">
<h2>Vectors with toxiclibs</h2>
<p><a data-type="indexterm" data-primary=""Vec2D (toxiclibs type)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Vec3D (toxiclibs type)"">&nbsp;</a></p>

<p>Here we go again.  Remember all that time we spent learning the ins and outs of the <strong klass>PVector</strong> class?  Then remember how when we got to Box2D, we had to translate all those concepts to a Box2D vector class: <strong klass>Vec2</strong>?  Well, it’s time to do it again.  toxiclibs also includes its own vector classes, one for two dimensions and one for three:  <strong klass>Vec2D</strong> and <strong klass>Vec3D</strong>.</p>

<p>Again, toxiclibs vectors are the same conceptually, but we need to learn a bit of new syntax.  You can find all of the documentation for these vector classes here:</p>

<p><a href="http://toxiclibs.org/docs/core/toxi/geom/Vec2D.html">Vec2D</a><br/>
<a href="http://toxiclibs.org/docs/core/toxi/geom/Vec3D.html">Vec3D</a></p>

<p>And let’s just review some of the basic vector math operations with <strong klass>PVector</strong> translated to <strong klass>Vec2D</strong> (we’re sticking with 2D for simplicity’s sake).</p>

<p><a data-type="indexterm" data-primary=""Vec2D (toxiclibs type)"" data-secondary=""math functions for"">&nbsp;</a></p>

<table class="code">
<tr>
<th>PVector</th>
<th>Vec2D</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
a.addSelf(b);
</pre>
</td>
</tr>

<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
Vec2D c = a.add(b);
</pre>
</td>
</tr>

<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
float m = a.magnitude();
a.normalize();
</pre>
</td>
</tr>

</table></section>







<section data-type="sect2" id="_building_the_toxiclibs_physics_world">
<h2>Building the toxiclibs physics world</h2>
<p><a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""world" data-tertiary="building"">&nbsp;</a></p>

<p>The first thing we need to do to create a toxiclibs physics world in our examples is import the library itself.</p>

<pre data-type="programlisting" data-code-language="java">//[full] Importing the libraries
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;
//[end]</pre>

<p><a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""VerletPhysics class"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""VerletPhysics2D class"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletPhysics class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletPhysics2D class (toxiclibs)"">&nbsp;</a></p>

<p>Then we’ll need a reference to our physics world, a <strong klass>VerletPhysics</strong> or <strong klass>VerletPhysics2D</strong> object (depending on whether we are working in two or three dimensions).  The examples in this chapter will operate in 2D only for simplicity, but they could easily be extended into 3D (and 3D versions are available with the chapter download).</p>

<pre data-type="programlisting" data-code-language="java">VerletPhysics2D physics;

void setup() {
  // Creating a toxiclibs Verlet physics world
  physics=new VerletPhysics2D();</pre>

<p>Once you have your <strong klass>VerletPhysics</strong> object, you can set some global properties for your world.  For example, if you want it to have hard boundaries past which objects cannot travel, you can set its limits:</p>

<pre data-type="programlisting" data-code-language="java">  physics.setWorldBounds(new Rect(0,0,width,height));</pre>

<p><a data-type="indexterm" data-primary=""gravity"" data-secondary=""GravityBehavior (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""GravityBehavior class (toxiclibs)"">&nbsp;</a></p>

<p>In addition, you can add gravity to the physics world with a <strong klass>GravityBehavior</strong> object.  A gravity behavior requires a vector—how strong and in what direction is the gravity?</p>

<pre data-type="programlisting" data-code-language="java">  physics.addBehavior(new GravityBehavior(new Vec2D(0,0.5)));
}</pre>

<p><a data-type="indexterm" data-primary=""update() function (toxiclibs)"">&nbsp;</a></p>

<p>Finally, in order to calculate the physics of the world and move the objects in the world, we have to call <strong function>update()</strong>.  Typically this would happen once per frame in <strong function>draw()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  // This is the same as Box2D’s “step()” function
  physics.update();
}</pre>
</section>


</section>







<section data-type="sect1" id="chapter05_section16">
<h1>5.16 Particles and Springs in toxiclibs</h1>
<p><a data-type="indexterm" data-primary=""particles"" data-secondary=""toxiclibs implementation of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""particles" data-tertiary="implementing in"">&nbsp;</a></p>

<p>In the Box2D examples, we saw how we can create our own class (called, say, <strong klass>Particle</strong>) and include a reference to a Box2D body.</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  Body body;</pre>

<p>This technique is somewhat redundant since Box2D itself keeps track of all of the bodies in its world.  However, it allows us to manage which body is which (and therefore how each body is drawn) without having to rely on iterating through Box2D’s internal lists.</p>

<p><a data-type="indexterm" data-primary=""particles"" data-secondary=""VerletParticle2D object (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletParticle2D object (toxiclibs)"">&nbsp;</a></p>

<p>Let’s look at how we might take the same approach with the class <strong klass>VerletParticle2D</strong> in toxiclibs. We want to make our own <strong klass>Particle</strong> class so that we can draw our particles a certain way and include any custom properties. We’d probably write our code as follows:</p>

<pre data-type="programlisting" data-code-language="java">class Particle {
  // Our Particle has a reference to a VerletParticle.
  VerletParticle2D p;

  Particle(Vec2D pos) {
    // A VerletParticle needs an initial location (an x and y).
    p = new VerletParticle2D(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    // When it comes time to draw the Particle, we ask the
    // VerletParticle for its x and y coordinates.
    ellipse(p.x,p.y,16,16);
  }
}</pre>

<p>Looking at the above, we should first be thrilled to notice that drawing the particle is as simple as grabbing the <em>x</em> and <em>y</em> and using them.  No awkward conversions between coordinate systems here since toxiclibs is designed to think in pixels.    Second, you might notice that this <strong klass>Particle</strong> class’s sole purpose is to store a reference to a <strong klass>VerletParticle2D</strong> object.  This hints at something.  Remember our discussion of inheritance back in Chapter 4: Particle Systems? What is a <strong klass>Particle</strong> object other than an “augmented” <strong klass>VerletParticle</strong>?  Why bother making a Verlet particle inside a particle when we could simply <strong klass>extend VerletParticle</strong>?</p>

<pre data-type="programlisting" data-code-language="java">class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    // Calling super() so that the object is initialized properly
    super(loc);
  }

  // We want this to be just like a VerletParticle, only with a display() method.
  void display() {
    fill(175);
    stroke(0);
    // We’ve inherited x and y from VerletParticle!
    ellipse(x,y,16,16);
  }
}</pre>

<p>Remember our multi-step process with the Box2D examples?  We had to ask the body for its location, then convert that location to pixels, then use that location in a drawing function.  Now, because we have inherited everything from the <strong klass>VerletParticle</strong> class, our only step is to draw the shape at <strong var>x</strong> and <strong var>y</strong>!</p>

<p><a data-type="indexterm" data-primary=""Vec2D (toxiclibs type)"" data-secondary=""VerletParticle2D class and"">&nbsp;</a></p>

<p>Incidentally, it’s interesting to note that the <strong klass>VerletParticle2D</strong> class is a subclass of <strong klass>Vec2D</strong>. So in addition to inheriting everything from <strong klass>VerletParticle2D</strong>, our <strong klass>Particle</strong> class actually has all of the <strong klass>Vec2D</strong> functions available as well.</p>

<p>We can now create particles anywhere within our sketch.</p>

<pre data-type="programlisting" data-code-language="java">  Particle p1 = new Particle(new Vec2D(100,20));
  Particle p2 = new Particle(new Vec2D(100,180));</pre>

<p><a data-type="indexterm" data-primary=""addParticle() function (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""particle systems"" data-secondary=""addParticle() function (toxiclibs)"">&nbsp;</a></p>

<p>Just making a particle isn’t enough, however.  We have to make sure we tell our physics world about them with the <strong function>addParticle()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">  physics.addParticle(p1);
  physics.addParticle(p2);</pre>

<p>If you look at the toxiclibs documentation, you’ll see that the <strong function>addParticle()</strong> expects a <strong klass>VerletParticle2D</strong> object.</p>

<p><strong function>addParticle(VerletParticle2D particle)</strong></p>

<p>And how can we then pass into the function our own <strong klass>Particle</strong> object?   Remember that other tenet of object-oriented programming—polymorphism? Here, because our <strong klass>Particle</strong> class <strong klass>extends VerletParticle2D</strong>, we can choose to treat our particle in two different ways—as a <strong klass>Particle</strong> or as a <strong klass>VerletParticle2D</strong>.   This is an incredibly powerful feature of object-oriented programming.  If we build our custom classes based on classes from toxiclibs, we can use our objects in conjunction with all of the functions toxiclibs has to offer.</p>

<p><a data-type="indexterm" data-primary=""springs"" data-secondary=""toxiclibs and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""springs"">&nbsp;</a></p>

<p>In addition to the <strong klass>VerletParticle</strong> class, toxiclibs has a set of classes that allow you to connect particles with spring forces.  There are three types of springs in toxiclibs:</p>

<p><a data-type="indexterm" data-primary=""springs"" data-secondary=""VerletConstrainedSpring class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""springs"" data-secondary=""VerletMinDistanceSpring class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""springs"" data-secondary=""VerletSpring class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletConstrainedSpring class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletMinDistanceSpring class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""VerletSpring class (toxiclibs)"">&nbsp;</a></p>

<ul>
<li>
<p><strong klass>VerletSpring</strong>: This class creates a springy connection between two particles in space. A spring’s properties can be configured in such a way as to create a stiff stick-like connection or a highly elastic stretchy connection. A particle can also be locked so that only one end of the spring can move.</p></li>
<li>
<p><strong klass>VerletConstrainedSpring</strong>: A <strong klass>VerletConstrainedSpring</strong> object is a spring whose maximum distance can be limited. This can help the whole spring system achieve better stability.</p></li>
<li>
<p><strong klass>VerletMinDistanceSpring</strong>: A <strong klass>VerletMinDistanceSpring</strong> object is a spring that only enforces its rest length if the current distance is less than its rest length. This is handy if you want to ensure objects are at least a certain distance from each other, but don’t care if the distance is bigger than the enforced minimum.</p></li>
</ul>

<p>The inheritance and polymorphism technique we employed in the previous section also proves to be useful when creating springs. A spring expects two particles when it is created. And again, because our <strong klass>Particle</strong> class <strong klass>extends VerletParticle</strong>, a <strong klass>VerletSpring</strong> object will accept our <strong klass>Particle</strong> objects passed into the constructor.  Let’s take a look at some example code that assumes the existence of our two previous particles <strong var>p1</strong> and <strong var>p2</strong> and creates a connection between them with a given rest length and strength.</p>

<pre data-type="programlisting" data-code-language="java">// What is the rest length of the spring?
float len = 80;
// How strong is the spring?
float strength = 0.01;
VerletSpring2D spring=new VerletSpring2D(p1,p2,len,strength);</pre>

<p>Just as with particles, in order for the connection to actually be part of the physics world, we need to explicitly add it.</p>

<pre data-type="programlisting" data-code-language="java">physics.addSpring(spring);</pre>
</section>







<section data-type="sect1" id="chapter05_section17">
<h1>5.17 Putting It All Together: A Simple Interactive Spring</h1>
<p><a data-type="indexterm" data-primary=""lock() function (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""springs"" data-secondary=""lock() function (toxiclibs)"">&nbsp;</a></p>

<p>One thing we saw with Box2D is that the physics simulation broke down when we overrode it and manually set the location of a body. With toxiclibs, we don’t have this problem.  If we want to move the location of a particle, we can simply set its <em>x</em> and <em>y</em> location manually.  However, before we do so, it’s generally a good idea to call the <strong function>lock()</strong> function.</p>

<p><strong function>lock()</strong> is typically used to lock a particle in place and is identical to setting a Box2D body’s density to 0.   However, here we are going to show how to lock a particle temporarily, move it, and then unlock it so that it continues to move according to the physics simulation.
 Let’s say you want to move a given particle whenever you click the mouse.</p>

<pre data-type="programlisting" data-code-language="java">  if (mousePressed) {
    //[full] First lock the particle, then set the x and y, then unlock() it.
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
    //[end]
  }</pre>

<p>And now we’re ready to put all of these elements together in a simple example that connects two particles with a spring.  One particle is locked in place, and the other can be moved by dragging the mouse.  Note that this example is virtually identical to <a href="#chapter03_example11">Example 3.11</a>.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex12.png" alt="ch05 ex12"/>
<figcaption/>
</figure>
<p><strong example>Example 5.10: Simple Spring with toxiclibs</strong></p>

<pre data-type="programlisting" data-code-language="java">import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

VerletPhysics2D physics;
Particle p1;
Particle p2;

void setup() {
  size(640,360);

  // Creating a physics world
  physics=new VerletPhysics2D();
  physics.addBehavior(new GravityBehavior2D(new Vec2D(0,0.5)));
  physics.setWorldBounds(new Rect(0,0,width,height));

  // Creating two Particles
  p1 = new Particle(new Vec2D(100,20));
  p2 = new Particle(new Vec2D(100,180));
  // Locking Particle 1 in place
  p1.lock();

  //[offset-down] Creating one Spring
  VerletSpring2D spring=new VerletSpring2D(p1,p2,80,0.01);

  // Must add everything to the world
  physics.addParticle(p1);
  physics.addParticle(p2);
  physics.addSpring(spring);
}

void draw() {
  // Must update the physics
  physics.update();

  background(255);

  // Drawing everything
  line(p1.x,p1.y,p2.x,p2.y);
  p1.display();
  p2.display();

  if (mousePressed) {
    //[full] Moving a Particle according to the mouse
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
    //[end]
  }
}

//[full] How cute is our simple Particle class?!
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    super(loc);
  }

  void display() {
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);
  }
}
//[end]</pre>
</section>







<section data-type="sect1" id="chapter05_section18">
<h1>5.18 Connected Systems, Part I: String</h1>
<p><a data-type="indexterm" data-primary=""connected systems"" data-secondary=""strings"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""connected systems"">&nbsp;</a></p>

<p>The above example, two particles connected with a single spring, is the core building block for what toxiclibs’ physics is particularly well suited for: soft body simulations.  For example, a string can be simulated by connecting a line of particles with springs.  A blanket can be simulated by connecting a grid of particles with springs.  And a cute, cuddly, squishy cartoon character can be simulated by a custom layout of particles connected with springs.</p>

<figure id="chapter05_figure14">
<img src="imgs/chapter05/ch05_14.png" alt="Figure 5.14"/>
<figcaption/>
</figure>
<p>Let’s begin by simulating a “soft pendulum”—a bob hanging from a string, instead of a rigid arm like we had in <a href="#chapter03_example10">Chapter 3, Example 10</a>.  Let’s use the "string"
in Figure 5.14 above as our model.</p>

<p>First, we’ll need a list of particles (let’s use the same <strong klass>Particle</strong> class we built in the previous example).</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();</pre>

<p>Now, let’s say we want to have 20 particles, all spaced 10 pixels apart.</p>

<figure id="chapter05_figure15">
<img src="imgs/chapter05/ch05_15.png" alt="Figure 5.15"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">float len = 10;
float numParticles = 20;</pre>

<p>We can loop from <strong var>i</strong> equals 0 all the way up to 20, with each particle&#8217;s <em>y</em> location set to <strong var>i <code>*</code> 10</strong> so that the first particle is at <em>(0,10)</em>, the second at <em>(0,20)</em>, the third at <em>(0,30)</em>, etc.</p>

<pre data-type="programlisting" data-code-language="java">for(int i=0; i &lt; numPoints; i++) {
  // Spacing them out along the x-axis
  Particle particle=new Particle(i*len,10);
  // Add the particle to our list.
  physics.addParticle(particle);
  // Add the particle to the physics world.
  particles.add(particle);
}</pre>

<p>Even though it’s a bit redundant, we’re going to add the particle to both the toxiclibs physics world and to our own list.  In case we eventually have multiple strings, this will allow us to know which particles are connected to which strings.</p>

<p>Now for the fun part: It’s time to connect all the particles.  Particle 1 will be connected to particle 0, particle 2 to particle 1, 3 to 2, 4 to 3, etc.</p>

<figure id="chapter05_figure16">
<img src="imgs/chapter05/ch05_16.png" alt="Figure 5.16"/>
<figcaption/>
</figure>
<p>In other words, particle <strong var>i</strong> needs to be connected to particle <strong var>i-1</strong> (except for when <strong var>i</strong> equals zero).</p>

<pre data-type="programlisting" data-code-language="java">if (i != 0) {
  // First we need a reference to the previous particle.
  Particle previous = particles.get(i-1);

  //[offset-down] Then we make a spring connection between the particle and the previous particle with a rest length and strength (both floats).
  VerletSpring2D spring = new VerletSpring2D(particle,previous,len,strength);




  // We must not forget to add the spring to the physics world.
  physics.addSpring(spring);
}</pre>

<p><a data-type="indexterm" data-primary=""strings"" data-secondary=""hanging from fixed points"">&nbsp;</a></p>

<p>Now, what if we want the string to hang from a fixed point?  We can lock one of the particles—the first, the last, the middle one, etc.  Here’s how we would access the first particle (in the <strong klass>ArrayList</strong>) and lock it.</p>

<pre data-type="programlisting" data-code-language="java">Particle head=particles.get(0);
head.lock();</pre>

<p>And if we want to draw all the particles as being connected with a line, along with a circle for the last particle, we can use <strong function>beginShape()</strong>, <strong function>endShape()</strong>, and <strong function>vertex()</strong>, accessing the particle locations from our <strong klass>ArrayList</strong>.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex13.png" alt="ch05 ex13"/>
<figcaption/>
</figure>
<p><strong example>Example 5.11: Soft swinging pendulum</strong></p>

<pre data-type="programlisting" data-code-language="java">stroke(0);
noFill();
beginShape();
for (Particle p : particles) {
  // Each particle is one point in the line.
  vertex(p.x,p.y);
}
endShape();
Particle tail = particles.get(numPoints-1);
// This draws the last particle as a circle.
tail.display();</pre>

<p>The full code available with the chapter download also demonstrates how to drag the tail particle with the mouse.</p>

<div id="chapter05_exercise13" data-type="example">
<h5>Exercise 5.13</h5>
<p>Create a hanging cloth simulation using the technique above, but connect all the particles with a grid as demonstrated in the screenshot below.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_exc13.png" alt="ch05 exc13"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter05_section19">
<h1>5.19 Connected Systems, Part II: Force-Directed Graph</h1>
<p><a data-type="indexterm" data-primary=""connected systems"" data-secondary=""force-directed graphs"">&nbsp;</a>
<a data-type="indexterm" data-primary=""force-directed graphs"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""force-directed graphs"">&nbsp;</a></p>

<p>Have you ever encountered the following scenario?</p>

<p>“I have a whole bunch of stuff I want to draw on the screen and I want all that stuff to be spaced out evenly in a nice, neat, organized manner.  Otherwise I have trouble sleeping at night.”</p>

<p>This is not an uncommon problem in computational design. One solution is typically referred to as a “force-directed graph.”  A force-directed graph is a visualization of elements—let’s call them “nodes”—in which the positions of those nodes are not manually assigned. Rather, the nodes arrange themselves according to a set of forces.  While any forces can be used, a typical example involves spring forces.  And so toxiclibs is perfect for this scenario.</p>

<figure class="three-col">
<img src="imgs/chapter05/ch05_ex14.png" alt="ch05 ex14"/>
<figcaption/>
</figure>
<figure class="three-col">
<img src="imgs/chapter05/ch05_ex15.png" alt="ch05 ex15"/>
<figcaption/>
</figure>
<figure class="three-col">
<img src="imgs/chapter05/ch05_ex16.png" alt="ch05 ex16"/>
<figcaption/>
</figure>
<p>How do we implement the above?</p>

<p>First, we’ll need a <strong klass>Node</strong> class.  This is the easy part; it can <strong klass>extend VerletParticle2D</strong>.  Really, this is just what we did before, only we’re calling it <strong klass>Node</strong> now instead of <strong klass>Particle</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Node extends VerletParticle2D {
  Node(Vec2D pos) {
    super(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</pre>

<p>Next we can write a class called <strong klass>Cluster</strong>, which will describe a list of nodes.</p>

<pre data-type="programlisting" data-code-language="java">class Cluster {

  ArrayList&lt;Node&gt; nodes;

  // We’ll use this variable for the rest
  // length between all the nodes.
  float diameter;

  Cluster(int n, float d, Vec2D center) {
    nodes = new ArrayList&lt;Node&gt;();
    diameter = d;

    for (int i = 0; i &lt; n; i++) {
      //[offset-down] Here’s a funny little detail.  We’re going to have a problem
      // if all the Node objects start in exactly the same location.
      // So we add a random vector to the center location so that each
      // Node is slightly offset.
      nodes.add(new Node(center.add(Vec2D.randomVector())));



    }
  }</pre>

<p>Let’s assume we added a <strong function>display()</strong> function to draw all the nodes in the cluster and created a <strong klass>Cluster</strong> object in <strong function>setup()</strong> and displayed it in <strong function>draw()</strong>. If we ran the sketch as is, nothing would happen. Why? Because we forgot the whole force-directed graph part!  We need to connect every single node to every other node with a force. But what exactly do we mean by that?  Let’s assume we have four <strong klass>Node</strong> objects: 0, 1, 2 and 3.  Here are our connections:</p>

<p><strong mono>0 connected to 1<br/>
0 connected to 2<br/>
0 connected to 3<br/>
1 connected to 2<br/>
1 connected to 3<br/>
2 connected to 3</strong></p>

<p>Notice two important details about our connection list.</p>

<ul>
<li>
<p><strong><em>No node is connected to itself.</em></strong>  We don’t have 0 connected to 0 or 1 connected to 1.</p></li>
<li>
<p><strong><em>We don’t need to repeat connections in reverse.</em></strong>  In other words, if we’ve already said 0 is connected to 1, we don’t need to say 1 is connected to 0 because, well, it already is!</p></li>
</ul>

<p>So how do we write code to make these connections for <em>N</em> number of nodes?</p>

<p>Look at the left column. It reads: 000 11 22.  So we know we need to access each node in the list from 0 to <em>N</em>-1.</p>

<pre data-type="programlisting" data-code-language="java">    for (int i = 0; i &lt; nodes.size()-1; i++) {
      VerletParticle2D ni = nodes.get(i);</pre>

<p>Now, we know we need to connect node 0 to nodes 1,2,3.  For node 1: 2,3.  For node 2: 3.  So for every node i, we must loop from i+1 until the end of the list.</p>

<pre data-type="programlisting" data-code-language="java">      // Look how we start j at i + 1.
      for (int j = i+1; j &lt; nodes.size(); j++) { //[bold]
        VerletParticle2D nj = nodes.get(j);</pre>

<p>With every two <strong klass>Node</strong><code>s</code> we find, all we have to do then is make a spring.</p>

<pre data-type="programlisting" data-code-language="java">        // The Spring connects Nodes “ni” and “nj”.
        physics.addSpring(new VerletSpring2D(ni,nj,diameter,0.01));
      }
    }</pre>

<p>Assuming those connections are made in the <strong klass>Cluster</strong> constructor, we can now create a cluster in our main tab and see the results!</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex17.png" alt="ch05 ex17"/>
<figcaption/>
</figure>
<p><strong example>Example 5.12: Cluster</strong></p>

<pre data-type="programlisting" data-code-language="java">import toxi.geom.*;
import toxi.physics2d.*;

VerletPhysics2D physics;
Cluster cluster;

void setup() {
  size(300,300);
  physics=new VerletPhysics2D();
  //[offset-down] Make a cluster.
  cluster = new Cluster(8,100,new Vec2D(width/2,height/2));
}

void draw() {
  physics.update();
  background(255);
  // Draw the cluster.
  cluster.display();
}</pre>

<div id="chapter05_exercise14" data-type="example">
<h5>Exercise 5.14</h5>
<p>Use the <strong klass>Cluster</strong> structure as a skeleton for a cute, cuddly, squishy creature (à la “Nokia Friends”).  Add gravity and also allow the creature to be dragged with the mouse.</p>
</div>

<div id="chapter05_exercise15" data-type="example">
<h5>Exercise 5.15</h5>
<p>Expand the force-directed graph to have more than one <strong klass>Cluster</strong> object.  Use a <strong klass>VerletMinDistanceSpring2D</strong> object to connect cluster to cluster.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_exc15.png" alt="ch05 exc15"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter05_section20">
<h1>5.20 Attraction and Repulsion Behaviors</h1>
<p><a data-type="indexterm" data-primary=""addForce() function (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""attraction/repulsion behaviors and"">&nbsp;</a></p>

<p>When we looked at adding an attraction force to Box2D, we found that the Box2D <strong klass>Body</strong> class included an <strong function>applyForce()</strong> function.  All we needed to do was calculate the attraction force (Force = G * mass1 * mass2 / distance squared) as a vector and apply it to the body.  toxiclibs <strong klass>VerletParticle</strong> class also includes a function called <strong function>addForce()</strong> that we can use to apply any calculated force to a particle.</p>

<p><a data-type="indexterm" data-primary=""AttractionBehavior class (toxiclibs)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""toxiclibs"" data-secondary=""AttractionBehavior class"">&nbsp;</a></p>

<p>However, toxiclibs also takes this idea one step further by allowing us to attach some common forces (let’s call them “behaviors”) to particles, calculating them and applying them for us!  For example, if we attach an <strong klass>AttractionBehavior</strong> object to a particle, then all other particles in the physics world will be attracted to that particle.</p>

<p>Let’s say we have a <strong klass>Particle</strong> class (that <strong klass>extends VerletParticle</strong>).</p>

<pre data-type="programlisting" data-code-language="java">Particle p = new Particle(new Vec2D(200,200));</pre>

<p>Once we&#8217;ve made a <strong klass>Particle</strong> object, we can create an <strong klass>AttractionBehavior</strong> object associated with that particle.</p>

<pre data-type="programlisting" data-code-language="java">float distance = 20;
float strength = 0.1;
AttractionBehavior behavior = new AttractionBehavior(p, distance, strength);</pre>

<p>Notice how the behavior is created with two parameters—<strong var>distance</strong> and <strong var>strength</strong>.  The distance specifies the range within which the behavior will be applied.  For example, in the above scenario, only other particles within twenty pixels will feel the attraction force.  The strength, of course, specifies how strong the force is.</p>

<p>Finally, in order for the force to be activated, the behavior needs to be added to the physics world.</p>

<pre data-type="programlisting" data-code-language="java">physics.addBehavior(behavior);</pre>

<p>This means everything that lives in the physics simulation will always be attracted to that particle, as long as it is within the distance threshold.</p>

<p>Even though toxiclibs does not handle collisions, you can create a collision-like effect by adding a repulsive behavior to each and every particle (so that every particle repels every other particle).  Let’s look at how we might modify our <strong klass>Particle</strong> class to do this.</p>

<pre data-type="programlisting" data-code-language="java">class Particle extends VerletParticle2D {

  // We’ve added a radius to every Particle.
  float r;

  Particle (Vec2D loc) {
    super(loc);
    r = 4;
    //[offset-down] Every time a Particle is made, an AttractionBehavior is
    // generated and added to the physics world.
    // Note that when the strength
    // is negative, it’s a repulsive force!
    physics.addBehavior(new AttractionBehavior(this, r*4, -1));
  }

  void display () {
    fill (255);
    stroke (255);
    ellipse (x, y, r*2, r*2);
  }
}</pre>

<p>We could now recreate our attraction example by having a single <strong klass>Attractor</strong> object that exerts an attraction behavior over the entire window.</p>

<figure class="screenshot">
<img src="imgs/chapter05/ch05_ex18.png" alt="ch05 ex18"/>
<figcaption/>
</figure>
<p><strong example>Example 5.13: Attraction/Repulsion</strong></p>

<pre data-type="programlisting" data-code-language="java">class Attractor extends VerletParticle2D {

  float r;

  Attractor (Vec2D loc) {
    super (loc);
    r = 24;
    //[offset-down] The AttractionBehavior “distance” equals
    // the width so that it covers the entire window.
    physics.addBehavior(new AttractionBehavior(this, width, 0.1));
  }

  void display () {
    fill(0);
    ellipse (x, y, r*2, r*2);
  }
}</pre>

<div id="chapter05_exercise16" data-type="example">
<h5>Exercise 5.16</h5>
<p>Create an object that both attracts and repels.  What if it attracts any particle that is far away but repels those particles at a short distance?</p>
</div>

<div id="chapter05_exercise17" data-type="example">
<h5>Exercise 5.17</h5>
<p>Use <strong klass>AttractionBehavior</strong> in conjunction with spring forces.</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 5 Exercise:</p>

<p>Take your system of creatures from Step 4 and use a physics engine to drive their motion and behaviors.  Some possibilities:</p>

<ul>
<li>
<p>Use Box2D to allow collisions between creatures.  Consider triggering events when creatures collide.</p></li>
<li>
<p>Use Box2D to augment the design of your creatures.  Build a skeleton with distance joints or make appendages with revolute joints.</p></li>
<li>
<p>Use toxiclibs to augment the design of your creature. Use a chain of toxiclibs particles for tentacles or a mesh of springs as a skeleton.</p></li>
<li>
<p>Use toxiclibs to add attraction and repulsion behaviors to your creatures.</p></li>
<li>
<p>Use spring (or joint) connections between objects to control their interactions.  Create and delete these springs on the fly.  Consider making these connections visible or invisible to the viewer.</p></li>
</ul>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_6_autonomous_agents">
<h1>Chapter 6.  Autonomous Agents</h1>
<blockquote data-type="epigraph"><p>“This is an exercise in fictional science, or science fiction, if you like that better.”</p>
<p data-type="attribution">&#8212; — Valentino Braitenberg</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""autonomous agents"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""autonomous agents"">&nbsp;</a></p>

<p>Believe it or not, there is a purpose.  Well, at least there&#8217;s a purpose to the first five chapters of this book.  We could stop right here; after all, we’ve looked at several different ways of modeling motion and simulating physics.  Angry Birds, here we come!</p>

<p>Still, let’s think for a moment.  Why are we here?   The <em>nature</em> of code, right?   What have we been designing so far?   Inanimate objects.  Lifeless shapes sitting on our screens that flop around when affected by forces in their environment.   What if we could breathe life into those shapes? What if those shapes could live by their own rules?  Can shapes have hopes and dreams and fears?   This is what we are here in this chapter to do—develop <em>autonomous agents</em>.</p>




<section data-type="sect1" id="chapter06_section1">
<h1>6.1  Forces from Within</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""autonomous agents and"">&nbsp;</a></p>

<p>The term <strong><em>autonomous agent</em></strong> generally refers to an entity that makes its own choices about how to act in its environment without any influence from a leader or global plan.  For us, “acting” will mean moving.   This addition is a significant conceptual leap.  Instead of a box sitting on a boundary waiting to be pushed by another falling box, we are now going to design a box that has the ability and “desire” to leap out of the way of that other falling box, if it so chooses.   While the concept of forces that come from within is a major shift in our design thinking, our code base will barely change, as these desires and actions are simply that—<em>forces</em>.</p>

<p>Here are three key components of autonomous agents that we’ll want to keep in mind as we build our examples.</p>

<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""key components of"">&nbsp;</a></p>

<ul>
<li>
<p><strong>An autonomous agent has a <em>limited</em> ability to perceive environment.</strong>   It makes sense that a living, breathing being should have an awareness of its environment.  What does this mean for us, however?   As we look at examples in this chapter, we will point out programming techniques for allowing objects to store references to other objects and therefore “perceive” their environment.    It’s also crucial that we consider the word <em>limited</em> here.  Are we designing an all-knowing rectangle that flies around a Processing window, aware of everything else in that window?  Or are we creating a shape that can only examine any other object within fifteen pixels of itself?   Of course, there is no right answer to this question; it all depends.  We’ll explore some possibilities as we move forward.  For a simulation to feel more “natural,” however, limitations are a good thing.  An insect, for example, may only be aware of the sights and smells that immediately surround it.   For a real-world creature, we could study the exact science of these limitations.   Luckily for us, we can just make stuff up and try it out.</p></li>
<li>
<p><strong>An autonomous agent processes the information from its environment and calculates an action.</strong>    This will be the easy part for us, as the action is a force.  The environment might tell the agent that there’s a big scary-looking shark swimming right at it, and the action will be a powerful force in the opposite direction.</p></li>
<li>
<p><strong>An autonomous agent has no leader.</strong>  This third principle is something we care a little less about.  After all, if you are designing a system where it makes sense to have a leader barking commands at various entities, then that’s what you’ll want to implement.  Nevertheless, many of these examples will have no leader for an important reason.   As we get to the end of this chapter and examine group behaviors, we will look at designing collections of autonomous agents that exhibit the properties of complex systems— intelligent and structured group dynamics that emerge not from a leader, but from the local interactions of the elements themselves.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""boids model"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Reynolds" data-secondary="Craig"">&nbsp;</a></p>

<p>In the late 1980s, computer scientist <a href="http://www.red3d.com/cwr/">Craig Reynolds</a> developed algorithmic steering behaviors for animated characters. These behaviors allowed individual elements to navigate their digital environments in a “lifelike” manner with strategies for fleeing, wandering, arriving, pursuing, evading, etc. Used in the case of a single autonomous agent, these behaviors are fairly simple to understand and implement. In addition, by building a system of multiple characters that steer themselves according to simple, locally based rules, surprising levels of complexity emerge.  The most famous example is Reynolds’s “boids” model for “flocking/swarming” behavior.</p>
</section>







<section data-type="sect1" id="chapter06_section2">
<h1>6.2  Vehicles and Steering</h1>
<p><a data-type="indexterm" data-primary=""<em>Turtles" data-secondary="Termites" data-tertiary="and Traffic Jams</em> (Resnick)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Resnick" data-secondary="Mitchel"">&nbsp;</a></p>

<p>Now that we understand the core concepts behind autonomous agents, we can begin writing the code.  There are many places where  we could start. Artificial simulations of ant and termite colonies are fantastic demonstrations of systems of autonomous agents. (For more on this topic, I encourage you to read <em>Turtles, Termites, and Traffic Jams</em> by Mitchel Resnick.)  However, we want to begin by examining agent behaviors that build on the work we’ve done in the first five chapters of this book: modeling motion with vectors and driving motion with forces.  And so it’s time to rename our <strong klass>Mover</strong> class that became our <strong klass>Particle</strong> class once again.  This time we are going to call it <strong klass>Vehicle</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {

  PVector location;
  PVector velocity;
  PVector acceleration;

  [inline]// What else do we need to add?</pre>

<p><a data-type="indexterm" data-primary=""Steering Behaviors for Autonomous Characters (Reynolds)"">&nbsp;</a></p>

<p>In his 1999 paper “Steering Behaviors for Autonomous Characters,” Reynolds uses the word “vehicle” to describe his autonomous agents, so we will follow suit.</p>

<p><a data-type="indexterm" data-primary=""<em>Vehicles: Experiments in Synthetic Psychology</em> (Braitenberg)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Braitenberg" data-secondary="Valentino"">&nbsp;</a></p>

<div data-type="note">
<h1>Why Vehicle?</h1><p>In 1986, Italian neuroscientist and cyberneticist Valentino Braitenberg described a series of hypothetical vehicles with simple internal structures in his book <em>Vehicles: Experiments in Synthetic Psychology</em>.  Braitenberg argues that his extraordinarily simple mechanical vehicles manifest behaviors such as fear, aggression, love, foresight, and optimism.  Reynolds took his inspiration from Braitenberg, and we’ll take ours from Reynolds.</p>
</div>
<p>Reynolds describes the motion of <em>idealized</em> vehicles (idealized because we are not concerned with the actual engineering of such vehicles, but simply assume that they exist and will respond to our rules) as a series of three layers—<strong>Action Selection</strong>, <strong>Steering</strong>, and <strong>Locomotion</strong>.</p>

<p><a data-type="indexterm" data-primary=""action selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""action selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""steering"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering force"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>Action Selection.</em></strong>   A vehicle has a goal (or goals) and can select an action (or a combination of actions) based on that goal.  This is essentially where we left off with autonomous agents.  The vehicle takes a look at its environment and calculates an action based on a desire: “I see a zombie marching towards me. Since I don’t want my brains to be eaten, I’m going to flee from the zombie.”   The goal is to keep one’s brains and the action is to flee.   Reynolds’s paper describes many goals and associated actions such as: seek a target, avoid an obstacle, and follow a path.  In a moment, we’ll start building these examples out with Processing code.</p></li>
<li>
<p><strong><em>Steering.</em></strong>  Once an action has been selected, the vehicle has to calculate its next move.  For us, the next move will be a force; more specifically, a steering force.  Luckily, Reynolds has developed a simple steering force formula that we’ll use throughout the examples in this chapter: <strong><em>steering force = desired velocity - current velocity</em></strong>.  We’ll get into the details of this formula and why it works so effectively in the next section.</p></li>
<li>
<p><strong><em>Locomotion.</em></strong>  For the most part, we’re going to ignore this third layer.   In the case of fleeing zombies, the locomotion could be described as “left foot, right foot, left foot, right foot, as fast as you can.”   In our Processing world, however, a rectangle or circle or triangle’s actual movement across a window is irrelevant given that it’s all an illusion in the first place.  Nevertheless, this isn’t to say that you should ignore locomotion entirely.   You will find great value in thinking about the locomotive design of your vehicle and how you choose to animate it.   The examples in this chapter will remain visually bare, and a good exercise would be to elaborate on the animation style —could you add spinning wheels or oscillating paddles or shuffling legs?</p></li>
</ol>

<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""locomotion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""locomotion"">&nbsp;</a></p>

<p>Ultimately, the most important layer for you to consider is #1—<em>Action Selection</em>.  What are the elements of your system and what are their goals?  In this chapter, we are going to look at a series of steering behaviors (i.e. actions): seek, flee, follow a path, follow a flow field, flock with your neighbors, etc.   It’s important to realize, however, that the point of understanding how to write the code for these behaviors is not because you should use them in all of your projects.  Rather, these are a set of building blocks, a foundation from which you can design and develop vehicles with creative goals and new and exciting behaviors.   And even though we will think literally in this chapter (follow that pixel!), you should allow yourself to think more abstractly (like Braitenberg). What would it mean for your vehicle to have “love” or “fear” as its goal, its driving force?    Finally (and we’ll address this later in the chapter), you won’t get very far by developing simulations with only one action.  Yes, our first example will be “seek a target.”  But for you to be creative—to make these steering behaviors <em>your own</em><code>—</code>it will all come down to mixing and matching multiple actions within the same vehicle.  So view these examples not as singular behaviors to be emulated, but as pieces of a larger puzzle that you will eventually assemble.</p>
</section>







<section data-type="sect1" id="chapter06_section3">
<h1>6.3  The Steering Force</h1>
<p><a data-type="indexterm" data-primary=""forces"" data-secondary=""steering"">&nbsp;</a></p>

<p>We can entertain ourselves by discussing the theoretical principles behind autonomous agents and steering as much as we like, but we can’t get anywhere without first understanding the concept of a steering force. Consider the following scenario.  A vehicle moving with velocity desires to seek a target.</p>

<figure id="chapter06_figure1" class="half-width-right">
<img src="imgs/chapter06/ch06_01.png" alt="Figure 6.1"/>
<figcaption/>
</figure>
<p>Its goal and subsequent action is to seek the target in Figure 6.1.  If you think back to Chapter 2, you might begin by making the target an attractor and apply a gravitational force that pulls the vehicle to the target.  This would be a perfectly reasonable solution, but conceptually it’s not what we’re looking for here.   We don’t want to simply calculate a force that pushes the vehicle towards its target; rather, we are asking the vehicle to make an intelligent decision to steer towards the target based on its perception of its state and environment (i.e. how fast and in what direction is it currently moving).   The vehicle should look at how it desires to move (a vector pointing to the target), compare that goal with how quickly it is currently moving (its velocity), and apply a force accordingly.</p>

<p><strong><em>steering force = desired velocity - current velocity</em></strong></p>

<p>Or as we might write in Processing:</p>

<pre data-type="programlisting" data-code-language="java">PVector steer = PVector.sub(desired,velocity);</pre>

<p><a data-type="indexterm" data-primary=""desired velocity"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering force"" data-secondary=""desired velocity"">&nbsp;</a></p>

<p>In the above formula, velocity is no problem.  After all, we’ve got a variable for that.   However, we don’t have the <em>desired velocity</em>; this is something we have to calculate.  Let’s take a look at Figure 6.2.   If we’ve defined the vehicle’s goal as “seeking the target,” then its desired velocity is a vector that points from its current location to the target location.</p>

<figure id="chapter06_figure2">
<img src="imgs/chapter06/ch06_02.png" alt="Figure 6.2"/>
<figcaption/>
</figure>
<p>Assuming a <strong klass>PVector</strong> target, we then have:</p>

<pre data-type="programlisting" data-code-language="java">PVector desired = PVector.sub(target,location);</pre>

<p>But this isn’t particularly realistic.  What if we have a very high-resolution window and the target is thousands of pixels away?  Sure, the vehicle might desire to teleport itself instantly to the target location with a massive velocity, but this won’t make for an effective animation.  What we really want to say is:</p>

<p><em>The vehicle desires to move towards the target at maximum speed.</em></p>

<p>In other words, the vector should point from location to target and with a magnitude equal to maximum speed (i.e. the fastest the vehicle can go).   So first, we need to make sure we add a variable to our <strong klass>Vehicle</strong> class that stores maximum speed.</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Maximum speed
  float maxspeed;</pre>

<p>Then, in our desired velocity calculation, we scale according to maximum speed.</p>

<pre data-type="programlisting" data-code-language="java">PVector desired = PVector.sub(target,location);
desired.normalize();
desired.mult(maxspeed);</pre>

<figure id="chapter06_figure3">
<img src="imgs/chapter06/ch06_03.png" alt="Figure 6.3"/>
<figcaption/>
</figure>
<p>Putting this all together, we can write a function called <strong function>seek()</strong> that receives a <strong klass>PVector</strong> target and calculates a steering force towards that target.</p>

<pre data-type="programlisting" data-code-language="java">  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    // Calculating the desired velocity
    // to target at max speed
    desired.mult(maxspeed);

    // Reynolds’s formula for steering force
    PVector steer = PVector.sub(desired,velocity);
    // Using our physics model and applying the force
    // to the object’s acceleration
    applyForce(steer);
  }</pre>

<p>Note how in the above function we finish by passing the steering force into <strong function>applyForce()</strong>.  This assumes that we are basing this example on the foundation we built in <a href="#chapter02_section2">Chapter 2</a>.  However, you could just as easily use the steering force with Box2D’s <strong function>applyForce()</strong> function or toxiclibs’ <strong function>addForce()</strong> function.</p>

<p>So why does this all work so well?  Let’s see what the steering force looks like relative to the vehicle and target locations.</p>

<figure id="chapter06_figure4">
<img src="imgs/chapter06/ch06_04.png" alt="Figure 6.4"/>
<figcaption/>
</figure>
<p>Again, notice how this is not at all the same force as gravitational attraction.  Remember one of our principles of autonomous agents: An autonomous agent has a <em>limited</em> ability to perceive its environment.  Here is that ability, subtly embedded into Reynolds’s steering formula.  If the vehicle weren’t moving at all (zero velocity), desired minus velocity would be equal to desired.  But this is not the case.  The vehicle is aware of its own velocity and its steering force compensates accordingly.   This creates a more active simulation, as the way in which the vehicle moves towards the targets depends on the way it is moving in the first place.</p>

<p><a data-type="indexterm" data-primary=""steering force"" data-secondary=""magnitude of"">&nbsp;</a></p>

<p>In all of this excitement, however, we’ve missed one last step.  What sort of vehicle is this?  Is it a super sleek race car with amazing handling?  Or a giant Mack truck that needs a lot of advance notice to turn?   A graceful panda, or a lumbering elephant?  Our example code, as it stands, has no feature to account for this variability in steering ability.   Steering ability can be controlled by limiting the magnitude of the steering force.  Let’s call that limit the “maximum force” (or <strong var>maxforce</strong> for short).  And so finally, we have:</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Maximum speed
  float maxspeed;
  // Now we also have maximum force.
  float maxforce;</pre>

<p>followed by:</p>

<pre data-type="programlisting" data-code-language="java">  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);

    // Limit the magnitude of the steering force.
    steer.limit(maxforce);

    applyForce(steer);
  }</pre>

<p>Limiting the steering force brings up an important point.  We must always remember that it’s not actually our goal to get the vehicle to the target as fast as possible.  If that were the case, we would just say “location equals target” and there the vehicle would be.  Our goal, as Reynolds puts it, is to move the vehicle in a “lifelike and improvisational manner.”  We’re trying to make it appear as if the vehicle is steering its way to the target, and so it’s up to us to play with the forces and variables of the system to simulate a given behavior.  For example, a large maximum steering force would result in a very different path than a small one.  One is not inherently better or worse than the other; it depends on your desired effect.  (And of course, these values need not be fixed and could change based on other conditions.  Perhaps a vehicle has health: the higher the health, the better it can steer.)</p>

<figure id="chapter06_figure5">
<img src="imgs/chapter06/ch06_05.png" alt="Figure 6.5"/>
<figcaption/>
</figure>
<p>Here is the full <strong klass>Vehicle</strong> class, incorporating the rest of the elements from the Chapter 2 <strong klass>Mover</strong> object.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_01_Seek/_6_01_Seek.pde processingjs/chapter06/_6_01_Seek/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex1.png" alt="ch06 ex1"/>
<figcaption/>
</figure>
<p><strong example>Example 6.1: Seeking a target</strong></p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // Additional variable for size
  float r;
  float maxforce;
  float maxspeed;

  Vehicle(float x, float y) {
    acceleration = new PVector(0,0);
    velocity = new PVector(0,0);
    location = new PVector(x,y);
    r = 3.0;
    //[full] Arbitrary values for maxspeed and
    // force; try varying these!
    maxspeed = 4;
    maxforce = 0.1;
    //[end]
  }

  // Our standard “Euler integration” motion model
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0);
  }

  // Newton’s second law; we could divide by mass if we wanted.
  void applyForce(PVector force) {
    acceleration.add(force);
  }

  // Our seek steering force algorithm
  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }

  void display() {
    // Vehicle is a triangle pointing in
    // the direction of velocity; since it is drawn
    // pointing up, we rotate it an additional 90 degrees.
    float theta = velocity.heading() + PI/2;
    fill(175);
    stroke(0);
    pushMatrix();
    translate(location.x,location.y);
    rotate(theta);
    beginShape();
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape(CLOSE);
    popMatrix();
  }</pre>

<div id="chapter06_exercise1" data-type="example">
<h5>Exercise 6.1</h5>
<p>Implement a “fleeing” steering behavior (desired vector is inverse of “seek”).</p>
</div>

<div id="chapter06_exercise2" data-type="example">
<h5>Exercise 6.2</h5>
<p>Implement seeking a moving target, often referred to as “pursuit.”  In this case, your desired vector won’t point towards the object’s current location, but rather its “future” location as extrapolated from its current velocity.   We’ll see this ability for a vehicle to “predict the future” in later examples.</p>
</div>

<div id="chapter06_exercise3" data-type="example">
<h5>Exercise 6.3</h5>
<p>Create a sketch where a vehicle’s maximum force and maximum speed do not remain constant, but rather vary according to environmental factors.</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section4">
<h1>6.4  Arriving Behavior</h1>
<p><a data-type="indexterm" data-primary=""arriving behavior"">&nbsp;</a>
<a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""arriving behavior"">&nbsp;</a></p>

<p>After working for a bit with the seeking behavior, you probably are asking yourself,  “What if I want my vehicle to slow down as it approaches the target?”   Before we can even begin to answer this question, we should look at the reasons behind why the seek behavior causes the vehicle to fly past the target so that it has to turn around and go back.  Let’s consider the brain of a seeking vehicle.  What is it thinking?</p>

<p>Frame 1: I want to go as fast as possible towards the target!<br/>
Frame 2: I want to go as fast as possible towards the target!<br/>
Frame 3: I want to go as fast as possible towards the target!<br/>
Frame 4: I want to go as fast as possible towards the target!<br/>
Frame 5: I want to go as fast as possible towards the target!<br/>
etc.</p>

<p>The vehicle is so gosh darn excited about getting to the target that it doesn’t bother to make any intelligent decisions about its speed relative to the target’s proximity.  Whether it’s far away or very close, it always wants to go as fast as possible.</p>

<figure id="chapter06_figure6">
<img src="imgs/chapter06/ch06_06.png" alt="Figure 6.6"/>
<figcaption/>
</figure>
<p>In some cases, this is the desired behavior (if a missile is flying at a target, it should always travel at maximum speed.)  However, in many other cases (a car pulling into a parking spot, a bee landing on a flower), the vehicle’s thought process needs to consider its speed relative to the distance from its target.  For example:</p>

<p>Frame 1: I’m very far away. I want to go as fast as possible towards the target!<br/>
Frame 2: I’m very far away. I want to go as fast as possible towards the target!<br/>
Frame 3: I’m somewhat far away. I want to go as fast as possible towards the target!<br/>
Frame 4: I’m getting close. I want to go more slowly towards the target!<br/>
Frame 5: I’m almost there. I want to go very slowly towards the target!<br/>
Frame 6: I’m there. I want to stop!</p>

<figure id="chapter06_figure7">
<img src="imgs/chapter06/ch06_07.png" alt="Figure 6.7"/>
<figcaption/>
</figure>
<p>How can we implement this “arriving” behavior in code?  Let’s return to our <strong function>seek()</strong> function and find the line of code where we set the magnitude of the desired velocity.</p>

<pre data-type="programlisting" data-code-language="java">   PVector desired = PVector.sub(target,location);
   desired.normalize();
   desired.mult(maxspeed);</pre>

<p>In Example 6.1, the magnitude of the desired vector is always “maximum” speed.</p>

<figure id="chapter06_figure8">
<img src="imgs/chapter06/ch06_08.png" alt="Figure 6.8"/>
<figcaption/>
</figure>
<p>What if we instead said the desired velocity is equal to half the distance?</p>

<figure id="chapter06_figure9">
<img src="imgs/chapter06/ch06_09.png" alt="Figure 6.9"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">   PVector desired = PVector.sub(target,location);
   desired.div(2);</pre>

<p>While this nicely demonstrates our goal of a desired speed tied to our distance from the target, it’s not particularly reasonable.  After all, 10 pixels away is rather close and a desired speed of 5 is rather large.   Something like a desired velocity with a magnitude of 5% of the distance would work much better.</p>

<pre data-type="programlisting" data-code-language="java">  PVector desired = PVector.sub(target,location);
  desired.mult(0.05);</pre>

<p>Reynolds describes a more sophisticated approach.  Let’s imagine a circle around the target with a given radius.  If the vehicle is within that circle, it slows down—at the edge of the circle, its desired speed is maximum speed, and at the target itself, its desired speed is 0.</p>

<figure id="chapter06_figure10">
<img src="imgs/chapter06/ch06_10.png" alt="Figure 6.10"/>
<figcaption/>
</figure>
<p>In other words, if the distance from the target is less than r, the desired speed is between 0 and maximum speed mapped according to that distance.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_02_Arrive/_6_02_Arrive.pde processingjs/chapter06/_6_02_Arrive/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex2.png" alt="ch06 ex2"/>
<figcaption/>
</figure>
<p><strong example>Example 6.2: Arrive steering behavior</strong></p>

<pre data-type="programlisting" data-code-language="java">  void arrive(PVector target) {
    PVector desired = PVector.sub(target,location);

    // The distance is the magnitude of
    // the vector pointing from
    // location to target.
    float d = desired.mag();
    desired.normalize();
    // If we are closer than 100 pixels...
    if (d &lt; 100) {
      //[full] ...set the magnitude
      // according to how close we are.
      float m = map(d,0,100,0,maxspeed);
      desired.mult(m);
      //[end]
    } else {
      // Otherwise, proceed at maximum speed.
      desired.mult(maxspeed);
    }

    // The usual steering = desired - velocity
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }</pre>

<p>The arrive behavior is a great demonstration of the magic of “desired minus velocity.”   Let’s examine this model again relative to how we calculated forces in earlier chapters.   In the “gravitational attraction” examples, the force always pointed directly from the object to the target (the exact direction of the desired velocity), whether the force was strong or weak.</p>

<p><a data-type="indexterm" data-primary=""arriving behavior"" data-secondary=""steering force and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering force"" data-secondary=""arriving behavior and"">&nbsp;</a></p>

<p>The steering function, however, says: “I have the ability to perceive the environment.”  The force isn’t based on just the desired velocity, but on the desired velocity relative to the current velocity.  Only things that are alive can know their current velocity.  A box falling off a table doesn’t know it’s falling.  A cheetah chasing its prey, however, knows it is chasing.</p>

<p>The steering force, therefore, is essentially a manifestation of the current velocity’s <strong><em>error</em></strong>:  "I’m supposed to be going this fast in this direction, but I’m actually going this fast in another direction.   My error is the difference between where I want to go and where I am currently going."  Taking that error and applying it as a steering force results in more dynamic, lifelike simulations.   With gravitational attraction, you would never have a force pointing away from the target, no matter how close. But with arriving via steering, if you are moving too fast towards the target, the error would actually tell you to slow down!</p>

<figure id="chapter06_figure11">
<img src="imgs/chapter06/ch06_11.png" alt="Figure 6.11"/>
<figcaption/>
</figure></section>







<section data-type="sect1" id="chapter06_section5">
<h1>6.5 Your Own Desires: Desired Velocity</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""desired velocity"">&nbsp;</a>
<a data-type="indexterm" data-primary=""desired velocity"">&nbsp;</a>
<a data-type="indexterm" data-primary=""velocity"" data-secondary=""desired" data-tertiary="for autonomous agents"">&nbsp;</a></p>

<p>The first two examples we’ve covered—seek and arrive—boil down to calculating a single vector for each behavior: the <em>desired</em> velocity.  And in fact, every single one of Reynolds’s steering behaviors follows this same pattern.  In this chapter, we’re going to walk through several more of Reynolds’s behaviors—flow field, path-following, flocking.  First, however, I want to emphasize again that these are <em>examples</em>—demonstrations of common steering behaviors that are useful in procedural animation.   They are not the be-all and end-all of what <em>you</em> can do.  As long as you can come up with a vector that describes a vehicle’s <em>desired</em> velocity, then you have created your own steering behavior.</p>

<p>Let’s see how Reynolds defines the desired velocity for his wandering behavior.</p>

<p><a data-type="indexterm" data-primary=""wandering behavior (Reynolds)"">&nbsp;</a></p>

<blockquote >
“Wandering is a type of random steering which has some long term order: the steering direction on one frame is related to the steering direction on the next frame. This produces more interesting motion than, for example, simply generating a random steering direction each frame.”
<span class="attribution">
<a href="http://www.red3d.com/cwr/steer/Wander.html">—Craig Reynolds</a>
</span>
</blockquote>
<figure id="chapter06_figure12" class="half-width-right">
<img src="imgs/chapter06/ch06_12.png" alt="Figure 6.12"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""steering behaviors"" data-secondary=""wandering"">&nbsp;</a></p>

<p>For Reynolds, the goal of wandering is not simply random motion, but rather a sense of moving in one direction for a little while, wandering off to the next for a little bit, and so on and so forth.  So how does Reynolds calculate a desired vector to achieve such an effect?</p>

<p>Figure 6.12 illustrates how the vehicle predicts its future location as a fixed distance in front of it (in the direction of its velocity), draws a circle with radius <strong var>r</strong> at that location, and picks a random point along the circumference of the circle.  That random point moves randomly around the circle in each frame of animation.   And that random point is the vehicle’s target, its desired vector pointing in that direction.</p>

<p>Sounds a bit absurd, right?  Or, at the very least, rather arbitrary.   In fact, this is a very clever and thoughtful solution—it uses randomness to drive a vehicle’s steering, but constrains that randomness along the path of a circle to keep the vehicle’s movement from appearing jittery, and, well, random.</p>

<p>But the seemingly random and arbitrary nature of this solution should drive home the point I’m trying to make—these are made-up behaviors inspired by real-life motion.  You can just as easily concoct some elaborate scenario to compute a desired velocity yourself.  And you should.</p>

<div id="chapter06_exercise4" data-type="example">
<h5>Exercise 6.4</h5>
<p>Write the code for Reynolds&#8217;s wandering behavior.  Use polar coordinates to calculate the vehicle’s target along a circular path.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/Ex_6_04_Wander/Ex_6_04_Wander.pde processingjs/chapter06/Ex_6_04_Wander/Vehicle.pde">
<img src="imgs/chapter06/ch06_exc4.png" alt="ch06 exc4"/>
<figcaption/>
</figure></div>

<p>Let’s say we want to create a steering behavior called “stay within walls.”  We’ll define the desired velocity as:</p>

<p><strong><em>If a vehicle comes within a distance</em></strong> d <strong><em>of a wall, it desires to move at maximum speed in the opposite direction of the wall.</em></strong></p>

<figure id="chapter06_figure13">
<img src="imgs/chapter06/ch06_13.png" alt="Figure 6.13"/>
<figcaption/>
</figure>
<p>If we define the walls of the space as the edges of a Processing window and the distance <strong var>d</strong> as 25, the code is rather simple.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_03_StayWithinWalls/_6_03_StayWithinWalls.pde processingjs/chapter06/_6_03_StayWithinWalls/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex3.png" alt="ch06 ex3"/>
<figcaption/>
</figure>
<p><strong example>Example 6.3: “Stay within walls” steering behavior</strong></p>

<pre data-type="programlisting" data-code-language="java">if (location. x &gt; 25) {
  //[offset-down] Make a desired vector that retains the y direction of
  // the vehicle but points the x direction directly away from
  // the window’s left edge.
  PVector desired = new PVector(maxspeed,velocity.y);
  PVector steer = PVector.sub(desired, velocity);
  steer.limit(maxforce);
  applyForce(steer);
}</pre>

<div id="chapter06_exercise5" data-type="example">
<h5>Exercise 6.5</h5>
<p>Come up with your own arbitrary scheme for calculating a desired velocity.</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section6">
<h1>6.6  Flow Fields</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""flow field following"">&nbsp;</a>
<a data-type="indexterm" data-primary=""flow field following"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering behaviors"" data-secondary=""flow field following"">&nbsp;</a></p>

<p>Now back to the task at hand.  Let’s examine a couple more of Reynolds’s steering behaviors.  First, <strong><em>flow field following</em></strong>.  What is a flow field?   Think of your Processing window as a grid.  In each cell of the grid lives an arrow pointing in some direction—you know, a vector.   As a vehicle moves around the screen, it asks, “Hey, what arrow is beneath me?  That’s my desired velocity!”</p>

<figure id="chapter06_figure14">
<img src="imgs/chapter06/ch06_14.png" alt="Figure 6.14"/>
<figcaption/>
</figure>
<p>Reynolds’s flow field following example has the vehicle predicting its future location and following the vector at that spot, but for simplicity’s sake, we’ll have the vehicle simply look to the vector at its current location.</p>

<p><a data-type="indexterm" data-primary=""arrays (2D)"">&nbsp;</a></p>

<p>Before we can write the additional code for our <strong klass>Vehicle</strong> class, we’ll need to build a class that describes the flow field itself, the grid of vectors.   A two-dimensional array is a convenient data structure in which to store a grid of information. If you are not familiar with 2D arrays, I suggest reviewing this online Processing tutorial: <a href="http://processing.org/learning/2darray/">2D array</a>.   The 2D array is convenient because we reference each element with two indices, which we can think of as columns and rows.</p>

<pre data-type="programlisting" data-code-language="java">class FlowField {

  // Declaring a 2D array of PVectors
  PVector[][] field;
  // How many columns and how many rows in the grid?
  int cols, rows;
  // Resolution of grid relative to window
  // width and height in pixels
  int resolution;</pre>

<p><a data-type="indexterm" data-primary=""flow field following"" data-secondary=""resolution and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""resolution" data-secondary="flow field following and"">&nbsp;</a></p>

<p>Notice how we are defining a third variable called <strong var>resolution</strong> above.   What is this variable?  Let’s say we have a Processing window that is 200 pixels wide by 200 pixels high.  We could make a flow field that has a <strong klass>PVector</strong> object for every single pixel, or 40,000 <strong klass>PVector</strong><code>s</code> (200 * 200).  This isn’t terribly unreasonable, but in our case, it’s overkill.  We don’t need a <strong klass>PVector</strong> for every single pixel; we can achieve the same effect by having, say, one every ten pixels (20 * 20 = 400).   We use this resolution to define the number of columns and rows based on the size of the window divided by resolution:</p>

<pre data-type="programlisting" data-code-language="java">  FlowField() {
    resolution = 10;
    // Total columns equals width divided by resolution.
    cols = width/resolution;
    // Total rows equals height divided by resolution.
    rows = height/resolution;
    field = new PVector[cols][rows];
  }</pre>

<p><a data-type="indexterm" data-primary=""vectors"" data-secondary=""flow fields" data-tertiary="computing for"">&nbsp;</a></p>

<p>Now that we’ve set up the flow field’s data structures, it’s time to compute the vectors in the flow field itself.  How do we do that? However we feel like it!  Perhaps we want to have every vector in the flow field pointing to the right.</p>

<figure id="chapter06_figure15">
<img src="imgs/chapter06/ch06_15.png" alt="Figure 6.15"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">//[full] Using a nested loop to hit every column
// and every row of the flow field
for (int i = 0; i &lt; cols; i++) {
  for (int j = 0; j &lt; rows; j++) {
  //[end]
    // Arbitrary decision to make each vector point to the right
    field[i][j] = new PVector(1,0);
  }
}</pre>

<p>Or perhaps we want the vectors to point in random directions.</p>

<figure id="chapter06_figure16">
<img src="imgs/chapter06/ch06_16.png" alt="Figure 6.16"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; cols; i++) {
  for (int j = 0; j &lt; rows; j++) {

    // A random PVector
    field[i][j] = PVector.2D();
  }
}</pre>

<p>What if we use 2D Perlin noise (mapped to an angle)?</p>

<p><a data-type="indexterm" data-primary=""Perlin noise"" data-secondary=""flow field following and"">&nbsp;</a></p>

<figure id="chapter06_figure17">
<img src="imgs/chapter06/ch06_17.png" alt="Figure 6.17"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">float xoff = 0;
for (int i = 0; i &lt; cols; i++) {
  float yoff = 0;
  for (int j = 0; j &lt; rows; j++) {
    //[offset-up] Noise
    float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
    field[i][j] = new PVector(cos(theta),sin(theta));
    yoff += 0.1;
  }
  xoff += 0.1;
}</pre>

<p>Now we’re getting somewhere.   Flow fields can be used for simulating various effects, such as an irregular gust of wind or the meandering path of a river.  Calculating the direction of your vectors using Perlin noise is one way to achieve such an effect.  Of course, there’s no “correct” way to calculate the vectors of a flow field; it’s really up to you to decide what you’re looking to simulate.</p>

<div id="chapter06_exercise6" data-type="example">
<h5>Exercise 6.6</h5>
<p>Write the code to calculate a <strong klass>PVector</strong> at every location in the flow field that points towards the center of a window.</p>

<figure>
<img src="imgs/chapter06/ch06_exc6.png" alt="ch06 exc6"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(____________,____________);
v.______________();
field[i][j] = v;</pre>
</div>

<p>Now that we have a two-dimensional array storing all of the flow field vectors, we need a way for a vehicle to look up its desired vector in the flow field.    Let’s say we have a vehicle that lives at a <strong klass>PVector</strong>: its location.  We first need to divide by the resolution of the grid.  For example, if the resolution is 10 and the vehicle is at <em>(100,50)</em>, we need to look up column 10 and row 5.</p>

<pre data-type="programlisting" data-code-language="java">int column = int(location.x/resolution);
int row = int(location.y/resolution);</pre>

<p><a data-type="indexterm" data-primary=""constrain() function (Processing)"">&nbsp;</a></p>

<p>Because a vehicle could theoretically wander off the Processing window, it’s also useful for us to employ the <strong function>constrain()</strong> function to make sure we don’t look outside of the flow field array.  Here is a function we’ll call <strong function>lookup()</strong> that goes in the <strong klass>FlowField</strong> class—it receives a <strong klass>PVector</strong> (presumably the location of our vehicle) and returns the corresponding flow field <strong klass>PVector</strong> for that location.</p>

<pre data-type="programlisting" data-code-language="java">  PVector lookup(PVector lookup) {
    //[full]
    // Using constrain()

    int column = int(constrain(lookup.x/resolution,0,cols-1));
    int row = int(constrain(lookup.y/resolution,0,rows-1));
    //[end]
    // Note the use of get() to ensure
    // we return a copy of the PVector.
    return field[column][row].get();
  }</pre>

<p>Before we move on to the <strong klass>Vehicle</strong> class, let’s take a look at the <strong klass>FlowField</strong> class all together.</p>

<pre data-type="programlisting" data-code-language="java">class FlowField {

  // A flow field is a two-dimensional array of PVectors.
  PVector[][] field;
  int cols, rows;
  int resolution;

  FlowField(int r) {
    resolution = r;
    //[full] Determine the number of columns and rows.
    cols = width/resolution;
    rows = height/resolution;
    //[end]
    field = new PVector[cols][rows];
    init();
  }

  void init() {
    float xoff = 0;
    for (int i = 0; i &lt; cols; i++) {
      float yoff = 0;
      for (int j = 0; j &lt; rows; j++) {
        //[offset-up] In this example, we use Perlin noise to seed the vectors.
        float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
        //[offset-down] Polar to Cartesian coordinate transformation to get x and y components of the vector
        field[i][j] = new PVector(cos(theta),sin(theta));
        yoff += 0.1;
      }
      xoff += 0.1;
    }
  }

  //[full] A function to return a PVector based on a location
  PVector lookup(PVector lookup) {

    int column = int(constrain(lookup.x/resolution,0,cols-1));
    int row = int(constrain(lookup.y/resolution,0,rows-1));
    return field[column][row].get();
  }
  //[end]
}</pre>

<p>So let’s assume we have a <strong klass>FlowField</strong> object called “flow”.  Using the <strong function>lookup()</strong> function above, our vehicle can then retrieve a desired vector from the flow field and use Reynolds’s rules (steering = desired - velocity) to calculate a steering force.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_04_Flowfield/_6_04_Flowfield.pde processingjs/chapter06/_6_04_Flowfield/Flowfield.pde processingjs/chapter06/_6_04_Flowfield/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex4.png" alt="ch06 ex4"/>
<figcaption/>
</figure>
<p><strong example>Example 6.4: Flow field following</strong></p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {

  void follow(FlowField flow) {
    // What is the vector at that spot in the flow field?
    PVector desired = flow.lookup(location);
    desired.mult(maxspeed);

    // Steering is desired minus velocity
    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }</pre>

<div id="chapter06_exercise7" data-type="example">
<h5>Exercise 6.7</h5>
<p>Adapt the flow field example so that the <strong klass>PVector</strong><code>s</code> change over time. (Hint: try using the third dimension of Perlin noise!)</p>
</div>

<div id="chapter06_exercise8" data-type="example">
<h5>Exercise 6.8</h5>
<p>Can you seed a flow field from a <strong klass>PImage</strong>?  For example, try having the <strong klass>PVector</strong><code>s</code> point from dark to light colors (or vice versa).</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section7">
<h1>6.7  The Dot Product</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""dot product"">&nbsp;</a>
<a data-type="indexterm" data-primary=""dot product (PVector)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""vectors"" data-secondary=""dot product"">&nbsp;</a></p>

<p>In a moment, we’re going to work through the algorithm (along with accompanying mathematics) and code for another of Craig Reynolds’s steering behaviors: <a href="http://www.red3d.com/cwr/steer/PathFollow.html">Path Following</a>.  Before we can do this, however, we have to spend some time learning about another piece of vector math that we skipped in Chapter 1—the dot product.  We haven’t needed it yet, but it’s likely going to prove quite useful for you (beyond just this path-following example), so we’ll go over it in detail now.</p>

<p>Remember all the basic vector math we covered in Chapter 1?  Add, subtract, multiply, and divide?</p>

<figure id="chapter06_figure18">
<img src="imgs/chapter06/ch06_18.png" alt="Figure 6.18"/>
<figcaption/>
</figure>
<p>Notice how in the above diagram, vector multiplication involves multiplying a vector by a scalar value.  This makes sense; when we want a vector to be twice as large (but facing the same direction), we multiply it by 2.  When we want it to be half the size, we multiply it by 0.5.</p>

<p><a data-type="indexterm" data-primary=""dot product (PVector)"" data-secondary=""defined"">&nbsp;</a></p>

<p>However, there are two other <em>multiplication-like</em> operations with vectors that are useful in certain scenarios—the dot product and the cross product. For now we’re going to focus on the dot product, which is defined as follows.  Assume vectors <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><msub><mrow><mi> a </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> , </mo><msub><mrow><mi> a </mi></mrow><mrow><mi> y </mi></mrow></msub></mrow></mfenced></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><msub><mrow><mi> b </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> , </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> y </mi></mrow></msub></mrow></mfenced></mstyle></math></p>

<p>THE DOT PRODUCT: <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> a </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> + </mo><msub><mrow><mi> a </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> y </mi></mrow></msub></mstyle></math></p>

<p>For example, if we have the following two vectors:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mo> - </mo><mn> 3 </mn><mo> , </mo><mn> 5 </mn></mrow></mfenced></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mn> 10 </mn><mo> , </mo><mn> 1 </mn></mrow></mfenced></mstyle></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> - </mo><mn> 3 </mn><mo> * </mo><mn> 10 </mn><mo> + </mo><mn> 5 </mn><mo> * </mo><mn> 1 </mn><mo> = </mo><mo> - </mo><mn> 30 </mn><mo> + </mo><mn> 5 </mn><mo> = </mo><mn> 35 </mn></mstyle></math></p>

<p>Notice that the result of the dot product is a scalar value (a single number) and not a vector.</p>

<p>In Processing, this would translate to:</p>

<pre data-type="programlisting" data-code-language="java">PVector a = new PVector(-3,5);
PVector b = new PVector(10,1);

// The PVector class includes a
// function to calculate the dot product.
float n = a.dot(b);</pre>

<p>And if we were to look in the guts of the <strong klass>PVector</strong> source, we’d find a pretty simple implementation of this function:</p>

<pre data-type="programlisting" data-code-language="java">public float dot(PVector v) {
  return x*v.x + y*v.y + z*v.z;
}</pre>

<p>This is simple enough, but why do we need the dot product, and when is it going to be useful for us in code?</p>

<p>One of the more common uses of the dot product is to find the angle between two vectors.   Another way in which the dot product can be expressed is:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<p><a data-type="indexterm" data-primary=""dot product (PVector)"" data-secondary=""theta"">&nbsp;</a>
<a data-type="indexterm" data-primary=""theta (θ)"" data-secondary=""dot product and"">&nbsp;</a></p>

<p>In other words, A dot B is equal to the magnitude of A times magnitude of B times cosine of theta (with theta defined as <em>the angle between the two vectors A and B</em>).</p>

<p>The two formulas for dot product can be derived from one another with <a href="http://mathworld.wolfram.com/DotProduct.html">trigonometry</a>, but for our purposes we can be happy with operating on the assumption that:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> a </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> + </mo><msub><mrow><mi> a </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> y </mi></mrow></msub></mstyle></math></p>

<p>both hold true and therefore:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msub><mrow><mi> a </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> x </mi></mrow></msub><mo> + </mo><msub><mrow><mi> a </mi></mrow><mrow><mi> y </mi></mrow></msub><mo> * </mo><msub><mrow><mi> b </mi></mrow><mrow><mi> y </mi></mrow></msub></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<figure id="chapter06_figure19" class="half-width-right">
<img src="imgs/chapter06/ch06_19.png" alt="Figure 6.19"/>
<figcaption/>
</figure>
<p>Now, let’s start with the following problem. We have the vectors A and B:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mn> 10 </mn><mo> , </mo><mn> 2 </mn></mrow></mfenced></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mfenced><mrow><mn> 4 </mn><mo> , </mo><mo> - </mo><mn> 3 </mn></mrow></mfenced></mstyle></math></p>

<p>We now have a situation in which we know everything except for theta.   We know the components of the vector and can calculate the magnitude of each vector.  We can therefore solve for cosine of theta:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> / </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math></p>

<p>To solve for theta, we can take the inverse cosine (often expressed as <em>cosine<sup>-1</sup></em> or <em>arccosine</em>).</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03B8; </mi></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msup><mrow><mi> cos </mi></mrow><mrow><mo> - </mo><mn> 1 </mn></mrow></msup></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> / </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math></p>

<p>Let’s now do the math with actual numbers:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 10.2 </mn></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 5 </mn></mstyle></math></p>

<p>Therefore:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03B8; </mi></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msup><mrow><mi> cos </mi></mrow><mrow><mo> - </mo><mn> 1 </mn></mrow></msup></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 10 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 4 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> + </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 2 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> -3 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> / </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 10.2 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 5 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03B8; </mi></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><msup><mrow><mi> cos </mi></mrow><mrow><mo> - </mo><mn> 1 </mn></mrow></msup></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ( </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 34 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> / </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 51 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> ) </mo></mstyle></math><br/>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> &#x03B8; </mi></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x223C; </mo><mn> 4 </mn><msup><mrow><mn> 8 </mn></mrow><mrow><mo> &#x2218; </mo></mrow></msup></mstyle></math></p>

<p>The Processing version of this would be:</p>

<pre data-type="programlisting" data-code-language="java">PVector a = new PVector(10,2);
PVector b = new PVector(4,-3);
float theta = acos(a.dot(b) / (a.mag() * b.mag()));</pre>

<p>And, again, if we were to dig into the guts of the Processing source code, we would see a function that implements this exact algorithm.</p>

<pre data-type="programlisting" data-code-language="java">  static public float angleBetween(PVector v1, PVector v2) {
    float dot = v1.dot(v2);
    float theta = (float) Math.acos(dot / (v1.mag() * v2.mag()));
    return theta;
  }</pre>

<div id="chapter06_exercise9" data-type="example">
<h5>Exercise 6.9</h5>
<figure class="half-width-right">
<img src="imgs/chapter06/ch06_exc9.png" alt="ch06 exc9"/>
<figcaption/>
</figure>
<p>Create a sketch that displays the angle between two <strong klass>PVector</strong> objects.</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<p>A couple things to note here:</p>

<ol>
<li>
<p>If two vectors (<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>) are orthogonal (i.e. perpendicular), the dot product (<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>) is equal to 0.</p></li>
<li>
<p>If two vectors are unit vectors, then the dot product is simply equal to cosine of the angle between them, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math> if <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> are of length 1.</p></li>
</ol>
</section>







<section data-type="sect1" id="chapter06_section8">
<h1>6.8  Path Following</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""path following"">&nbsp;</a>
<a data-type="indexterm" data-primary=""path following"">&nbsp;</a>
<a data-type="indexterm" data-primary=""path following"" data-secondary=""pathfinding vs."">&nbsp;</a>
<a data-type="indexterm" data-primary=""pathfinding"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Reynolds" data-secondary="Craig"" data-tertiary=""path following algorithm"">&nbsp;</a></p>

<p>Now that we’ve got a basic understanding of the dot product under our belt, we can return to a discussion of Craig Reynolds’s path-following algorithm.     Let’s quickly clarify something.  We are talking about path <em>following</em>, not path <em>finding</em>.  Pathfinding refers to a research topic (commonly studied in artificial intelligence) that involves solving for the shortest distance between two points, often in a maze.   With <strong><em>path following</em></strong>, the path already exists and we’re asking a vehicle to follow that path.</p>

<p>Before we work out the individual pieces, let’s take a look at the overall algorithm for path following, as defined by Reynolds.</p>

<figure id="chapter06_figure20">
<img src="imgs/chapter06/ch06_20.png" alt="Figure 6.20"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""path"">&nbsp;</a></p>

<p>We&#8217;ll first define what we mean by a path.  There are many ways we could implement a path, but for us, a simple way will be to define a path as a series of connected points:</p>

<figure id="chapter06_figure21">
<img src="imgs/chapter06/ch06_21.png" alt="Figure 6.21: Path"/>
<figcaption/>
</figure>
<p>An even simpler path would be a line between two points.</p>

<figure id="chapter06_figure22">
<img src="imgs/chapter06/ch06_22.png" alt="Figure 6.22: Simple path"/>
<figcaption/>
</figure>
<p>We’re also going to consider a path to have a radius.  If we think of the path as a road, the radius determines the road’s width.  With a smaller radius, our vehicles will have to follow the path more closely; a wider radius will allow them to stray a bit more.</p>

<p>Putting this into a class, we have:</p>

<figure class="screenshot">
<img src="imgs/chapter06/ch06_ex5_a.png" alt="ch06 ex5 a"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">class Path {

  //[full] A path is only two points, start and end.
  PVector start;
  PVector end;
  //[end]

  // A path has a radius, i.e. how wide it is.
  float radius;

  Path() {
    // Picking some arbitrary values to initialize the path
    radius = 20;
    start = new PVector(0,height/3);
    end = new PVector(width,2*height/3);
  }

  void display() {  // Display the path.
    strokeWeight(radius*2);
    stroke(0,100);
    line(start.x,start.y,end.x,end.y);
    strokeWeight(1);
    stroke(0);
    line(start.x,start.y,end.x,end.y);
  }
}</pre>

<p>Now, let’s assume we have a vehicle (as depicted below) outside of the path’s radius, moving with a velocity.</p>

<figure id="chapter06_figure23">
<img src="imgs/chapter06/ch06_23.png" alt="Figure 6.23"/>
<figcaption/>
</figure>
<p>The first thing we want to do is predict, assuming a constant velocity, where that vehicle will be in the future.</p>

<pre data-type="programlisting" data-code-language="java">// Start by making a copy of the velocity.
PVector predict = vel.get();

//[full] Normalize it and look 25 pixels
// ahead by scaling the vector up.
predict.normalize();
predict.mult(25);
//[end]

// Add vector to location to find the
// predicted location.
PVector predictLoc = PVector.add(loc, predict);</pre>

<p><a data-type="indexterm" data-primary=""path following"" data-secondary=""current distance from path" data-tertiary="finding"">&nbsp;</a></p>

<p>Once we have that location, it’s now our job to find out the vehicle&#8217;s current distance from the path of that predicted location.  If it’s very far away, well, then, we’ve strayed from the path and need to steer back towards it.  If it’s close, then we’re doing OK and are following the path nicely.</p>

<p>So, how do we find the distance between a point and a line?  This concept is key.  The distance between a point and a line is defined as the length of the normal between that point and line.  The normal is a vector that extends from that point and is perpendicular to the line.</p>

<figure id="chapter06_figure24">
<img src="imgs/chapter06/ch06_24.png" alt="Figure 6.24"/>
<figcaption/>
</figure>
<p>Let’s figure out what we do know.    We know we have a vector (call it <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>) that extends from the path’s starting point to the vehicle’s predicted location.</p>

<pre data-type="programlisting" data-code-language="java">PVector a = PVector.sub(predictLoc,path.start);</pre>

<p>We also know that we can define a vector (call it <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math>) that points from the start of the path to the end.</p>

<pre data-type="programlisting" data-code-language="java">PVector b = PVector.sub(path.end,path.start);</pre>

<p>Now, with basic trigonometry, we know that the distance from the path’s start to the normal point is: <strong formula>|A| * cos(theta)</strong>.</p>

<figure id="chapter06_figure25">
<img src="imgs/chapter06/ch06_25.png" alt="Figure 6.25"/>
<figcaption/>
</figure>
<p>If we knew theta, we could easily define that normal point as follows:</p>

<pre data-type="programlisting" data-code-language="java">// The distance from START to NORMAL
float d = a.mag()*cos(theta);
b.normalize();
// Scale PVector b to that distance.
b.mult(d);
// The normal point can be found by adding
// the scaled version of b to the path’s
// starting point.
PVector normalPoint = PVector.add(path.start,b);</pre>

<p>And if the dot product has taught us anything, it’s that given two vectors, we can get theta, the angle between.</p>

<pre data-type="programlisting" data-code-language="java">// What is theta?  The angle between A and B
float theta = PVector.angleBetween(a,b);
b.normalize();
b.mult(a.mag()*cos(theta));
PVector normalPoint = PVector.add(path.start,b);</pre>

<p>While the above code will work, there’s one more simplification we can make.   If you’ll notice, the desired magnitude for vector <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> is:</p>

<p><strong formula>a.mag()*cos(theta)</strong></p>

<p>which is the code translation of:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<p>And if you recall:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<p>Now, what if vector <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> is a unit vector, i.e. length 1?  Then:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mn> 1 </mn></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<p>or</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x00B7; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mover><mrow><mi> B </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> = </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> &#x2225; </mo><mover><mrow><mi> A </mi></mrow><mrow><mo> &#x2192; </mo></mrow></mover><mo> &#x2225; </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo> * </mo></mstyle></math> <math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi> cos </mi><mfenced><mrow><mi> &#x03B8; </mi></mrow></mfenced></mstyle></math></p>

<p>And what are we doing in our code?  Normalizing b!</p>

<pre data-type="programlisting" data-code-language="java">b.normalize();</pre>

<p>Because of this fact, we can simplify our code as:</p>

<pre data-type="programlisting" data-code-language="java">float theta = PVector.angleBetween(a,b); //[line-through]

b.normalize();
// We can use the dot product to scale b’s length.
b.mult(a.dot(b));

PVector normalPoint = PVector.add(path.start,b);</pre>

<p><a data-type="indexterm" data-primary=""scalar projection"">&nbsp;</a></p>

<p>This process is commonly known as “scalar projection.”  <strong><em>|A| cos(θ) is the scalar projection of A onto B.</em></strong></p>

<figure id="chapter06_figure26">
<img src="imgs/chapter06/ch06_26.png" alt="Figure 6.26"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""normal points"">&nbsp;</a>
<a data-type="indexterm" data-primary=""path following"" data-secondary=""normal points"">&nbsp;</a></p>

<p>Once we have the normal point along the path, we have to decide whether the vehicle should steer towards the path and how.  Reynolds’s algorithm states that the vehicle should only steer towards the path if it strays beyond the path (i.e., if the distance between the normal point and the predicted future location is greater than the path radius).</p>

<figure id="chapter06_figure27">
<img src="imgs/chapter06/ch06_27.png" alt="Figure 6.27"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">float distance = PVector.dist(predictLoc, normalPoint);

// If the vehicle is outside the path,
// seek the target.
if (distance &gt; path.radius) {
  // We don’t have to work out the desired velocity and
  // steering force; all that is taken care of by seek(),
  // which we already wrote in Example 6.1.
  seek(target);
}</pre>

<p>But what is the target?</p>

<p><a data-type="indexterm" data-primary=""path following"" data-secondary=""target" data-tertiary="determining"">&nbsp;</a></p>

<p>Reynolds’s algorithm involves picking a point ahead of the normal on the path (see step #3 above).  But for simplicity, we could just say that the target is the normal itself. This will work fairly well:</p>

<pre data-type="programlisting" data-code-language="java">float distance = PVector.dist(predictLoc, normalPoint);
if (distance &gt; path.radius) {
  // Seek the normal point on the path.
  seek(normalPoint);
}</pre>

<p>Since we know the vector that defines the path (we’re calling it “B”), we can implement Reynolds’s “point ahead on the path” without too much trouble.</p>

<figure id="chapter06_figure28">
<img src="imgs/chapter06/ch06_28.png" alt="Figure 6.28"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">float distance = PVector.dist(predictLoc, normalPoint);
if (distance &gt; path.radius) {
  //[full] Normalize and scale b (pick 25 pixels arbitrarily).
  b.normalize();
  b.mult(25);
  //[end]
  // By adding b to normalPoint, we now move
  // 25 pixels ahead on the path.
  PVector target = PVector.add(normalPoint,b);

  seek(target);
}</pre>

<p>Putting it all together, we have the following steering function in our <strong klass>Vehicle</strong> class.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_05_PathFollowingSimple/_6_05_PathFollowingSimple.pde processingjs/chapter06/_6_05_PathFollowingSimple/Path.pde processingjs/chapter06/_6_05_PathFollowingSimple/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex5.png" alt="ch06 ex5"/>
<figcaption/>
</figure>
<p><strong example>Example 6.5: Simple path following</strong></p>

<pre data-type="programlisting" data-code-language="java">  void follow(Path p) {

    //[full] Step 1: Predict the vehicle’s future location.
    PVector predict = vel.get();
    predict.normalize();
    predict.mult(25);
    PVector predictLoc = PVector.add(loc, predict);
    //[end]

    //[full] Step 2: Find the normal point along the path.
    PVector a = p.start;
    PVector b = p.end;
    PVector normalPoint = getNormalPoint(predictLoc, a, b);
    //[end]

    //[full] Step 3: Move a little further along the path and set a target.
    PVector dir = PVector.sub(b, a);
    dir.normalize();
    dir.mult(10);
    PVector target = PVector.add(normalPoint, dir);
    //[end]

    //[full] Step 4: If we are off the path,
    // seek that target in order to stay on the path.
    float distance =
      PVector.dist(normalPoint, predictLoc);
    if (distance &gt; p.radius) {
      seek(target);
    }//[end]
  }</pre>

<p>Now, you may notice above that instead of using all that dot product/scalar projection code to find the normal point, we instead call a function: <strong function>getNormalPoint()</strong>.   In cases like this, it’s useful to break out the code that performs a specific task (finding a normal point) into a function that it can be used generically in any case where it is required.  The function takes three <strong klass>PVector</strong><code>s</code>: the first defines a point in Cartesian space and the second and third arguments define a line segment.</p>

<figure id="chapter06_figure29">
<img src="imgs/chapter06/ch06_29.png" alt="Figure 6.29"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">  PVector getNormalPoint(PVector p, PVector a, PVector b) {
    // PVector that points from a to p
    PVector ap = PVector.sub(p, a);
    // PVector that points from a to b
    PVector ab = PVector.sub(b, a);

    //[full] Using the dot product for scalar projection
    ab.normalize();
    ab.mult(ap.dot(ab));
    //[end]
    // Finding the normal point along the line segment
    PVector normalPoint = PVector.add(a, ab);

    return normalPoint;
  }</pre>

<p>What do we have so far?  We have a <strong klass>Path</strong> class that defines a path as a line between two points.  We have a <strong klass>Vehicle</strong> class that defines a vehicle that can follow the path (using a steering behavior to seek a target along the path).  What is missing?</p>

<p>Take a deep breath.  We’re almost there.</p>
</section>







<section data-type="sect1" id="chapter06_section9">
<h1>6.9 Path Following with Multiple Segments</h1>
<p><a data-type="indexterm" data-primary=""path following"" data-secondary=""multiple segments"">&nbsp;</a></p>

<figure id="chapter06_figure30" class="A Curvy Path">
<img src="imgs/chapter06/ch06_30.png" alt="Figure 6.30"/>
<figcaption/>
</figure>
<p>We’ve built a great example so far, yes, but it’s pretty darn limiting.  After all, what if we want our path to be something that looks more like:</p>

<figure id="chapter06_figure31" class="Path defined as line segments">
<img src="imgs/chapter06/ch06_31.png" alt="Figure 6.31"/>
<figcaption/>
</figure>
<p>While it’s true that we could make this example work for a curved path, we’re much less likely to end up needing a cool compress on our forehead if we stick with line segments.  In the end, we  can always employ the same technique we discovered with Box2D—we can draw whatever fancy curved path we want and approximate it behind the scenes with simple geometric forms.</p>

<p>So, what’s the problem?  If we made path following work with one line segment, how do we make it work with a series of connected line segments?   Let’s take a look again at our vehicle driving along the screen.    Say we arrive at Step 3.</p>

<p><strong><em>Step 3: Find a target point on the path.</em></strong></p>

<p><a data-type="indexterm" data-primary=""normal points"" data-secondary=""series of" data-tertiary="for path following"">&nbsp;</a></p>

<p>To find the target, we need to find the normal to the line segment.  But now that we have a series of line segments, we have a series of normal points (see above)!  Which one do we choose?  The solution we’ll employ is to pick the normal point that is (a) closest and (b) on the path itself.</p>

<figure id="chapter06_figure32">
<img src="imgs/chapter06/ch06_32.png" alt="Figure 6.32"/>
<figcaption/>
</figure>
<p>If we have a point and an infinitely long line, we’ll always have a normal.  But, as in the path-following example, if we have a point and a line segment, we won’t necessarily find a normal that is on the line segment itself.  So if this happens for any of the segments, we can disqualify those normals.  Once we are left with normals that are on the path itself (only two in the above diagram), we simply pick the one that is closest to our vehicle’s location.</p>

<p>In order to write the code for this, we’ll have to expand our <strong klass>Path</strong> class to have an <strong klass>ArrayList</strong> of points (rather than just two, a start and an end).</p>

<figure class="screenshot">
<img src="imgs/chapter06/ch06_ex6_a.png" alt="ch06 ex6 a"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java"> class Path {

  // A Path is now an ArrayList of points (PVector objects).
  ArrayList&lt;PVector&gt; points;
  float radius;

  Path() {
    radius = 20;
    points = new ArrayList&lt;PVector&gt;();
  }

  //[full] This function allows us to add points to the path.
  void addPoint(float x, float y) {   .
    PVector point = new PVector(x,y);
    points.add(point);
  }
  //[end]

  //[full] Display the path as a series of points.
  void display() {
    stroke(0);
    noFill();
    beginShape();
    for (PVector v : points) {
      vertex(v.x,v.y);
    }
    endShape();
  }
  //[end]
}</pre>

<p>Now that we have the <strong klass>Path</strong> class defined, it’s the vehicle’s turn to deal with multiple line segments.  All we did before was find the normal for one line segment.  We can now find the normals for all the line segments in a loop.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; p.points.size()-1; i++) {
  PVector a = p.points.get(i);
  PVector b = p.points.get(i+1);
  //[offset-down] Finding the normals for each line segment
  PVector normalPoint = getNormalPoint(predictLoc, a, b);
</pre>

<p>Then we should make sure the normal point is actually between points <strong var>a</strong> and <strong var>b</strong>.  Since we know our path goes from left to right in this example, we can test if the <em>x</em> component of <strong var>normalPoint</strong> is outside the <em>x</em> components of <strong var>a</strong> and <strong var>b</strong>.</p>

<pre data-type="programlisting" data-code-language="java">   if (normalPoint.x &lt; a.x || normalPoint.x &gt; b.x) {
      // Use the end point of the segment
      // as our normal point if we can’t find one.
      normalPoint = b.get();
   }</pre>

<p>As a little trick, we’ll say that if it’s not within the line segment, let’s just pretend the end point of that line segment is the normal.  This will ensure that our vehicle always stays on the path, even if it strays out of the bounds of our line segments.</p>

<p>Finally, we’ll need to make sure we find the normal point that is closest to our vehicle.  To accomplish this, we start with a very high “world record” distance and iterate through each normal point to see if it beats the record (i.e. is less than).  Each time a normal point beats the record, the world record is updated and the winning point is stored in a variable named <strong var>target</strong>.  At the end of the loop, we’ll have the closest normal point in that variable.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_06_PathFollowing/_6_06_PathFollowing.pde processingjs/chapter06/_6_06_PathFollowing/Path.pde processingjs/chapter06/_6_06_PathFollowing/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex6.png" alt="ch06 ex6"/>
<figcaption/>
</figure>
<p><strong example>Example 6.6: Path following</strong></p>

<pre data-type="programlisting" data-code-language="java">PVector target = null;
// Start with a very high record
// that can easily be beaten.
float worldRecord = 1000000;

for (int i = 0; i &lt; p.points.size()-1; i++) {
  PVector a = p.points.get(i);
  PVector b = p.points.get(i+1);
  PVector normalPoint = getNormalPoint(predictLoc, a, b);
  if (normalPoint.x &lt; a.x || normalPoint.x &gt; b.x) {
    normalPoint = b.get();
  }

  float distance = PVector.dist(predictLoc, normalPoint);

  //[full] If we beat the record, then
  // this should be our target!
  if (distance &lt; worldRecord) {
    worldRecord = distance;
    target = normalPoint.get();
  }
  //[end]
}</pre>

<div id="chapter06_exercise10" data-type="example">
<h5>Exercise 6.10</h5>
<p>Update the path-following example so that the path can go in any direction.  (Hint: you’ll need to use the <strong function>min()</strong> and <strong function>max()</strong> function when determining if the normal point is inside the line segment.)</p>

<pre data-type="programlisting" data-code-language="java">if (normalPoint.x &lt; ____(____,____) || normalPoint.x &gt; ____(____,____)) {
  normalPoint = b.get();
}</pre>
</div>

<div id="chapter06_exercise11" data-type="example">
<h5>Exercise 6.11</h5>
<p>Create a path that changes over time.  Can the points that define the path itself have their own steering behaviors?</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section10">
<h1>6.10  Complex Systems</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""complex systems and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""complex systems"">&nbsp;</a></p>

<p>Remember our purpose?  To breathe life into the things that move around our Processing windows?  By learning to write the code for an autonomous agent and building a series of examples of individual behaviors, hopefully our souls feel a little more full.  But this is no place to stop and rest on our laurels.  We’re just getting started.   After all, there is a deeper purpose at work here.  Yes, a vehicle is a simulated being that makes decisions about how to seek and flow and follow.  But what is a life led alone, without the love and support of others?  Our purpose here is not only to build individual behaviors for our vehicles, but to put our vehicles into systems of many vehicles and allow those vehicles to interact with each other.</p>

<p><a data-type="indexterm" data-primary=""ants" data-secondary="modeling for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""complex systems"" data-secondary=""superorganisms"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""ants" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""superorganisms"">&nbsp;</a></p>

<p>Let’s think about a tiny, crawling ant—one single ant.  An ant is an autonomous agent; it can perceive its environment (using antennae to gather information about the direction and strength of chemical signals) and make decisions about how to move based on those signals.  But can a single ant acting alone build a nest, gather food, defend its queen?   An ant is a simple unit and can only perceive its immediate environment.  A colony of ants, however, is a sophisticated complex system, a “superorganism” in which the components work together to accomplish difficult and complicated goals.</p>

<p>We want to take what we’ve learned during the process of building autonomous agents in Processing into simulations that involve many agents operating in parallel—agents that have an ability to perceive not only their physical environment but also the actions of their fellow agents, and then act accordingly.  We want to create complex systems in Processing.</p>

<p>What is a complex system?  A complex system is typically defined as a system that is “more than the sum of its parts.”  While the individual elements of the system may be incredibly simple and easily understood, the behavior of the system as a whole can be highly complex, intelligent, and difficult to predict.  Here are three key principles of complex systems.</p>

<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""key principles of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""short range relationships"" data-secondary=""complex systems"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Simple units with short-range relationships.</em></strong>  This is what we’ve been building all along: vehicles that have a limited perception of their environment.</p></li>
<li>
<p><strong><em>Simple units operate in parallel.</em></strong>   This is what we need to simulate in code.  For every cycle through Processing’s <strong function>draw()</strong> loop, each unit will decide how to move (to create the appearance of them all working in parallel).</p></li>
<li>
<p><strong><em>System as a whole exhibits emergent phenomena.</em></strong>   Out of the interactions between these simple units emerges complex behavior, patterns, and intelligence.  Here we’re talking about the result we are hoping for in our sketches.  Yes, we know this happens in nature (ant colonies, termites, migration patterns, earthquakes, snowflakes, etc.), but can we achieve the same result in our Processing sketches?</p></li>
</ul>

<p>Following are three additional features of complex systems that will help frame the discussion, as well as provide guidelines for features we will want to include in our software simulations.  It&#8217;s important to acknowledge that this is a fuzzy set of characteristics and not all complex systems have all of them.</p>

<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""non-linearity component"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Non-linearity.</em></strong>  This aspect of complex systems is often casually referred to as “the butterfly effect,” coined by mathematician and meteorologist Edward Norton Lorenz, a pioneer in the study of chaos theory.  In 1961, Lorenz was running a computer weather simulation for the second time and, perhaps to save a little time, typed in a starting value of 0.506 instead of 0.506127.   The end result was completely different from the first result of the simulation.   In other words, the theory is that a single butterfly flapping its wings on the other side of the world could cause a massive weather shift and ruin our weekend at the beach.  We call it “non-linear” because there isn’t a linear relationship between a change in initial conditions and a change in outcome.   A small change in initial conditions can have a massive effect on the outcome.  Non-linear systems are a superset of chaotic systems.  In the next chapter, we’ll see how even in a system of many zeros and ones, if we change just one bit, the result will be completely different.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""competition/cooperation component"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Competition and cooperation.</em></strong>  One of the things that often makes a complex system tick is the presence of both competition and cooperation between the elements.   In our upcoming flocking system, we will have three rules—alignment, cohesion, and separation.  Alignment and cohesion will ask the elements to “cooperate”—i.e. work together to stay together and move together.  Separation, however, will ask the elements to “compete” for space.  As we get to the flocking system, try taking out the cooperation or the competition and you’ll see how you are left without complexity. Competition and cooperation are found in living complex systems, but not in non-living complex systems like the weather.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""feedback component"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Feedback.</em></strong> Complex systems often include a feedback loop where the the output of the system is fed back into the system to influence its behavior in a positive or negative direction. Let&#8217;s say you drive to work each day because the price of gas is low.  In fact, everyone drives to work.  The price of gas goes up as demand begins to exceed supply.  You, and everyone else, decide to take the train to work because driving is too expensive.  And the price of gas declines as the demand declines.  The price of gas is both the input of the system (determining whether you choose to drive or ride the train) and the output (the demand that results from your choice).  I should note that economic models (like supply/demand, the stock market) are one example of a human complex system.  Others include fads and trends, elections, crowds, and traffic flow.</p></li>
</ul>

<p>Complexity will serve as a theme for the remaining content in this book. In this chapter, we’ll begin by adding one more feature to our <strong klass>Vehicle</strong> class: an ability to look at neighboring vehicles.</p>
</section>







<section data-type="sect1" id="chapter06_section11">
<h1>6.11  Group Behaviors (or: Let’s not run into each other)</h1>
<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""group behavior"">&nbsp;</a>
<a data-type="indexterm" data-primary=""group behavior"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""group behavior"">&nbsp;</a></p>

<p>A group is certainly not a new concept. We’ve done this before—in Chapter 4, where we developed a framework for managing collections of particles in a <strong klass>ParticleSystem</strong> class.   There, we stored a list of particles in an <strong klass>ArrayList</strong>.  We’ll do the same thing here: store a bunch of <strong klass>Vehicle</strong> objects in an <strong klass>ArrayList</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// Declare an ArrayList of Vehicle objects.
ArrayList&lt;Vehicle&gt; vehicles;

void setup() {
  // Initialize and fill the ArrayList
  // with a bunch of Vehicles.
  vehicles = new ArrayList&lt;Vehicle&gt;;
  for (int i = 0; i &lt; 100; i++) {
    vehicles.add(new Vehicle(random(width),random(height)));
  }
}</pre>

<p>Now when it comes time to deal with all the vehicles in <strong function>draw()</strong>, we simply loop through all of them and call the necessary functions.</p>

<pre data-type="programlisting" data-code-language="java">void draw(){
  for (Vehicle v : vehicles) {
    v.update();
    v.display();
  }
}</pre>

<p>OK, so maybe we want to add a behavior, a force to be applied to all the vehicles.  This could be seeking the mouse.</p>

<pre data-type="programlisting" data-code-language="java">    v.seek(mouseX,mouseY);</pre>

<p><a data-type="indexterm" data-primary=""collisions"" data-secondary=""avoiding in group behavior"">&nbsp;</a>
<a data-type="indexterm" data-primary=""group behavior"" data-secondary=""collisions" data-tertiary="avoiding"">&nbsp;</a></p>

<p>But that’s an individual behavior.  We’ve already spent thirty-odd pages worrying about individual behaviors.  We’re here because we want to apply a group behavior.  Let’s begin with separation, a behavior that commands, “Avoid colliding with your neighbors!”</p>

<pre data-type="programlisting" data-code-language="java">    v.separate();</pre>

<p>Is that right?  It sounds good, but it’s not.  What’s missing?  In the case of seek, we said, “Seek <strong var>mouseX</strong> and <strong var>mouseY</strong>.”  In the case of separate, we’re saying “separate from <em>everyone else</em>.”  Who is everyone else?  It’s the list of all the other vehicles.</p>

<pre data-type="programlisting" data-code-language="java">    v.separate(vehicles);</pre>

<p>This is the big leap beyond what we did before with particle systems.  Instead of having each element (particle or vehicle) operate on its own, we’re now saying, “Hey you, the vehicle! When it comes time for you to operate, you need to operate with an awareness of everyone else. So I’m going to go ahead and pass you the <strong klass>ArrayList</strong> of everyone else.”</p>

<p>This is how we’ve mapped out <strong function>setup()</strong> and <strong function>draw()</strong> to deal with a group behavior.</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Vehicle&gt; vehicles;

void setup() {
  size(320,240);
  vehicles = new ArrayList&lt;Vehicle&gt;();
  for (int i = 0; i &lt; 100; i++) {
    vehicles.add(new Vehicle(random(width),random(height)));
  }
}

void draw() {
  background(255);

  for (Vehicle v : vehicles) {
    // This is really the only new thing we’re doing in this section.  We’re asking
    // a Vehicle object to examine all the other vehicles in the process of calculating a
    // separation force.
    v.separate(vehicles); //[bold]
    v.update();
    v.display();
  }
}</pre>

<figure id="chapter06_figure33" class="half-width-right">
<img src="imgs/chapter06/ch06_33.png" alt="Figure 6.33"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""repulsion"" data-secondary=""group behavior and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering behaviors"" data-secondary=""group behavior and"">&nbsp;</a></p>

<p>Of course, this is just the beginning.  The real work happens inside the <strong function>separate()</strong> function itself.  Let’s figure out how we want to define separation. Reynolds states: “Steer to avoid crowding.” In other words, if a given vehicle is too close to you, steer away from that vehicle.  Sound familiar?  Remember the seek behavior where a vehicle steers towards a target?  Reverse that force and we have the flee behavior.</p>

<figure id="chapter06_figure34" class="half-width-right">
<img src="imgs/chapter06/ch06_34.png" alt="Figure 6.34"/>
<figcaption/>
</figure>
<p>But what if more than one vehicle is too close?  In this case, we’ll define separation as the average of all the vectors pointing away from any close vehicles.</p>

<p>Let’s begin to write the code.  As we just worked out, we’re writing a function called <strong function>separate()</strong> that receives an <strong klass>ArrayList</strong> of Vehicle objects as an argument.</p>

<pre data-type="programlisting" data-code-language="java">void separate (ArrayList&lt;Vehicle&gt; vehicles) {

}</pre>

<p>Inside this function, we’re going to loop through all of the vehicles and see if any are too close.</p>

<pre data-type="programlisting" data-code-language="java">  // This variable specifies how close is too close.
  float desiredseparation = 20;

  for (Vehicle other : vehicles) {

    //[offset-down] What is the distance between me and another Vehicle?
    float d = PVector.dist(location, other.location);


    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      // Any code here will be executed if the Vehicle is within 20 pixels.

    }
  }</pre>

<p>Notice how in the above code, we are not only checking if the distance is less than a desired separation (i.e. too close!), but also if the distance is greater than zero.  This is a little trick that makes sure we don’t ask a vehicle to separate from itself.   Remember, all the vehicles are in the <strong klass>ArrayList</strong>, so if you aren’t careful you’ll be comparing each vehicle to itself!</p>

<p>Once we know that two vehicles are too close, we need to make a vector that points away from the offending vehicle.</p>

<pre data-type="programlisting" data-code-language="java">    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      //[offset-down] A PVector pointing away from the other’s location
      PVector diff = PVector.sub(location, other.location);
      diff.normalize();
    }</pre>

<p>This is not enough.  We have that vector now, but we need to make sure we calculate the average of all vectors pointing away from close vehicles.   How do we compute average?  We add up all the vectors and divide by the total.</p>

<pre data-type="programlisting" data-code-language="java">  // Start with an empty PVector.
  PVector sum = new PVector();  //[bold]
  int count = 0;  //[bold]
  // We have to keep track of how many Vehicles are too close.
  for (Vehicle other : vehicles) {

    float d = PVector.dist(location, other.location);
    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      PVector diff = PVector.sub(location, other.location); //[bold]
      diff.normalize();
      // Add all the vectors together and increment the count.
      sum.add(diff); //[bold]
      count++;
    }
  }

  // We have to make sure we found at least one close
  // vehicle.  We don’t want to bother doing anything
  // if nothing is too close (not to mention we can’t
  // divide by zero!)
  if (count &gt; 0) { //[bold]
    sum.div(count); //[bold]
  } //[bold]</pre>

<p>Once we have the average vector (stored in the <strong klass>PVector</strong> object “sum”), that <strong klass>PVector</strong> can be scaled to maximum speed and become our desired velocity—we <em>desire</em> to move in that direction at maximum speed!   And once we have the desired velocity, it’s the same old Reynolds story: steering equals desired minus velocity.</p>

<pre data-type="programlisting" data-code-language="java">  if (count &gt; 0) {
    sum.div(count);

    // Scale average to maxspeed
    // (this becomes desired).
    sum.setMag(maxspeed);

    // Reynolds’s steering formula
    PVector steer = PVector.sub(sum,vel);
    steer.limit(maxforce);

    // Apply the force to the Vehicle’s
    // acceleration.
    applyForce(steer);
  }</pre>

<p>Let’s see the function in its entirety.  There are two additional improvements, noted in the code comments.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_07_Separation/_6_07_Separation.pde processingjs/chapter06/_6_07_Separation/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex7.png" alt="ch06 ex7"/>
<figcaption/>
</figure>
<p><strong example>Example 6.7: Group behavior: Separation</strong></p>

<pre data-type="programlisting" data-code-language="java">  void separate (ArrayList&lt;Vehicle&gt; vehicles) {
    // Note how the desired separation is based
    // on the Vehicle’s size.
    float desiredseparation = r*2; //[bold]
    PVector sum = new PVector();
    int count = 0;
    for (Vehicle other : vehicles) {
      float d = PVector.dist(location, other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
        PVector diff = PVector.sub(location, other.location);
        diff.normalize();
        // What is the magnitude of the PVector
        // pointing away from the other vehicle?
        // The closer it is, the more we should flee.
        // The farther, the less. So we divide
        // by the distance to weight it appropriately.
        diff.div(d);  //[bold]
        sum.add(diff);
        count++;

      }
    }
    if (count &gt; 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(maxspeed);
      PVector steer = PVector.sub(sum, vel);
      steer.limit(maxforce);
      applyForce(steer);
    }

  }</pre>

<div id="chapter06_exercise12" data-type="example">
<h5>Exercise 6.12</h5>
<p>Rewrite <strong function>separate()</strong> to work in the opposite fashion (“cohesion”).  If a vehicle is beyond a certain distance, steer towards that vehicle.  This will keep the group together.  (Note that in a moment, we’re going to look at what happens when we have both cohesion and separation in the same simulation.)</p>
</div>

<div style="page-break-after:always;"> </div>
<div id="chapter06_exercise13" data-type="example">
<h5>Exercise 6.13</h5>
<p>Add the separation force to path following to create a simulation of Reynolds’s “Crowd Path Following.”</p>

<figure class="screenshot" data-pde="processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Ex_6_13_CrowdPathFollowing.pde processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Path.pde processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Vehicle.pde">
<img src="imgs/chapter06/ch06_exc13.png" alt="ch06 exc13"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter06_section12">
<h1>6.12  Combinations</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""combinations"">&nbsp;</a>
<a data-type="indexterm" data-primary=""combinations"">&nbsp;</a>
<a data-type="indexterm" data-primary=""group behavior"" data-secondary=""combinations"">&nbsp;</a></p>

<p>The previous two exercises hint at what is perhaps the most important aspect of this chapter.  After all, what is a Processing sketch with one steering force compared to one with many?  How could we even begin to simulate emergence in our sketches with only one rule?   The most exciting and intriguing behaviors will come from mixing and matching multiple steering forces, and we’ll need a mechanism for doing so.</p>

<p>You may be thinking, “Duh, this is nothing new.  We do this all the time.”  You would be right.  In fact, we did this as early as Chapter 2.</p>

<pre data-type="programlisting" data-code-language="java">  PVector wind = new PVector(0.001,0);
  PVector gravity = new PVector(0,0.1);
  mover.applyForce(wind);
  mover.applyForce(gravity);</pre>

<p>Here we have a mover that responds to two forces.  This all works nicely because of the way we designed the <strong klass>Mover</strong> class to accumulate the force vectors into its acceleration vector.  In this chapter, however, our forces stem from internal desires of the movers (now called vehicles). And those desires can be weighted. Let’s consider a sketch where all vehicles have two desires:</p>

<ul>
<li>
<p><strong><em>Seek the mouse location.</em></strong></p></li>
<li>
<p><strong><em>Separate from any vehicles that are too close.</em></strong></p></li>
</ul>

<p>We might begin by adding a function to the <strong klass>Vehicle</strong> class that manages all of the behaviors.  Let’s call it <strong function>applyBehaviors()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
  separate(vehicles);
  seek(new PVector(mouseX,mouseY));
}</pre>

<p>Here we see how a single function takes care of calling the other functions that apply the forces—<strong function>separate()</strong> and <strong function>seek()</strong>.    We could start mucking around with those functions and see if we can adjust the strength of the forces they are calculating.  But it would be easier for us to ask those functions to return the forces so that we can adjust their strength before applying them to the vehicle’s acceleration.</p>

<pre data-type="programlisting" data-code-language="java">  void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
    PVector separate = separate(vehicles);
    PVector seek = seek(new PVector(mouseX,mouseY));
    //[full] We have to apply the force here since seek() and separate() no longer do so.
    applyForce(separate);
    applyForce(seek);
    //[end]
  }</pre>

<p>Let’s look at how the seek function changed.</p>

<pre data-type="programlisting" data-code-language="java">  PVector seek(PVector target) {
    PVector desired = PVector.sub(target,loc);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,vel);
    steer.limit(maxforce);

    //[full] Instead of applying the force we return the PVector.
    applyForce(steer); //[line-through]
    return steer;
    //[end]
  }</pre>

<p>This is a subtle change, but incredibly important for us: it allows us to alter the strength of these forces in one place.</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_08_SeparationAndSeek/_6_08_SeparationAndSeek.pde processingjs/chapter06/_6_08_SeparationAndSeek/Vehicle.pde">
<img src="imgs/chapter06/ch06_ex8.png" alt="ch06 ex8"/>
<figcaption/>
</figure>
<p><strong example>Example 6.8: Combining steering behaviors: Seek and separate</strong></p>

<pre data-type="programlisting" data-code-language="java">void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
  PVector separate = separate(vehicles);
  PVector seek = seek(new PVector(mouseX,mouseY));

  //[full] These values can be whatever you want them to be!
  // They can be variables that are customized for
  // each vehicle, or they can change over time.
  separate.mult(1.5); //[bold]
  seek.mult(0.5); //[bold]


  //[end]
  applyForce(separate);
  applyForce(seek);
}</pre>

<div id="chapter06_exercise14" data-type="example">
<h5>Exercise 6.14</h5>
<p>Redo Example 6.8 so that the behavior weights are not constants.  What happens if they change over time (according to a sine wave or Perlin noise)?  Or if some vehicles are more concerned with seeking and others more concerned with separating?  Can you introduce other steering behaviors as well?</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section13">
<h1>6.13  Flocking</h1>
<p><a data-type="indexterm" data-primary=""Flocks" data-secondary="Herds" data-tertiary="and Schools: A Distributed Behavioral Model (Reynolds)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""flocking"">&nbsp;</a>
<a data-type="indexterm" data-primary=""flocking"">&nbsp;</a>
<a data-type="indexterm" data-primary=""group behavior"" data-secondary=""flocking"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""flocking"">&nbsp;</a></p>

<p>Flocking is an group animal behavior that is characteristic of many living creatures, such as birds, fish, and insects.   In 1986, Craig Reynolds created a computer simulation of flocking behavior and documented the algorithm in his paper, “Flocks, Herds, and Schools: A Distributed Behavioral Model.”    Recreating this simulation in Processing will bring together all the concepts in this chapter.</p>

<ol>
<li>
<p><em>We will use the steering force formula (steer = desired - velocity) to implement the rules of flocking.</em></p></li>
<li>
<p><em>These steering forces will be group behaviors and require each vehicle to look at all the other vehicles.</em></p></li>
<li>
<p><em>We will combine and weight multiple forces.</em></p></li>
<li>
<p><em>The result will be a complex system—intelligent group behavior will emerge from the simple rules of flocking without the presence of a centralized system or leader.</em></p></li>
</ol>

<p>The good news is, we’ve already done items 1 through 3 in this chapter, so this section will be about just putting it all together and seeing the result.</p>

<p>Before we begin, I should mention that we’re going to change the name of our <strong klass>Vehicle</strong> class (yet again).  Reynolds uses the term “boid” (a made-up word that refers to a bird-like object) to describe the elements of a flocking system and we will do the same.</p>

<p>Let’s take an overview of the three rules of flocking.</p>

<p><a data-type="indexterm" data-primary=""alignment (flocking)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""cohesion (flocking)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""flocking"" data-secondary=""rules of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""separation (flocking)"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>Separation</em></strong> (also known as “avoidance”): Steer to avoid colliding with your neighbors.</p></li>
<li>
<p><strong><em>Alignment</em></strong> (also known as “copy”): Steer in the same direction as your neighbors.</p></li>
<li>
<p><strong><em>Cohesion</em></strong> (also known as “center”): Steer towards the center of your neighbors (stay with the group).</p></li>
</ol>

<figure id="chapter06_figure35">
<img src="imgs/chapter06/ch06_35.png" alt="Figure 6.35"/>
<figcaption/>
</figure>
<p>Just as we did with our separate and seek example, we’ll want our <strong klass>Boid</strong> objects to have a single function that manages all the above behaviors.  We’ll call this function <strong function>flock()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  void flock(ArrayList&lt;Boid&gt; boids) {
    //[full] The three flocking rules
    PVector sep = separate(boids);
    PVector ali = align(boids);
    PVector coh = cohesion(boids);
    //[end]

    //[full] Arbitrary weights for these forces
    // (Try different ones!)
    sep.mult(1.5);
    ali.mult(1.0);
    coh.mult(1.0);
    //[end]

    //[full] Applying all the forces
    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
    //[end]
  }</pre>

<p>Now, it’s just a matter of implementing the three rules.   We did separation before; it’s identical to our previous example.  Let’s take a look at alignment, or steering in the same direction as your neighbors.  As with all of our steering behaviors, we’ve got to boil down this concept into a desire: the boid’s desired velocity is the average velocity of its neighbors.</p>

<p>So our algorithm is to calculate the average velocity of all the other boids and set that to desired.</p>

<p><a data-type="indexterm" data-primary=""separation (flocking)"" data-secondary=""implementing"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">  PVector align (ArrayList&lt;Boid&gt; boids) {
    //[full] Add up all the velocities
    // and divide by the total
    // to calculate the average velocity.
    PVector sum = new PVector(0,0);
    for (Boid other : boids) {
      sum.add(other.velocity);
    }
    sum.div(boids.size());
    //[end]

    // We desire to go in that
    // direction at maximum speed.
    sum.setMag(maxspeed);

    // Reynolds’s steering
    // force formula
    PVector steer = PVector.sub(sum,velocity);
    steer.limit(maxforce);
    return steer;
  }</pre>

<p><a data-type="indexterm" data-primary=""short range relationships"" data-secondary=""flocking behavior and"">&nbsp;</a></p>

<p>The above is pretty good, but it’s missing one rather crucial detail.  One of the key principles behind complex systems like flocking is that the elements (in this case, boids) have short-range relationships.   Thinking about ants again, it’s pretty easy to imagine an ant being able to sense its immediate environment, but less so an ant having an awareness of what another ant is doing hundreds of feet away.  The fact that the ants can perform such complex collective behavior from only these neighboring relationships is what makes them so exciting in the first place.</p>

<p>In our alignment function, we’re taking the average velocity of all the boids, whereas we should really only be looking at the boids within a certain distance.  That distance threshold is up to you, of course.  You could design boids that can see only twenty pixels away or boids that can see a hundred pixels away.</p>

<figure id="chapter06_figure36">
<img src="imgs/chapter06/ch06_36.png" alt="Figure 6.36"/>
<figcaption/>
</figure>
<p>Much like we did with separation (only calculating a force for others within a certain distance), we’ll want to do the same with alignment (and cohesion).</p>

<p><a data-type="indexterm" data-primary=""alignment (flocking)"" data-secondary=""implementing"">&nbsp;</a></p>

<pre data-type="programlisting" data-code-language="java">  PVector align (ArrayList&lt;Boid&gt; boids) {
    // This is an arbitrary value and could
    // vary from boid to boid.
    float neighbordist = 50;
    PVector sum = new PVector(0,0);
    int count = 0;
    for (Boid other : boids) {
      float d = PVector.dist(location,other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; neighbordist)) {
        sum.add(other.velocity);
        // For an average, we need to keep track of
        // how many boids are within the distance.
        count++;
      }
    }
    if (count &gt; 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(maxspeed);
      PVector steer = PVector.sub(sum,velocity);
      steer.limit(maxforce);
      return steer;
    //[full] If we don’t find any close boids,
    // the steering force is zero.
    } else {
      return new PVector(0,0);
    }
    //[end]
  }</pre>

<div id="chapter06_exercise15" data-type="example">
<h5>Exercise 6.15</h5>
<figure class="half-width-right">
<img src="imgs/chapter06/ch06_exc15.png" alt="ch06 exc15"/>
<figcaption/>
</figure>
<p>Can you write the above code so that boids can only see other boids that are actually within their “peripheral” vision (as if they had eyes)?</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<p><a data-type="indexterm" data-primary=""cohesion (flocking)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Finally, we are ready for cohesion.  Here our code is virtually identical to that for alignment—only instead of calculating the average velocity of the boid’s neighbors, we want to calculate the average location of the boid’s neighbors (and use that as a target to seek).</p>

<pre data-type="programlisting" data-code-language="java">  PVector cohesion (ArrayList&lt;Boid&gt; boids) {
    float neighbordist = 50;
    PVector sum = new PVector(0,0);
    int count = 0;
    for (Boid other : boids) {
      float d = PVector.dist(location,other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; neighbordist)) {
        // Adding up all the others’ locations
        sum.add(other.location);
        count++;
      }
    }
    if (count &gt; 0) {
      sum.div(count);
      // Here we make use of the seek() function we
      // wrote in Example 6.8.  The target
      // we seek is the average location of
      // our neighbors.
      return seek(sum); //[bold]
    } else {
      return new PVector(0,0);
    }
  }</pre>

<p>It’s also worth taking the time to write a class called <strong klass>Flock</strong>, which will be virtually identical to the <strong klass>ParticleSystem</strong> class we wrote in Chapter 4 with only one tiny change:  When we call <strong function>run()</strong> on each <strong klass>Boid</strong> object (as we did to each <strong klass>Particle</strong> object), we’ll pass in a reference to the entire <strong klass>ArrayList</strong> of boids.</p>

<pre data-type="programlisting" data-code-language="java">class Flock {
  ArrayList&lt;Boid&gt; boids;

  Flock() {
    boids = new ArrayList&lt;Boid&gt;();
  }

  void run() {
    for (Boid b : boids) {
      // Each Boid object must know about
      // all the other Boids.
      b.run(boids); //[bold]
    }
  }

  void addBoid(Boid b) {
    boids.add(b);
  }
}</pre>

<p>And our main program will look like:</p>

<figure class="screenshot" data-pde="processingjs/chapter06/_6_09_Flocking/_6_09_Flocking.pde processingjs/chapter06/_6_09_Flocking/Flock.pde processingjs/chapter06/_6_09_Flocking/Boid.pde">
<img src="imgs/chapter06/ch06_ex9.png" alt="ch06 ex9"/>
<figcaption/>
</figure>
<p><strong example>Example 6.9: Flocking</strong></p>

<pre data-type="programlisting" data-code-language="java">// A Flock object manages the
// entire group.
Flock flock;
void setup() {
  size(300,200);
  flock = new Flock();
  for (int i = 0; i &lt; 100; i++) {
    Boid b = new Boid(width/2,height/2);
    // The Flock starts out with 100 Boids.
    flock.addBoid(b);
  }
}

void draw() {
  background(255);
  flock.run();
}</pre>

<div id="chapter06_exercise16" data-type="example">
<h5>Exercise 6.16</h5>
<p>Combine flocking with some other steering behaviors.</p>
</div>

<div id="chapter06_exercise17" data-type="example">
<h5>Exercise 6.17</h5>
<figure class="half-width-right">
<img src="imgs/chapter06/ch06_exc17.png" alt="ch06 exc17"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""<em>Computational Beauty of Nature</em> (Flake)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Flake" data-secondary="Gary"">&nbsp;</a></p>

<p>In his book The <em>Computational Beauty of Nature</em> (MIT Press, 2000), Gary Flake describes a fourth rule for flocking: “View: move laterally away from any boid that blocks the view.” Have your boids follow this rule.</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<div id="chapter06_exercise18" data-type="example">
<h5>Exercise 6.18</h5>
<p>Create a flocking simulation where all of the parameters (<em>separation weight</em>, <em>cohesion weight</em>, <em>alignment weight</em>, <em>maximum force</em>, <em>maximum speed</em>) change over time.  They could be controlled by Perlin noise or by user interaction. (For example, you could use a library such as <a href="http://www.sojamo.de/libraries/controlP5/">controlp5</a> to tie the values to slider positions.)</p>
</div>

<div id="chapter06_exercise19" data-type="example">
<h5>Exercise 6.19</h5>
<p>Visualize the flock in an entirely different way.</p>
</div>
</section>







<section data-type="sect1" id="chapter06_section14">
<h1>6.14  Algorithmic Efficiency (or: Why does my $@(*%! run so slowly?)</h1>
<p><a data-type="indexterm" data-primary=""efficiency"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"">&nbsp;</a></p>

<p>I would like to hide the dark truth behind we’ve just done, because I would like you to be happy and live a fulfilling and meaningful life.  But I also would like to be able to sleep at night without worrying about you so much.  So it is with a heavy heart that I must bring up this topic.  Group behaviors are wonderful.  But they can be slow, and the more elements in the group, the slower they can be.  Usually, when we talk about Processing sketches running slowly, it’s because drawing to the screen can be slow—the more you draw, the slower your sketch runs.  This is actually a case, however, where the slowness derives from the algorithm itself.  Let’s discuss.</p>

<p><a data-type="indexterm" data-primary=""Big O Notation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""efficiency"" data-secondary=""Big O Notation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""flocking"" data-secondary=""performance and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""Big O Notation"">&nbsp;</a></p>

<p>Computer scientists classify algorithms with something called “Big O notation,” which describes the efficiency of an algorithm: how many computational cycles does it require to complete?  Let’s consider a simple analog search problem.  You have a basket containing one hundred chocolate treats, only one of which is pure dark chocolate. That’s the one you want to eat.  To find it, you pick the chocolates out of the basket one by one.  Sure, you might be lucky and find it on the first try, but in the worst-case scenario you have to check all one hundred before you find the dark chocolate.   To find one thing in one hundred, you have to check one hundred things (or to find one thing in N things, you have to check N times.)  Your Big O Notation is N.  This, incidentally, is the Big O Notation that describes our simple particle system.  If we have N particles, we have to run and display those particles N times.</p>

<p>Now, let’s think about a group behavior (such as flocking).   For every <strong klass>Boid</strong> object, we have to check every other <strong klass>Boid</strong> object (for its velocity and location).  Let’s say we have one hundred boids.  For boid #1, we need to check one hundred boids; for boid #2, we need to check one hundred boids, and so on and so forth.   For one hundred boids, we need to perform one hundred times one hundred checks, or ten thousand.   No problem: computers are fast and can do things ten thousand times pretty easily.  Let’s try one thousand.</p>

<p>1,000 x 1,000 = 1,000,000 cycles.</p>

<p>OK, this is rather slow, but still somewhat manageable.   Let’s try 10,000 elements:</p>

<p>10,000 x 10,000 elements = 100,000,000 cycles.</p>

<p>Now, we’re really getting slow. Really, really, really slow.</p>

<p><a data-type="indexterm" data-primary=""Big O Notation N-Squared"">&nbsp;</a>
<a data-type="indexterm" data-primary=""efficiency"" data-secondary=""Big O Notation N-Squared"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""Big O Notation N-Squared"">&nbsp;</a></p>

<p>Notice something odd?  As the number of elements increases by a factor of 10, the number of required cycles increases by a factor of 100.  Or as the number of elements increases by a factor of N, the cycles increase by a factor of N times N.  This is known as Big O Notation N-Squared.</p>

<p>I know what you are thinking.  You are thinking: “No problem; with flocking, we only need to consider the boids that are close to other boids.  So even if we have 1,000 boids, we can just look at, say, the 5 closest boids and then we only have 5,000 cycles.”   You pause for a moment, and then start thinking: “So for each boid I just need to check all the boids and find the five closest ones and I’m good!”  See the catch-22?  Even if we only want to look at the close ones, the only way to know what the close ones are would be to check all of them.</p>

<p>Or is there another way?</p>

<p>Let’s take a number that we might actually want to use, but would still run too slowly: 2,000 (4,000,000 cycles required).</p>

<p><a data-type="indexterm" data-primary=""bin-lattice spatial subdivision"">&nbsp;</a>
<a data-type="indexterm" data-primary=""efficiency"" data-secondary=""bin-lattice spatial subdivision"">&nbsp;</a>
<a data-type="indexterm" data-primary=""flocking"" data-secondary=""bin-lattice spatial subdivision"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""bin-lattice spatial subdivision"">&nbsp;</a></p>

<p>What if we could divide the screen into a grid?  We would take all 2,000 boids and assign each boid to a cell within that grid.   We would then be able to look at each boid and compare it to its neighbors within that cell at any given moment. Imagine a 10 x 10 grid. In a system of 2,000 elements, on average, approximately 20 elements would be found in each cell (20 x 10 x 10 = 2,000).  Each cell would then require 20 x 20 = 400 cycles. With 100 cells, we’d have 100 x 400 = 40,000 cycles, a massive savings over 4,000,000.</p>

<figure id="chapter06_figure37">
<img src="imgs/chapter06/ch06_37.png" alt="Figure 6.37"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Interaction with Groups of Autonomous Characters (Reynolds)"">&nbsp;</a></p>

<p>This technique is known as “bin-lattice spatial subdivision” and is outlined in more detail in (surprise, surprise) Reynolds’s 2000 paper, <a href="http://www.red3d.com/cwr/papers/2000/pip.pdf">“Interaction with Groups of Autonomous Characters”</a>.   How do we implement such an algorithm in Processing?  One way is to keep multiple <strong klass>ArrayList</strong><code>s</code>.  One <strong klass>ArrayList</strong> would keep track of all the boids, just like in our flocking example.</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Boid&gt; boids;</pre>

<p>In addition to that <strong klass>ArrayList</strong>, we store an additional reference to each <strong klass>Boid</strong> object in a two-dimensional <strong klass>ArrayList</strong>.  For each cell in the grid, there is an <strong klass>ArrayList</strong> that tracks the objects in that cell.</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;Boid&gt;[][] grid;</pre>

<p>In the main <strong function>draw()</strong> loop, each <strong klass>Boid</strong> object then registers itself in the appropriate cell according to its location.</p>

<pre data-type="programlisting" data-code-language="java">int column = int(boid.x) / resolution;
int row    = int(boid.y) /resolution;
grid[column][row].add(boid);</pre>

<p>Then when it comes time to have the boids check for neighbors, they can look at only those in their particular cell (in truth, we also need to check neighboring cells to deal with border cases).</p>

<p><strong example>Example 6.10: Bin-lattice spatial subdivision</strong></p>

<pre data-type="programlisting" data-code-language="java">int column = int(boid.x) / resolution;
int row    = int(boid.y) /resolution;
boid.flock(boids);
// Instead of looking at all
// the boids, just this cell
boid.flock(grid[column][row]);</pre>

<p>We’re only covering the basics here; for the full code, check the book’s website.</p>

<p>Now, there are certainly flaws with this system.  What if all the boids congregate in the corner and live in the same cell? Then don’t we have to check all 2,000 against all 2,000?</p>

<p>The good news is that this need for optimization is a common one and there are a wide variety of similar techniques out there.   For us, it’s likely that a basic approach will be good enough (in most cases, you won’t need one at all.)  For another, more sophisticated approach, check out <a href="http://toxiclibs.org/2010/02/new-package-simutils/">toxiclibs' Octree examples</a>.</p>
</section>







<section data-type="sect1" id="chapter06_section15">
<h1>6.15  A Few Last Notes: Optimization Tricks</h1>
<p><a data-type="indexterm" data-primary=""autonomous agents"" data-secondary=""efficiency"">&nbsp;</a>
<a data-type="indexterm" data-primary=""efficiency"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"">&nbsp;</a></p>

<p>This is something of a momentous occasion.  The end of Chapter 6 marks the end of our story of motion (in the context of this book, that is).  We started with the concept of a vector, moved on to forces, designed systems of many elements, examined physics libraries, built entities with hopes and dreams and fears, and simulated emergence.  The story doesn’t end here, but it does take a bit of a turn.  The next two chapters won’t focus on moving bodies, but rather on systems of rules.   Before we get there, I have a few quick items I’d like to mention that are important when working with the examples in Chapters 1 through 6.  They also relate to optimizing your code, which fits in with the previous section.</p>





<section data-type="sect2" id="_1_magnitude_squared_or_sometimes_distance_squared">
<h2>1) Magnitude squared (or sometimes distance squared)</h2>
<p>What is magnitude squared and when should you use it?  Let’s revisit how the magnitude of a vector is calculated.</p>

<pre data-type="programlisting" data-code-language="java">float mag() {
  return sqrt(x*x + y*y);
}</pre>

<p>Magnitude requires the square root operation.  And it should.  After all, if you want the magnitude of a vector, then you’ve got to look up the Pythagorean theorem and compute it (we did this in Chapter 1).  However, if you could somehow skip using the square root, your code would run faster.   Let’s consider a situation where you just want to know the relative magnitude of a vector.  For example, is the magnitude greater than ten?  (Assume a <strong klass>PVector</strong> <strong var>v</strong>.)</p>

<pre data-type="programlisting" data-code-language="java">if (v.mag() &gt; 10) {
  [inline]// Do Something!
}</pre>

<p>Well, this is equivalent to saying:</p>

<pre data-type="programlisting" data-code-language="java">if (v.magSq() &gt; 100) {
  [inline]// Do Something!
}</pre>

<p>And how is magnitude squared calculated?</p>

<pre data-type="programlisting" data-code-language="java">float magSq() {
  return x*x + y*y;
}</pre>

<p><a data-type="indexterm" data-primary=""efficiency"" data-secondary=""magSq() function (PVector class)."">&nbsp;</a>
<a data-type="indexterm" data-primary=""mag() function (PVector class)"" data-secondary=""magSq() function vs."">&nbsp;</a>
<a data-type="indexterm" data-primary=""magSq() function (PVector class)."">&nbsp;</a>
<a data-type="indexterm" data-primary=""optimization"" data-secondary=""magSq() function (PVector class)."">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""magSq() function (PVector class)."">&nbsp;</a></p>

<p>Same as magnitude, but without the square root.  In the case of a single <strong klass>PVector</strong> object, this will never make a significant difference on a Processing sketch.  However, if you are computing the magnitude of thousands of <strong klass>PVector</strong> objects each time through <strong function>draw()</strong>, using <strong function>magSq()</strong> instead of <strong function>mag()</strong> could help your code run a wee bit faster.  (Note: <strong function>magSq()</strong> is only available in Processing 2.0a1 or later.)</p>
</section>







<section data-type="sect2" id="_2_sine_and_cosine_lookup_tables">
<h2>2) Sine and cosine lookup tables</h2>
<p><a data-type="indexterm" data-primary=""cosine lookup tables"">&nbsp;</a>
<a data-type="indexterm" data-primary=""efficiency"" data-secondary=""sine/cosine lookup tables"">&nbsp;</a>
<a data-type="indexterm" data-primary=""optimization"" data-secondary=""sine/cosine lookup tables"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""sine/cosine lookup tables"">&nbsp;</a>
<a data-type="indexterm" data-primary=""sine lookup tables"">&nbsp;</a></p>

<p>There’s a pattern here.  What kinds of functions are slow to compute? Square root. Sine. Cosine.  Tangent.  Again, if you just need a sine or cosine value here or there in your code, you are never going to run into a problem.  But what if you had something like this?</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  for (int i = 0; i &lt; 10000; i++) {
     println(sin(PI));
  }
}</pre>

<p>Sure, this is a totally ridiculous code snippet that you would never write.  But it illustrates a certain point.  If you are calculating the sine of pi ten thousand times, why not just calculate it once, save that value, and refer to it whenever necessary?  This is the principle behind sine and cosine lookup tables.   Instead of calling the sine and cosine functions in your code whenever you need them, you can build an array that stores the results of sine and cosine at angles between 0 and <strong var>TWO_PI</strong> and just look up the values when you need them. For example, here are two arrays that store the sine and cosine values for every angle, 0 to 359 degrees.</p>

<pre data-type="programlisting" data-code-language="java">float sinvalues[] = new float[360];
float cosvalues[] = new float[360];
for (int i = 0; i &lt; 360; i++) {
  sinvalues[i] = sin(radians(i));
  cosvalues[i] = cos(radians(i));
}</pre>

<p>Now, what if you need the value of sine of pi?</p>

<pre data-type="programlisting" data-code-language="java">int angle = int(degrees(PI));
float answer = sinvalues[angle];</pre>

<p>A more sophisticated example of this technique is available on the <a href="http://wiki.processing.org/w/Sin/Cos_look-up_table">Processing wiki</a>.</p>
</section>







<section data-type="sect2" id="_3_making_gajillions_of_unnecessary_pvector_objects">
<h2>3) Making gajillions of unnecessary PVector objects</h2>
<p><a data-type="indexterm" data-primary=""efficiency"" data-secondary=""temporary objects and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""optimization"" data-secondary=""temporary objects and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""performance"" data-secondary=""temporary objects and"">&nbsp;</a></p>

<p>I have to admit, I am perhaps the biggest culprit of this last note.  In fact, in the interest of writing clear and understandable examples, I often choose to make extra <strong klass>PVector</strong> objects when I absolutely do not need to.  For the most part, this is not a problem at all.   But sometimes, it can be.  Let’s take a look at an example.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  for (Vehicle v : vehicles) {
   PVector mouse = new PVector(mouseX,mouseY);
   v.seek(mouse);
  }
}</pre>

<p>Let’s say our <strong klass>ArrayList</strong> of vehicles has one thousand vehicles in it.  We just made one thousand new <strong klass>PVector</strong> objects every single time through <strong function>draw()</strong>.  Now, on any ol’ laptop or desktop computer you’ve purchased in recent times, your sketch will likely not register a complaint, run slowly, or have any problems.  After all, you’ve got tons of RAM, and Java will be able to handle making a thousand or so temporary objects and dispose of them without much of a problem.</p>

<p>If your numbers grow larger (and they easily could) or perhaps more likely, if you are working with Processing on Android, you will almost certainly run into a problem.  In cases like this you want to look for ways to reduce the number of <strong klass>PVector</strong> objects you make.  An obvious fix for the above code is:</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  PVector mouse = new PVector(mouseX,mouseY);
  for (Vehicle v : vehicles) {
   v.seek(mouse);
  }
}</pre>

<p>Now you’ve made just one <strong klass>PVector</strong> instead of one thousand.  Even better, you could turn the <strong klass>PVector</strong> into a global variable and just assign the <strong var>x</strong> and <strong var>y</strong> value:</p>

<pre data-type="programlisting" data-code-language="java">PVector mouse = new PVector();

void draw() {
  mouse.x = mouseX;
  mouse.y = mouseY;
  for (Vehicle v : vehicles) {
   v.seek(mouse);
  }
}</pre>

<p>Now you never make a new <strong klass>PVector</strong>; you use just one over the length of your sketch!</p>

<p>Throughout the book&#8217;s examples, you can find lots of opportunities to reduce the number of temporary objects.  Let’s look at one more.  Here is a snippet from our <strong function>seek()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);

    // Create a new PVector to store the steering force.
    PVector steer = PVector.sub(desired,velocity); //[bold]
    steer.limit(maxforce);
    return steer;</pre>

<p>See how we’ve made two <strong klass>PVector</strong> objects?  First, we figure out the desired vector, then we calculate the steering force.  Notice how we could rewrite this to create only one <strong klass>PVector</strong>.</p>

<pre data-type="programlisting" data-code-language="java">    PVector desired = PVector.sub(target, location);
    desired.normalize();
    desired.mult(maxspeed);

    // Calculate the steering force in the desired PVector.
    desired.sub(velocity); //[bold]
    desired.limit(maxforce);
    return desired;</pre>

<p>We don’t actually need a second <strong klass>PVector</strong> called <strong var>steer</strong>.  We could just use the desired <strong klass>PVector</strong> object and turn it into the steering force by subtracting velocity.  I didn’t do this in my example because it is more confusing to read.  But in some cases, it may be greatly more efficient.</p>

<div id="chapter06_exercise20" data-type="example">
<h5>Exercise 6.20</h5>
<p>Eliminate as many temporary <strong klass>PVector</strong> objects from the flocking example as possible.  Also use <strong function>magSq()</strong> where possible.</p>
</div>

<div id="chapter06_exercise21" data-type="example">
<h5>Exercise 6.21</h5>
<p>Use steering behaviors with Box2D or toxiclibs.</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 6 Exercise:</p>

<p>Use the concept of steering forces to drive the behavior of the creatures in your ecosystem.  Some possibilities:</p>

<ul>
<li>
<p>Create “schools” or “flocks” of creatures.</p></li>
<li>
<p>Use a seeking behavior for creatures to search for food (for chasing moving prey, consider “pursuit”).</p></li>
<li>
<p>Use a flow field for the ecosystem environment.  For example, how does your system behave if the creatures live in a flowing river?</p></li>
<li>
<p>Build a creature with countless steering behaviors (as many as you can reasonably add).  Think about ways to vary the weights of these behaviors so that you can dial those behaviors up and down, mixing and matching on the fly.    How are creatures’ initial weights set?  What rules drive how the weights change over time?</p></li>
<li>
<p>Complex systems can be nested.  Can you design a single creature out of a flock of boids?  And can you then make a flock of those creatures?</p></li>
<li>
<p>Complex systems can have memory (and be adaptive).  Can the history of your ecosystem affect the behavior in its current state? (This could be the driving force behind how the creatures adjust their steering force weights.)</p></li>
</ul>
</div>
<div style="page-break-after:always;"> </div></section>


</section>



</section>







<section data-type="chapter" id="_chapter_7_cellular_automata">
<h1>Chapter 7.  Cellular Automata</h1>
<blockquote class='long-quote'>
“To play life you must have a fairly large checkerboard and a plentiful supply of flat counters of two colors.  It is possible to work with pencil and graph paper but it is much easier, particularly for beginners, to use counters and a board.”
<span class="attribution">
— Martin Gardner, <em>Scientific American</em> (October 1970)
</span>
</blockquote>
<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""cellular automata"">&nbsp;</a></p>

<p>In this chapter, we’re going to take a break from talking about vectors and motion.  In fact, the rest of the book will mostly focus on systems and algorithms (albeit ones that we can, should, and will apply to moving bodies).  In the previous chapter, we encountered our first Processing example of a complex system: flocking.  We briefly stated the core principles behind complex systems: more than the sum of its parts, a complex system is a system of elements, operating in parallel, with short-range relationships that as a whole exhibit emergent behavior.   This entire chapter is going to be dedicated to building another complex system simulation in Processing.    Oddly, we are going to take some steps backward and simplify the elements of our system.  No longer are the individual elements going to be members of a physics world; instead we will build a system out of the simplest digital element possible, a single bit.  This bit is going to be called a cell and its value (0 or 1) will be called its state.  Working with such simple elements will help us understand more of the details behind how complex systems work, and we’ll also be able to elaborate on some programming techniques that we can apply to code-based projects.</p>




<section data-type="sect1" id="chapter07_section1">
<h1>7.1 What Is a Cellular Automaton?</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""defined"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""cellular automata"">&nbsp;</a></p>

<p>First, let’s get one thing straight.   The term <strong><em>cellular automata</em></strong> is plural.   Our code examples will simulate just one—a <strong><em>cellular automaton</em></strong>, singular.   To simplify our lives, we’ll also refer to cellular automata as “CA.”</p>

<p>In Chapters 1 through 6, our objects (mover, particle, vehicle, boid) generally existed in only one “state.” They might have moved around with advanced behaviors and physics, but ultimately they remained the same type of object over the course of their digital lifetime.  We’ve alluded to the possibility that these entities can change over time (for example, the weights of steering “desires” can vary), but we haven’t fully put this into practice.   In this context, cellular automata make a great first step in building a system of many objects that have varying states over time.</p>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""characteristics of"">&nbsp;</a></p>

<p>A cellular automaton is a model of a system of “cell” objects with the following characteristics.</p>

<p><a data-type="indexterm" data-primary=""grid (cellular automata)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""state (cellular automata)"">&nbsp;</a></p>

<ul>
<li>
<p>The cells live on a <strong><em>grid</em></strong>. (We’ll see examples in both one and two dimensions in this chapter, though a cellular automaton can exist in any finite number of dimensions.)</p></li>
<li>
<p>Each cell has a <strong><em>state</em></strong>.  The number of state possibilities is typically finite. The simplest example has the two possibilities of 1 and 0 (otherwise referred to as “on” and “off” or “alive” and “dead”).</p></li>
<li>
<p>Each cell has a <strong><em>neighborhood</em></strong>.  This can be defined in any number of ways, but it is typically a list of adjacent cells.</p></li>
</ul>

<figure id="chapter07_figure1">
<img src="imgs/chapter07/ch07_01.png" alt="Figure 7.1"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""self-replicating cells"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Game of Life"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Los Alamos National Laboratory"">&nbsp;</a>
<a data-type="indexterm" data-primary=""self-replicating cells"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Ulam" data-secondary="Stanisław"">&nbsp;</a>
<a data-type="indexterm" data-primary=""von Neumann" data-secondary="John"">&nbsp;</a></p>

<p>The development of cellular automata systems is typically attributed to Stanisław Ulam and John von Neumann, who were both researchers at the Los Alamos National Laboratory in New Mexico in the 1940s.  Ulam was studying the growth of crystals and von Neumann was imagining a world of self-replicating robots.  That’s right, robots that build copies of themselves.  Once we see some examples of CA visualized, it’ll be clear how one might imagine modeling crystal growth; the robots idea is perhaps less obvious.   Consider the design of a robot as a pattern on a grid of cells (think of filling in some squares on a piece of graph paper).  Now consider a set of simple rules that would allow that pattern to create copies of itself on that grid.  This is essentially the process of a CA that exhibits behavior similar to biological reproduction and evolution.  (Incidentally, von Neumann’s cells had twenty-nine possible states.)  Von Neumann’s work in self-replication and CA is conceptually similar to what is probably the most famous cellular automaton: the “Game of Life,” which we will discuss in detail in section 7.3.</p>

<p><a data-type="indexterm" data-primary=""<em>New Kind of Science" data-secondary="A</em> (Wolfram)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram" data-secondary="Stephen"">&nbsp;</a></p>

<p>Perhaps the most significant scientific (and lengthy) work studying cellular automata arrived in 2002: Stephen Wolfram’s 1,280-page <a href="http://www.wolframscience.com/nksonline/toc.html"><em>A New Kind of Science</em></a>. Available in its entirety for free online, Wolfram’s book discusses how CA are not simply neat tricks, but are relevant to the study of biology, chemistry, physics, and all branches of science.  This chapter will barely scratch the surface of the theories Wolfram outlines (we will focus on the code implementation) so if the examples provided spark your curiosity, you’ll find plenty more to read about in his book.</p></section>







<section data-type="sect1" id="chapter07_section2">
<h1>7.2  Elementary Cellular Automata</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""elementary"">&nbsp;</a>
<a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""Wolfram algorithm for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""elementary cellular automata"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram" data-secondary="Stephen"" data-tertiary=""elementary cellular automata algorithm"">&nbsp;</a></p>

<p>The examples in this chapter will begin with a simulation of Wolfram’s work.   To understand Wolfram’s elementary CA, we should ask ourselves the question: “What is the simplest cellular automaton we can imagine?”  What’s exciting about this question and its answer is that even with the simplest CA imaginable, we will see the properties of complex systems at work.</p>

<p>Let’s build Wolfram’s elementary CA from scratch.  Concepts first, then code.   What are the three key elements of a CA?</p>

<p>1) <strong><em>Grid</em></strong>.  The simplest grid would be one-dimensional: a line of cells.</p>

<figure id="chapter07_figure2">
<img src="imgs/chapter07/ch07_02.png" alt="Figure 7.2"/>
<figcaption/>
</figure>
<p>2) <strong><em>States</em></strong>.  The simplest set of states (beyond having only one state) would be two states: 0 or 1.</p>

<figure id="chapter07_figure3">
<img src="imgs/chapter07/ch07_03.png" alt="Figure 7.3"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""neighborhood (cellular automata)"">&nbsp;</a></p>

<p>3) <strong><em>Neighborhood</em></strong>.  The simplest neighborhood in one dimension for any given cell would be the cell itself and its two adjacent neighbors: one to the left and one to the right.</p>

<figure id="chapter07_figure4">
<img src="imgs/chapter07/ch07_04.png" alt="Figure 7.4: A neighborhood is three cells."/>
<figcaption/>
</figure>
<p>So we begin with a line of cells, each with an initial state (let’s say it is random), and each with two neighbors.   We’ll have to figure out what we want to do with the cells on the edges (since those have only one neighbor each), but this is something we can sort out later.</p>

<figure id="chapter07_figure5">
<img src="imgs/chapter07/ch07_05.png" alt="Figure 7.5: The edge cell only has a neighborhood of two."/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""time and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""time"" data-secondary=""cellular automata and"">&nbsp;</a></p>

<p>We haven’t yet discussed, however, what is perhaps the most important detail of how cellular automata work—<em>time</em>.   We’re not really talking about real-world time here, but about the CA living over a period of <em>time</em>, which could also be called a <strong><em>generation</em></strong> and, in our case, will likely refer to the <strong><em>frame count</em></strong> of an animation.  The figures above show us the CA at time equals 0 or generation 0.  The questions we have to ask ourselves are: <em>How do we compute the states for all cells at generation 1?  And generation 2?</em>  And so on and so forth.</p>

<figure id="chapter07_figure6">
<img src="imgs/chapter07/ch07_06.png" alt="Figure 7.6"/>
<figcaption/>
</figure>
<p>Let’s say we have an individual cell in the CA, and let’s call it CELL.   The formula for calculating CELL’s state at any given time <strong var>t</strong> is as follows:</p>

<p><strong formula>CELL state at time t = f(CELL neighborhood at time t - 1)</strong></p>

<p>In other words, a cell’s new state is a function of all the states in the cell’s neighborhood at the previous moment in time (or during the previous generation).  We calculate a new state value by looking at all the previous neighbor states.</p>

<figure id="chapter07_figure7">
<img src="imgs/chapter07/ch07_07.png" alt="Figure 7.7"/>
<figcaption/>
</figure>
<p>Now, in the world of cellular automata, there are many ways we could compute a cell’s state from a group of cells.  Consider blurring an image.  (Guess what? Image processing works with CA-like rules.)  A pixel’s new state (i.e. its color) is the average of all of its neighbors’ colors.  We could also say that a cell’s new state is the sum of all of its neighbors’ states.   With Wolfram’s elementary CA, however, we can actually do something a bit simpler and seemingly absurd: We can look at all the possible configurations of a cell and its neighbor and define the state outcome for every possible configuration.  It seems ridiculous—wouldn’t there be way too many possibilities for this to be practical?   Let’s give it a try.</p>

<p>We have three cells, each with a state of 0 or 1.  How many possible ways can we configure the states?  If you love binary, you’ll notice that three cells define a 3-bit number, and how high can you count with 3 bits?  Up to 8.  Let’s have a look.</p>

<figure id="chapter07_figure8">
<img src="imgs/chapter07/ch07_08.png" alt="Figure 7.8"/>
<figcaption/>
</figure>
<p>Once we have defined all the possible neighborhoods, we need to define an outcome (new state value: 0 or 1) for each neighborhood configuration.</p>

<figure id="chapter07_figure9">
<img src="imgs/chapter07/ch07_09.png" alt="Figure 7.9"/>
<figcaption/>
</figure>
<p>The standard Wolfram model is to start generation 0 with all cells having a state of 0 except for the middle cell, which should have a state of 1.</p>

<figure id="chapter07_figure10">
<img src="imgs/chapter07/ch07_10.png" alt="Figure 7.10"/>
<figcaption/>
</figure>
<p>Referring to the ruleset above, let’s see how a given cell (we&#8217;ll pick the center one) would change from generation 0 to generation 1.</p>

<figure id="chapter07_figure11">
<img src="imgs/chapter07/ch07_11.png" alt="Figure 7.11"/>
<figcaption/>
</figure>
<p>Try applying the same logic to all of the cells above and fill in the empty cells.</p>

<p>Now, let’s go past just one generation and color the cells —0 means white, 1 means black—and stack the generations, with each new generation appearing below the previous one.</p>

<figure id="chapter07_figure12" class="screenshot">
<img src="imgs/chapter07/ch07_12.png" alt="Figure 7.12: Rule 90"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""Sierpiński triangle"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Sierpiński triangle"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Sierpiński" data-secondary="Wacław"">&nbsp;</a></p>

<p>The low-resolution shape we’re seeing above is the “Sierpiński triangle.” Named after the Polish mathematician Wacław Sierpiński, it’s a fractal pattern that we’ll examine in the next chapter.  That’s right: this incredibly simple system of 0s and 1s, with little neighborhoods of three cells, can generate a shape as sophisticated and detailed as the Sierpiński triangle.   Let’s look at it again, only with each cell a single pixel wide so that the resolution is much higher.</p>

<figure id="chapter07_figure13" class="screenshot">
<img src="imgs/chapter07/ch07_13.png" alt="Figure 7.13: Rule 90"/>
<figcaption/>
</figure>
<p>This particular result didn’t happen by accident.  I picked this set of rules because of the pattern it generates.  Take a look at Figure 7.8 one more time.  Notice how there are eight possible neighborhood configurations; we therefore define a “ruleset” as a list of 8 bits.</p>

<p>So this particular rule can be illustrated as follows:</p>

<figure id="chapter07_figure14">
<img src="imgs/chapter07/ch07_14.png" alt="Figure 7.14: Rule 90"/>
<figcaption/>
</figure>
<p>Eight 0s and 1s means an 8-bit number.  How many combinations of eight 0s and 1s are there?  256.  This is just like how we define the components of an RGB color.  We get 8 bits for red, green, and blue, meaning we make colors with values from 0 to 255 (256 possibilities).</p>

<p>In terms of a Wolfram elementary CA, we have now discovered that there are 256 possible rulesets.   The above ruleset is commonly referred to as “Rule 90” because if you convert the binary sequence—01011010—to a decimal number, you’ll get the integer 90.  Let’s try looking at the results of another ruleset.</p>

<figure id="chapter07_figure15" class="screenshot">
<img src="imgs/chapter07/ch07_15.png" alt="Figure 7.15: Rule 222"/>
<figcaption/>
</figure>
<figure id="chapter07_figure16" class="half-width-right">
<img src="imgs/chapter07/ch07_16.jpeg" alt="Figure 7.16: A Textile Cone Snail (Conus textile), Cod Hole, Great Barrier Reef, Australia, 7 August 2005. Photographer: Richard Ling richard@research.canon.com.au"/>
<figcaption/>
</figure>
<p>As we can now see, the simple act of creating a CA and defining a ruleset does not guarantee visually interesting results. Out of all 256 rulesets, only a handful produce compelling outcomes.  However, it&#8217;s quite incredible that even one of these rulesets for a one-dimensional CA with only two possible states can produce the patterns we see every day in nature (see Figure 7.16), and it demonstrates how valuable these systems can be in simulation and pattern generation.</p>

<p>Before we go too far down the road of how Wolfram classifies the results of varying rulesets, let’s look at how we actually build a Processing sketch that generates the Wolfram CA and visualizes it onscreen.</p>
</section>







<section data-type="sect1" id="chapter07_section3">
<h1>7.3 How to Program an Elementary CA</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""elementary" data-tertiary="implementing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""elementary cellular automata"" data-secondary=""implementing"">&nbsp;</a></p>

<p>You may be thinking: “OK, I’ve got this cell thing.  And the cell thing has some properties, like a state, what generation it’s on, who its neighbors are, where it lives pixel-wise on the screen.   And maybe it has some functions: it can display itself, it can generate its new state, etc.”  This line of thinking is an excellent one and would likely lead you to write some code like this:</p>

<pre data-type="programlisting" data-code-language="java">class Cell {

}</pre>

<p>This line of thinking, however, is not the road we will first travel.  Later in this chapter, we will discuss why an object-oriented approach could prove valuable in developing a CA simulation, but to begin, we can work with a more elementary data structure.  After all, what is an elementary CA but a list of 0s and 1s?   Certainly, we could describe the following CA generation using  an array:</p>

<figure id="chapter07_figure17">
<img src="imgs/chapter07/ch07_17.png" alt="Figure 7.17"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">int[] cells = {1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,0,0};</pre>

<p>To draw that array, we simply check if we’ve got a 0 or a 1 and create a fill accordingly.</p>

<pre data-type="programlisting" data-code-language="java">// Loop through every cell.
for (int i = 0; i &lt; cells.length; i++) {
  if (cells[i] == 0) fill(255);
  // Create a fill based on its state (0 or 1).
  else fill(0);
  stroke(0);
  rect(i*50,0,50,50);
}</pre>

<p>Now that we have the array to describe the cell states of a given generation (which we’ll ultimately consider the “current” generation), we need a mechanism by which to compute the next generation.   Let’s think about the pseudocode of what we are doing at the moment.</p>

<p><strong>For every cell in the array:</strong></p>

<ul>
<li>
<p><strong><em>Take a look at the neighborhood states: left, middle, right.</em></strong></p></li>
<li>
<p><strong><em>Look up the new value for the cell state according to some ruleset.</em></strong></p></li>
<li>
<p><strong><em>Set the cell’s state to that new value.</em></strong></p></li>
</ul>

<p>This may lead you to write some code like this:</p>

<pre data-type="programlisting" data-code-language="java">// For every cell in the array...
for (int i = 0; i &lt; cells.length; i++) {

  //[full] ...take a look at the neighborhood.
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];
  //[end]

  // Look up the new value according to the rules.
  int newstate = rules(left,middle,right);

  // Set the cell’s state to the new value.
  cell[i] = newstate;
}</pre>

<p>We’re fairly close to getting this right, but we’ve made one minor blunder and one major blunder in the above code.  Let’s talk about what we’ve done well so far.</p>

<p>Notice how easy it is to look at a cell’s neighbors.  Because an array is an ordered list of data, we can use the fact that the indices are numbered to know which cells are next to which cells.  We know that cell number 15, for example, has cell 14 to its left and 16 to its right.  More generally, we can say that for any cell <strong var>i</strong>, its neighbors are <strong var>i-1</strong> and <strong var>i+1</strong>.</p>

<p><a data-type="indexterm" data-primary=""elementary cellular automata"" data-secondary=""edge cases and"">&nbsp;</a></p>

<p>We’re also farming out the calculation of a new state value to some function called <strong function>rules()</strong>.  Obviously, we’re going to have to write this function ourselves, but the point we’re making here is modularity.  We have a basic framework for the CA in this function, and if we later want to change how the rules operate, we don’t have to touch that framework; we can simply rewrite the <strong function>rules()</strong> function to compute the new states differently.</p>

<p>So what have we done wrong?  Let’s talk through how the code will execute.  First, we look at cell index <strong var>i</strong> equals 0.  Now let’s look at 0’s neighbors.  Left is index -1.  Middle is index 0.  And right is index 1.  However, our array by definition does not have an element with the index -1.  It starts with 0.  This is a problem we’ve alluded to before: the edge cases.</p>

<p>How do we deal with the cells on the edge who don’t have a neighbor to both their left and their right?  Here are three possible solutions to this problem:</p>

<ol>
<li>
<p><strong><em>Edges remain constant.</em></strong>  This is perhaps the simplest solution.  We never bother to evaluate the edges and always leave their state value constant (0 or 1).</p></li>
<li>
<p><strong><em>Edges wrap around.</em></strong>  Think of the CA as a strip of paper and turn that strip of paper into a ring.  The cell on the left edge is a neighbor of the cell on the right and vice versa.  This can create the appearance of an infinite grid and is probably the most used solution.</p></li>
<li>
<p><strong><em>Edges have different neighborhoods and rules.</em></strong>  If we wanted to, we could treat the edge cells differently and create rules for cells that have a neighborhood of two instead of three.  You may want to do this in some circumstances, but in our case, it’s going to be a lot of extra lines of code for little benefit.</p></li>
</ol>

<p>To make the code easiest to read and understand right now, we’ll go with option #1 and just skip the edge cases, leaving their values constant.  This can be accomplished by starting the loop one cell later and ending one cell earlier:</p>

<pre data-type="programlisting" data-code-language="java">// A loop that ignores the first and last cell
for (int i = 1; i &lt; cells.length-1; i++) { //[bold]
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];
  int newstate = rules(left,middle,right);
  cell[i] = newstate;
}</pre>

<p><a data-type="indexterm" data-primary=""elementary cellular automata"" data-secondary=""generations" data-tertiary="maintaining integrity of"">&nbsp;</a></p>

<p>There’s one more problem we have to fix before we’re done.  It’s subtle and you won’t get a compilation error; the CA just won’t perform correctly.  However, identifying this problem is absolutely fundamental to the techniques behind programming CA simulations.  It all lies in this line of code:</p>

<pre data-type="programlisting" data-code-language="java">  cell[i] = newstate;</pre>

<p>This seems like a perfectly innocent line.  After all, we’ve computed the new state value and we’re simply giving the cell its new state.   But in the next iteration, you’ll discover a massive bug.  Let’s say we’ve just computed the new state for cell #5.  What do we do next?  We calculate the new state value for cell #6.</p>

<p><em>Cell #6, generation 0 = some state, 0 or 1</em><br/>
<em>Cell #6, generation 1 = a function of states for <strong>cell #5</strong>, cell #6, and cell #7 at *generation 0*</em></p>

<p>Notice how we need the value of cell #5 at generation 0 in order to calculate cell #6’s new state at generation 1?  A cell’s new state is a function of the previous neighbor states.   Do we know cell #5’s value at generation 0?   Remember, Processing just executes this line of code for <em>i = 5</em>.</p>

<pre data-type="programlisting" data-code-language="java">  cell[i] = newstate;</pre>

<p>Once this happens, we no longer have access to cell #5’s state at generation 0, and cell index 5 is storing the value for generation 1.  We cannot overwrite the values in the array while we are processing the array, because we need those values to calculate the new values.   A solution to this problem is to have two arrays, one to store the current generation states and one for the next generation states.</p>

<pre data-type="programlisting" data-code-language="java">// Another array to store the states
// for the next generation.
int[] newcells = new int[cells.length]; //[bold]

for (int i = 1; i &lt; cells.length-1; i++) {
  //[full] Look at the states from the current array.
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];
  //[end]
  int newstate = rules(left,middle,right);
  // Saving the new state in the new array
  newcells[i] = newstate; //[bold]
}</pre>

<p>Once the entire array of values is processed, we can then discard the old array and set it equal to the new array of states.</p>

<pre data-type="programlisting" data-code-language="java">// The new generation becomes the current generation.
cells = newcells; //[bold]</pre>

<p>We’re almost done.  The above code is complete except for the fact that we haven’t yet written the <strong function>rules()</strong> function that computes the new state value based on the neighborhood (left, middle, and right cells).   We know that function needs to return an integer (0 or 1) as well as receive three arguments (for the three neighbors).</p>

<pre data-type="programlisting" data-code-language="java">  // Function receives 3 ints and returns 1.
  int rules (int a, int b, int c) {</pre>

<p>Now, there are many ways we could write this function, but I’d like to start with a long-winded one that will hopefully provide a clear illustration of what we are doing.</p>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""rulesets" data-tertiary="defining"">&nbsp;</a>
<a data-type="indexterm" data-primary=""rulesets for cellular automata"">&nbsp;</a></p>

<p>Let’s first establish how we are storing the ruleset.  The ruleset, if you remember from the previous section, is a series of 8 bits (0 or 1) that defines that outcome for every possible neighborhood configuration.</p>

<figure id="chapter07_figure14">
<img src="imgs/chapter07/ch07_14.png" alt="Figure 7.14 (repeated)"/>
<figcaption/>
</figure>
<p>We can store this ruleset in Processing as an array.</p>

<pre data-type="programlisting" data-code-language="java">int[] ruleset = {0,1,0,1,1,0,1,0};</pre>

<p>And then say:</p>

<pre data-type="programlisting" data-code-language="java">if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];</pre>

<p>If left, middle, and right all have the state 1, then that matches the configuration 111 and the new state should be equal to the first value in the ruleset array.   We can now duplicate this strategy for all eight possibilities.</p>

<pre data-type="programlisting" data-code-language="java">  int rules (int a, int b, int c) {
    if      (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];
    else if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 0) return ruleset[1];
    else if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 1) return ruleset[2];
    else if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 0) return ruleset[3];
    else if (a == 0 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[4];
    else if (a == 0 &amp;&amp; b == 1 &amp;&amp; c == 0) return ruleset[5];
    else if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 1) return ruleset[6];
    else if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) return ruleset[7];
    // For this function to be valid, we have to make sure something is returned
    // in cases where the states do not match one of the eight possibilities.
    // We know this is impossible given the rest of our code, but Processing does not.
    return 0;
  }</pre>

<p>I like having the example written as above because it describes line by line exactly what is happening for each neighborhood configuration.  However, it’s not a great solution.  After all, what if we design a CA that has 4 possible states (0-3) and suddenly we have 64 possible neighborhood configurations?  With 10 possible states, we have 1,000 configurations.  Certainly we don’t want to type in 1,000 lines of code!</p>

<p>Another solution, though perhaps a bit more difficult to follow, is to convert the neighborhood configuration (a 3-bit number) into a regular integer and use that value as the index into the ruleset array.  This can be done in Java like so.</p>

<pre data-type="programlisting" data-code-language="java">  int rules (int a, int b, int c) {
    // A quick way to join three bits into a String
    String s = "" + a + b + c;

    // The second argument ‘2’ indicates that we intend to
    // parse a binary number (base 2).
    int index = Integer.parseInt(s,2);

    return ruleset[index];
  }</pre>

<p>There’s one tiny problem with this solution, however.  Let’s say we are implementing rule 222:</p>

<pre data-type="programlisting" data-code-language="java">// Rule 222
int[] ruleset = {1,1,0,1,1,1,1,0};</pre>

<p>And we have the neighborhood “111”.    The resulting state is equal to ruleset index 0, as we see in the first way we wrote the function.</p>

<pre data-type="programlisting" data-code-language="java">    if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];</pre>

<p>If we convert “111” to a decimal number, we get 7.  But we don’t want ruleset[7]; we want ruleset[0].  For this to work, we need to write the ruleset with the bits in reverse order, i.e.</p>

<pre data-type="programlisting" data-code-language="java">// Rule 222 in “reverse” order
int[] ruleset = {0,1,1,1,1,0,1,1};</pre>

<p>So far in this section, we’ve written everything we need to compute the generations for a Wolfram elementary CA.    Let’s take a moment to organize the above code into a class, which will ultimately help in the design of our overall sketch.</p>

<pre data-type="programlisting" data-code-language="java">class CA {
  //[full] We need an array for the cells and
  // one for the rules.
  int[] cells;
  int[] ruleset;
  //[end]

  CA() {
    cells = new int[width];
    // Arbitrarily starting with rule 90
    ruleset = {0,1,0,1,1,0,1,0};

    for (int i = 0; i &lt; cells.length; i++) {
      cells[i] = 0;
    }
    // All cells start with state 0, except the center
    // cell has state 1.
    cells[cells.length/2] = 1;
  }

  void generate() {
    //[full] Compute the next generation.
    int[] nextgen = new int[cells.length];
    for (int i = 1; i &lt; cells.length-1; i++) {
      int left   = cells[i-1];
      int me     = cells[i];
      int right  = cells[i+1];
      nextgen[i] = rules(left, me, right);
    }
    //[end]
    cells = nextgen;
  }

  //[full] Look up a new state from the ruleset.
  int rules (int a, int b, int c) {
    String s = "" + a + b + c;
    int index = Integer.parseInt(s,2);
    return ruleset[index];
  }
  //[end]
}</pre>
</section>







<section data-type="sect1" id="chapter07_section4">
<h1>7.4 Drawing an Elementary CA</h1>
<p><a data-type="indexterm" data-primary=""elementary cellular automata"" data-secondary=""drawing"">&nbsp;</a></p>

<p>What’s missing?  Presumably, it’s our intention to display cells and their states in visual form.  As we saw earlier, the standard technique for doing this is to stack the generations one on top of each other and draw a rectangle that is black (for state 1) or white (for state 0).</p>

<figure id="chapter07_figure12" class="screenshot">
<img src="imgs/chapter07/ch07_12.png" alt="Figure 7.12 (repeated)"/>
<figcaption/>
</figure>
<p>Before we implement this particular visualization, I’d like to point out two things.</p>

<p>One, this visual interpretation of the data is completely literal.  It’s useful for demonstrating the algorithms and results of Wolfram’s elementary CA, but it shouldn’t necessarily drive your own personal work.  It’s rather unlikely that you are building a project that needs precisely this algorithm with this visual style.  So while learning to draw the CA in this way will help you understand and implement CA systems, this skill should exist only as a foundation.</p>

<p>Second, the fact that we are visualizing a one-dimensional CA with a two-dimensional image can be confusing.  It’s very important to remember that this is not a 2D CA.  We are simply choosing to show a history of all the generations stacked vertically.  This technique creates a two-dimensional image out of many instances of one-dimensional data.  But the system itself is one-dimensional.  Later, we are going to look at an actual 2D CA (the Game of Life) and discuss how we might choose to display such a system.</p>

<p>The good news is that drawing the CA is not particularly difficult.  Let’s begin by looking at how we would render a single generation.  Assume we have a Processing window 600 pixels wide and we want each cell to be a 10x10 square.  We therefore have a CA with 60 cells.  Of course, we can calculate this value dynamically.</p>

<pre data-type="programlisting" data-code-language="java">int w = 10;
// How many cells fit across given a certain width
int[] cells = new int[width/w];</pre>

<p>Assuming we’ve gone through the process of generating the cell states (which we did in the previous section), we can now loop through the entire array of cells, drawing a black cell when the state is 1 and a white one when the state is 0.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; cells.length; i++) {
  //[full] Black or white fill?
  if (cells[i] == 1) fill(0);
  else               fill(255);
  //[end]
  // Notice how the x-location is the cell index times the cell width.
  // In the above scenario, this would give us cells located at x equals 0, 10, 20, 30, all the way up to 600.
  rect(i*w, 0, w, w);
}</pre>

<p>In truth, we could optimize the above by having a white background and only drawing when there is a black cell (saving us the work of drawing many white squares), but in most cases this solution is good enough (and necessary for other more sophisticated designs with varying colors, etc.)  Also, if we wanted each cell to be represented as a single pixel, we would not want to use Processing’s <strong function>rect()</strong> function, but rather access the pixel array directly.</p>

<p>In the above code, you’ll notice the y-location for each rectangle is 0.  If we want the generations to be drawn next to each other, with each row of cells marking a new generation, we’ll also need to compute a y-location based on how many iterations of the CA we’ve executed.  We could accomplish this by adding a “generation” variable (an integer) to our CA class and incrementing it each time through <strong function>generate()</strong>.  With these additions, we can now look at the CA class with all the features for both computing and drawing the CA.</p>

<figure class="screenshot" data-pde="processingjs/chapter07/Ex_7_01_WolframCA_randomizedrules/Ex_7_01_WolframCA_randomizedrules.pde processingjs/chapter07/Ex_7_01_WolframCA_randomizedrules/CA.pde">
<img src="imgs/chapter07/ch07_ex01.png" alt="ch07 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 7.1: Wolfram elementary cellular automata</strong></p>

<pre data-type="programlisting" data-code-language="java">class CA {
  int[] cells;
  int[] ruleset;
  int w = 10;
  // The CA should keep track of how
  // many generations.
  int generation = 0;
  CA() {
    cells = new int[width/w];
    ruleset = {0,1,0,1,1,0,1,0};
    cells[cells.length/2] = 1;
  }

  // Function to compute the next generation
  void generate() {
    int[] nextgen = new int[cells.length];
    for (int i = 1; i &lt; cells.length-1; i++) {
      int left   = cells[i-1];
      int me     = cells[i];
      int right  = cells[i+1];
      nextgen[i] = rules(left, me, right);
    }
    cells = nextgen;
    // Increment the generation counter.
    generation++;
  }

  int rules(int a, int b, int c) {
    String s = "" + a + b + c;
    int index = Integer.parseInt(s,2);
    return ruleset[index];
  }

  for (int i = 0; i &lt; cells.length; i++) {
    if (cells[i] == 1) fill(0);
    else               fill(255);
    // Set the y-location according to the generation.
    rect(i*w, generation*w, w, w);
  }
}</pre>

<div id="chapter07_exercise1" data-type="example">
<h5>Exercise 7.1</h5>
<p>Expand Example 7.1 to have the following feature: when the CA reaches the bottom of the Processing window, the CA starts over with a new, random ruleset.</p>
</div>

<p> </p>
<div id="chapter07_exercise2" data-type="example">
<h5>Exercise 7.2</h5>
<p>Examine what patterns occur if you initialize the first generation with each cell having a random state.</p>
</div>

<p> </p>
<div id="chapter07_exercise3" data-type="example">
<h5>Exercise 7.3</h5>
<p>Visualize the CA in a non-traditional way.  Break all the rules you can; don’t feel tied to using squares on a perfect grid with black and white.</p>
</div>

<p> </p>
<div id="chapter07_exercise4" data-type="example">
<h5>Exercise 7.4</h5>
<p>Create a visualization of the CA that scrolls upwards as the generations increase so that you can view the generations to “infinity.”  Hint: instead of keeping track of only one generation at a time, you’ll need to store a history of generations, always adding a new one and deleting the oldest one in each frame.</p>
</div>
</section>







<section data-type="sect1" id="chapter07_section5">
<h1>7.5 Wolfram Classification</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""Wolfram classification"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram classification"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram" data-secondary="Stephen"" data-tertiary=""Wolfram classification"">&nbsp;</a></p>

<p>Before we move on to looking at CA in two dimensions, it’s worth taking a brief look at Wolfram’s classification for cellular automata.  As we noted earlier, the vast majority of elementary CA rulesets produce uninspiring results, while some result in wondrously complex patterns like those found in nature.  Wolfram has divided up the range of outcomes into four classes:</p>

<figure id="chapter07_figure18" class="screenshot" data-pde="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_222/Ex_7_04_WolframCA_scrolling_222.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_222/CA.pde">
<img src="imgs/chapter07/ch07_18.png" alt="Figure 7.18: Rule 222"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Uniformity class (Wolfram classification)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram classification"" data-secondary=""Uniformity class"">&nbsp;</a></p>

<p><strong><em>Class 1: Uniformity.</em></strong>  Class 1 CAs end up, after some number of generations, with every cell constant.   This is not terribly exciting to watch.  Rule 222 (above) is a class 1 CA; if you run it for enough generations, every cell will eventually become and remain black.</p>

<figure id="chapter07_figure19" class="screenshot" data-pde="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_190/Ex_7_04_WolframCA_scrolling_190.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_190/CA.pde">
<img src="imgs/chapter07/ch07_19.png" alt="Figure 7.19: Rule 190"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Repetition class (Wolfram classification)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram classification"" data-secondary=""Repetition class"">&nbsp;</a></p>

<p><strong><em>Class 2: Repetition.</em></strong>  Like class 1 CAs, class 2 CAs remain stable, but the cell states are not constant.  Rather, they oscillate in some regular pattern back and forth from 0 to 1 to 0 to 1 and so on.   In rule 190 (above), each cell follows the sequence 11101110111011101110.</p>

<figure id="chapter07_figure20" class="screenshot" data-pde="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_30/Ex_7_04_WolframCA_scrolling_30.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_30/CA.pde">
<img src="imgs/chapter07/ch07_20.png" alt="Figure 7.20: Rule 30"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Random class (Wolfram classification)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram classification"" data-secondary=""Random class"">&nbsp;</a></p>

<p><strong><em>Class 3: Random.</em></strong>  Class 3 CAs appear random and have no easily discernible pattern.   In fact, rule 30 (above) is used as a random number generator in Wolfram’s Mathematica software.  Again, this is a moment where we can feel amazed that such a simple system with simple rules can descend into a chaotic and random pattern.</p>

<figure id="chapter07_figure21" class="screenshot" data-pde="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_110/Ex_7_04_WolframCA_scrolling_110.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_110/CA.pde">
<img src="imgs/chapter07/ch07_21.png" alt="Figure 7.21: Rule 110"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Complexity class (Wolfram classification)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Wolfram classification"" data-secondary=""Complexity class"">&nbsp;</a></p>

<p><strong><em>Class 4: Complexity.</em></strong>  Class 4 CAs can be thought of as a mix between class 2 and class 3.  One can find repetitive, oscillating patterns inside the CA, but where and when these patterns appear is unpredictable and seemingly random.  Class 4 CAs exhibit the properties of complex systems that we described earlier in this chapter and in Chapter 6.  If a class 3 CA wowed you, then a class 4 like Rule 110 above should really blow your mind.</p>

<div id="chapter07_exercise5" data-type="example">
<h5>Exercise 7.5</h5>
<p>Create a Processing sketch that saves an image for every possible ruleset.  Can you classify them?</p>
</div>
</section>







<section data-type="sect1" id="chapter07_section6">
<h1>7.6 The Game of Life</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""two-dimensional"">&nbsp;</a>
<a data-type="indexterm" data-primary=""two-dimensional cellular automata"">&nbsp;</a></p>

<p>The next step we are going to take is to move from a one-dimensional CA to a two-dimensional one.  This will introduce some additional complexity; each cell will have a bigger neighborhood, but that will open up the door to a range of possible applications.  After all, most of what we do in computer graphics lives in two dimensions, and this chapter will demonstrate how to apply CA thinking to what we draw in our Processing sketches.</p>

<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""Game of Life as"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Conway" data-secondary="John"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Game of Life"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Gardner" data-secondary="Martin"">&nbsp;</a></p>

<p>In 1970, Martin Gardner wrote an article in <em>Scientific American</em> that documented mathematician John Conway’s new “Game of Life,” describing it as “recreational” mathematics and suggesting that the reader get out a chessboard and some checkers and “play.”    While the Game of Life has become something of a computational cliché (make note of the myriad projects that display the Game of Life on LEDs, screens, projection surfaces, etc.), it is still important for us to build it from scratch.  For one, it provides a good opportunity to practice our skills with two-dimensional arrays, object orientation, etc.   But perhaps more importantly, its core principles are tied directly to our core goals—simulating the natural world with code.    Though we may want to avoid simply duplicating it without a great deal of thought or care, the algorithm and its technical implementation will provide us with the inspiration and foundation to build simulations that exhibit the characteristics and behaviors of biological systems of reproduction.</p>

<p>Unlike von Neumann, who created an extraordinarily complex system of states and rules, Conway wanted to achieve a similar “lifelike” result with the simplest set of rules possible.    Martin Gardner outlined Conway’s goals as follows:</p>

<blockquote >
“1. There should be no initial pattern for which there is a simple proof that the population can grow without limit. 2. There should be initial patterns that apparently do grow without limit. 3. There should be simple initial patterns that grow and change for a considerable period of time before coming to an end in three possible ways: fading away completely (from overcrowding or becoming too sparse), settling into a stable configuration that remains unchanged thereafter, or entering an oscillating phase in which they repeat an endless cycle of two or more periods.”
<span class="attribution">
—Martin Gardner, <span style="font-style:normal"><a href="http://www.ibiblio.org/lifepatterns/october1970.html">Scientific American</a></span> 223 (October 1970): 120-123.
</span>
</blockquote>
<p>The above might sound a bit cryptic, but it essentially describes a Wolfram class 4 CA.  The CA should be patterned but unpredictable over time, eventually settling into a uniform or oscillating state.  In other words, though Conway didn’t use this terminology, it should have all those properties of a <em>complex system</em> that we keep mentioning.</p>

<p>Let’s look at how the Game of Life works.  It won’t take up too much time or space, since we’ve covered the basics of CA already.</p>

<figure id="chapter07_figure22" class="half-width-right">
<img src="imgs/chapter07/ch07_22.png" alt="Figure 7.22"/>
<figcaption/>
</figure>
<p>First, instead of a line of cells, we now have a two-dimensional matrix of cells.   As with the elementary CA, the possible states are 0 or 1.  Only in this case, since we’re talking about “life," 0 means dead and 1 means alive.</p>

<p>The cell’s neighborhood has also expanded.  If a neighbor is an adjacent cell, a neighborhood is now nine cells instead of three.</p>

<p>With three cells, we had a 3-bit number or eight possible configurations.  With nine cells, we have 9 bits, or 512 possible neighborhoods.  In most cases, it would be impractical to define an outcome for every single possibility.  The Game of Life gets around this problem by defining a set of rules according to general characteristics of the neighborhood.  In other words, is the neighborhood overpopulated with life?  Surrounded by death?  Or just right?  Here are the rules of life.</p>

<p><a data-type="indexterm" data-primary=""Game of Life"" data-secondary=""rules of"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>Death.</em></strong>  If a cell is alive (state = 1) it will die (state becomes 0) under the following circumstances.</p>
<ul>
<li>
<p><strong><em>Overpopulation:</em></strong> If the cell has four or more alive neighbors, it dies.</p></li>
<li>
<p><strong><em>Loneliness:</em></strong> If the cell has one or fewer alive neighbors, it dies.</p></li>
</ul>
</li>
<li>
<p><strong><em>Birth.</em></strong>  If a cell is dead (state = 0) it will come to life (state becomes 1) if it has exactly three alive neighbors (no more, no less).</p></li>
<li>
<p><strong><em>Stasis.</em></strong> In all other cases, the cell state does not change.  To be thorough, let’s describe those scenarios.</p>
<ul>
<li>
<p><strong><em>Staying Alive:</em></strong> If a cell is alive and has exactly two or three live neighbors, it stays alive.</p></li>
<li>
<p><strong><em>Staying Dead:</em></strong> If a cell is dead and has anything other than three live neighbors, it stays dead.</p></li>
</ul>
</li>
</ol>

<p>Let’s look at a few examples.</p>

<figure id="chapter07_figure23">
<img src="imgs/chapter07/ch07_23.png" alt="Figure 7.23"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Game of Life"" data-secondary=""drawing"">&nbsp;</a></p>

<p>With the elementary CA, we were able to look at all the generations next to each other, stacked as rows in a 2D grid.  With the Game of Life, however, the CA itself is in two dimensions.  We could try creating an elaborate 3D visualization of the results and stack all the generations in a cube structure (and in fact, you might want to try this as an exercise).  Nevertheless, the typical way the Game of Life is displayed is to treat each generation as a single frame in an animation.  So instead of viewing all the generations at once, we see them one at a time, and the result resembles rapidly growing bacteria in a petri dish.</p>

<p>One of the exciting aspects of the Game of Life is that there are initial patterns that yield intriguing results.  For example, some remain static and never change.</p>

<figure id="chapter07_figure24">
<img src="imgs/chapter07/ch07_24.png" alt="Figure 7.24"/>
<figcaption/>
</figure>
<p>There are patterns that oscillate back and forth between two states.</p>

<figure id="chapter07_figure25">
<img src="imgs/chapter07/ch07_25.png" alt="Figure 7.25"/>
<figcaption/>
</figure>
<p>And there are also patterns that from generation to generation move about the grid.  (It’s important to note that the cells themselves aren&#8217;t actually moving, although we see the appearance of motion in the result as the cells turn on and off.)</p>

<figure id="chapter07_figure26">
<img src="imgs/chapter07/ch07_26.png" alt="Figure 7.26"/>
<figcaption/>
</figure>
<p>If you are interested in these patterns, there are several good “out of the box” Game of Life demonstrations online that allow you to configure the CA’s initial state and watch it run at varying speeds.  Two examples you might want to examine are:</p>

<p><a data-type="indexterm" data-primary=""Conway's Game of Life (Klise)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Exploring Emergence (Resnick/Silverman)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Klise" data-secondary="Steven"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Resnick" data-secondary="Mitchel"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Silverman" data-secondary="Brian"">&nbsp;</a></p>

<ul>
<li>
<p><a href="http://llk.media.mit.edu/projects/emergence/">Exploring Emergence</a> by Mitchel Resnick and Brian Silverman, Lifelong Kindergarten Group, MIT Media Laboratory</p></li>
<li>
<p><a href="http://stevenklise.github.com/ConwaysGameOfLife">Conway&#8217;s Game of Life</a> by Steven Klise  (uses Processing.js!)</p></li>
</ul>

<p>For the example we’ll build from scratch in the next section, it will be easier to simply randomly set the states for each cell.</p>
</section>







<section data-type="sect1" id="chapter07_section7">
<h1>7.7  Programming the Game of Life</h1>
<p><a data-type="indexterm" data-primary=""two-dimensional cellular automata"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Now we just need to extend our code from the Wolfram CA to two dimensions.   We used a one-dimensional array to store the list of cell states before, and for the Game of Life, we can use a <a href="http://www.processing.org/learning/2darray/">two-dimensional array</a>.</p>

<pre data-type="programlisting" data-code-language="java">int[][] board = new int[columns][rows];</pre>

<p>We’ll begin by initializing each cell of the board with a random state: 0 or 1.</p>

<pre data-type="programlisting" data-code-language="java">for (int x = 0; x &lt; columns; x++) {
  for (int y = 0; y &lt; rows; y++) {
    // Initialize each cell with a 0 or 1.
    current[x][y] = int(random(2));
  }
}</pre>

<p>And to compute the next generation, just as before, we need a fresh 2D array to write to as we analyze each cell’s neighborhood and calculate a new state.</p>

<pre data-type="programlisting" data-code-language="java">int[][] next = new int[columns][rows];

for (int x = 0; x &lt; columns; x++) {
  for (int y = 0; y &lt; rows; y++) {

    // We need a new state for each cell.
    next[x][y] = _______________?;

  }
}</pre>

<figure id="chapter07_figure27" class="half-width-right">
<img src="imgs/chapter07/ch07_27.png" alt="Figure 7.27"/>
<figcaption/>
</figure>
<p>OK. Before we can sort out how to actually calculate the new state, we need to know how we can reference each cell’s neighbor.  In the case of the 1D CA, this was simple: if a cell index was <strong var>i</strong>, its neighbors were i-1 and i+1.  Here each cell doesn’t have a single index, but rather a column and row index: x,y.  As shown in Figure 7.27, we can see that its neighbors are: <em>(x-1,y-1) (x,y-1), (x+1,y-2), (x-1,y), (x+1,y), (x-1,y+1), (x,y+1),</em> and <em>(x+1,y+1)</em>.</p>

<p>All of the Game of Life rules operate by knowing how many neighbors are alive.  So if we create a neighbor counter variable and increment it each time we find a neighbor with a state of 1, we’ll have the total of live neighbors.</p>

<pre data-type="programlisting" data-code-language="java">int neighbors = 0;

//[full] Top row of neighbors
if (board[x-1][y-1] == 1) neighbors++;
if (board[x  ][y-1] == 1) neighbors++;
if (board[x+1][y-1] == 1) neighbors++;
//[end]

//[full] Middle row of neighbors
// (note we don’t count self)
if (board[x-1][y]   == 1) neighbors++;
if (board[x+1][y]   == 1) neighbors++;
//[end]

//[full] Bottom row of neighbors
if (board[x-1][y+1] == 1) neighbors++;
if (board[x  ][y+1] == 1) neighbors++;
if (board[x+1][y+1] == 1) neighbors++;
//[end]</pre>

<p>And again, just as with the Wolfram CA, we find ourselves in a situation where the above is a useful and clear way to write the code for teaching purposes, allowing us to see every step (each time we find a neighbor with a state of one, we increase a counter).  Nevertheless, it’s a bit silly to say, “If the cell state equals one, add one to a counter” when we could just say, “Add the cell state to a counter.”   After all, if the state is only a 0 or 1, the sum of all the neighbors’ states will yield the total number of live cells.   Since the neighbors are arranged in a mini 3x3 grid, we can add them all up with another loop.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = -1; i &lt;= 1; i++) {
  for (int j = -1; j &lt;= 1; j++) {
    // Add up all the neighbors’ states.
    neighbors += board[x+i][y+j];
   }
}</pre>

<p>Of course, we’ve made a mistake in the code above.   In the Game of Life, the cell itself does not count as one of the neighbors.  We could use a conditional to skip adding the state when both <strong var>i</strong> and <strong var>j</strong> equal 0, but another option would be to just subtract the cell state once we’ve finished the loop.</p>

<pre data-type="programlisting" data-code-language="java">// Whoops! Subtract the cell’s state,
// which we don’t want in the total.
neighbors -= board[x][y];</pre>

<p>Finally, once we know the total number of live neighbors, we can decide what the cell’s new state should be according to the rules: birth, death, or stasis.</p>

<pre data-type="programlisting" data-code-language="java">//[full] If it is alive and has less than 2 live neighbors, it dies from loneliness.
if      ((board[x][y] == 1) &amp;&amp; (neighbors &lt;  2)) {
  next[x][y] = 0;
}
//[end]

//[full] If it is alive and has more than 3 live neighbors, it dies from overpopulation.
else if ((board[x][y] == 1) &amp;&amp; (neighbors &gt;  3)) {
  next[x][y] = 0;
}
//[end]

//[full] If it is dead and has exactly 3 live neighbors, it is born!
else if ((board[x][y] == 0) &amp;&amp; (neighbors == 3)) {
  next[x][y] = 1;
}
//[end]

//[full] In all other cases, its state remains the same.
else {
  next[x][y] = board[x][y];
}
//[end]</pre>

<p>Putting this all together, we have:</p>

<pre data-type="programlisting" data-code-language="java">// The next board
int[][] next = new int[columns][rows];

//[full] Looping but skipping the edge cells
for (int x = 1; x &lt; columns-1; x++) {
  for (int y = 1; y &lt; rows-1; y++) {
  //[end]

    // Add up all the neighbor states to
    // calculate the number of live neighbors.
    int neighbors = 0;
    for (int i = -1; i &lt;= 1; i++) {
      for (int j = -1; j &lt;= 1; j++) {
        neighbors += board[x+i][y+j];
      }
    }

    // Correct by subtracting the cell state itself.
    neighbors -= board[x][y];

    //[full] &lt;b&gt;The rules of life!&lt;/b&gt;

    if      ((board[x][y] == 1) &amp;&amp; (neighbors &lt;  2)) next[x][y] = 0;
    else if ((board[x][y] == 1) &amp;&amp; (neighbors &gt;  3)) next[x][y] = 0;
    else if ((board[x][y] == 0) &amp;&amp; (neighbors == 3)) next[x][y] = 1;
    else next[x][y] = board[x][y];
    //[end]
  }
}

// The 2D array “next” is now the current board.
board = next;</pre>

<p>Finally, once the next generation is calculated, we can employ the same method we used to draw the Wolfram CA—a square for each spot, white for off, black for on.</p>

<figure class="screenshot" data-pde="processingjs/chapter07/_7_02_GameOfLifeSimple/_7_02_GameOfLifeSimple.pde processingjs/chapter07/_7_02_GameOfLifeSimple/GOL.pde">
<img src="imgs/chapter07/ch07_ex02.png" alt="ch07 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 7.2: Game of Life</strong></p>

<pre data-type="programlisting" data-code-language="java">for ( int i = 0; i &lt; columns;i++) {
  for ( int j = 0; j &lt; rows;j++) {

    // Black when state = 1
    if ((board[i][j] == 1)) fill(0);
    // White when state = 0
    else fill(255);
    stroke(0);

    rect(i*w, j*w, w, w);
  }
}</pre>

<div id="chapter07_exercise6" data-type="example">
<h5>Exercise 7.6</h5>
<p>Create a Game of Life simulation that allows you to manually configure the grid by drawing or with specific known patterns.</p>
</div>

<div id="chapter07_exercise7" data-type="example">
<h5>Exercise 7.7</h5>
<p>Implement “wrap-around” for the Game of Life so that cells on the edges have neighbors on the opposite side of the grid.</p>
</div>

<div id="chapter07_exercise8" data-type="example">
<h5>Exercise 7.8</h5>
<p>While the above solution (Example 7.2) is convenient, it is not particularly memory-efficient.  It creates a new 2D array for every frame of animation!  This matters very little for a Processing desktop application, but if you were implementing the Game of Life on a microcontroller or mobile device, you’d want to be more careful.    One solution is to have only two arrays and constantly swap them, writing the next set of states into whichever one isn’t the current array.  Implement this particular solution.</p>
</div>
</section>







<section data-type="sect1" id="chapter07_section8">
<h1>7.8 Object-Oriented Cells</h1>
<p><a data-type="indexterm" data-primary=""object"" data-secondary=""cells in cellular automata as"">&nbsp;</a>
<a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""cellular automata and"">&nbsp;</a></p>

<p>Over the course of the previous six chapters, we’ve slowly built examples of systems of <em>objects</em> with properties that move about the screen.  And in this chapter, although we’ve been talking about a “cell” as if it were an object, we actually haven’t been using any object orientation in our code (other than a class to describe the CA system as a whole).   This has worked because a cell is such an enormously simple object (a single bit).  However, in a moment, we are going to discuss some ideas for further developing CA systems, many of which involve keeping track of multiple properties for each cell.  For example, what if a cell needed to remember its last ten states?  Or what if we wanted to apply some of our motion and physics thinking to a CA and have the cells move about the window, dynamically changing their neighbors from frame to frame?</p>

<p>To accomplish any of these ideas (and more), it would be helpful to see how we might treat a cell as an object with multiple properties, rather than as a single 0 or 1.  To show this, let’s just recreate the Game of Life simulation. Only instead of:</p>

<pre data-type="programlisting" data-code-language="java">  int[][] board;</pre>

<p>Let’s have:</p>

<pre data-type="programlisting" data-code-language="java">  Cell[][] board;</pre>

<p>where <strong klass>Cell</strong> is a class we will write.   What are the properties of a <strong klass>Cell</strong> object?   In our Game of Life example, each cell has a location and size, as well as a state.</p>

<pre data-type="programlisting" data-code-language="java">class Cell {

  //[full] Location and size
  float x, y;
  float w;
  //[end]

  // What is the cell’s state?
  int state;</pre>

<p>In the non-OOP version, we used a separate 2D array to keep track of the states for the current and next generation.   By making a cell an object, however, each cell could keep track of both states.   In this case, we’ll think of the cell as remembering its previous state (for when new states need to be computed).</p>

<pre data-type="programlisting" data-code-language="java">  // What was its previous state?
  int previous;</pre>

<p>This allows us to visualize more information about what the state is doing.  For example, we could choose to color a cell differently if its state has changed.  For example:</p>

<figure class="screenshot" data-pde="processingjs/chapter07/_7_03_GameOfLifeOOP/_7_03_GameOfLifeOOP.pde processingjs/chapter07/_7_03_GameOfLifeOOP/GOL.pde processingjs/chapter07/_7_03_GameOfLifeOOP/Cell.pde">
<img src="imgs/chapter07/ch07_ex02.png" alt="ch07 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 7.3: Game of Life OOP</strong></p>

<pre data-type="programlisting" data-code-language="java">void display() {
  // If the cell is born, color it blue!
  if (previous == 0 &amp;&amp; state == 1) fill(0,0,255);
  else if (state == 1) fill(0);

  //[offset-down] If the cell dies, color it red!
  else if (previous == 1 &amp;&amp; state == 0) fill(255,0,0);
  else fill(255);

  rect(x, y, w, w);
}</pre>

<p>Not much else about the code (at least for our purposes here) has to change.  The neighbors can still be counted the same way; the difference is that we now need to refer to the object’s state variables as we loop through the 2D array.</p>

<pre data-type="programlisting" data-code-language="java">for (int x = 1; x &lt; columns-1; x++) {
  for (int y = 1; y &lt; rows-1; y++) {

    int neighbors = 0;
    for (int i = -1; i &lt;= 1; i++) {
      for (int j = -1; j &lt;= 1; j++) {
        // Use the previous state when tracking neighbors.
        neighbors += board[x+i][y+j].previous; //[bold]
      }
    }
    neighbors -= board[x][y].previous;

    //[full]
    // We are calling a function newState() to assign a new state to each cell.


    if      ((board[x][y].state == 1) &amp;&amp; (neighbors &lt;  2)) board[x][y].newState(0);
    else if ((board[x][y].state == 1) &amp;&amp; (neighbors &gt;  3)) board[x][y].newState(0);
    else if ((board[x][y].state == 0) &amp;&amp; (neighbors == 3)) board[x][y].newState(1);
    //[end]
    // else do nothing!
  }
}</pre>
</section>







<section data-type="sect1" id="chapter07_section9">
<h1>7.9 Variations of Traditional CA</h1>
<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""variations of"">&nbsp;</a></p>

<p>Now that we have covered the basic concepts, algorithms, and programming strategies behind the most famous 1D and 2D cellular automata, it’s time to think about how you might take this foundation of code and build on it, developing creative applications of CAs in your own work.  In this section, we’ll talk through some ideas for expanding the features of the CA examples.  Example answers to each of these exercises can be found on the book website.</p>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""non-rectangular grids and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-rectangular grids (cellular automata)"">&nbsp;</a></p>

<p><strong><em>1) Non-rectangular Grids</em></strong>.  There’s no particular reason why you should limit yourself to having your cells on a rectangular grid.  What happens if you design a CA with another type of shape?</p>

<div id="chapter07_exercise9" data-type="example">
<h5>Exercise 7.9</h5>
<p>Create a CA using a grid of hexagons (as below), each with six neighbors.</p>

<figure>
<img src="imgs/chapter07/ch07_exc09.png" alt="ch07 exc09"/>
<figcaption/>
</figure></div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""probabilistic"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probabilistic (cellular automata)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""cellular automata based on"">&nbsp;</a></p>

<p><strong><em>2) Probabilistic</em></strong>.  The rules of a CA don’t necessarily have to define an exact outcome.</p>

<div id="chapter07_exercise10" data-type="example">
<h5>Exercise 7.10</h5>
<p>Rewrite the Game of Life rules as follows:</p>

<p>Overpopulation: If the cell has four or more alive neighbors, it has a 80% chance of dying.<br/>
Loneliness: If the cell has one or fewer alive neighbors, it has a 60% chance of dying.<br/>
Etc.</p>
</div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""continuous"">&nbsp;</a>
<a data-type="indexterm" data-primary=""continuous (cellular automata)"">&nbsp;</a></p>

<p><strong><em>3) Continuous</em></strong>. We’ve looked at examples where the cell’s state can only be a 1 or a 0.  But what if the cell’s state was a floating point number between 0 and 1?</p>

<div id="chapter07_exercise11" data-type="example">
<h5>Exercise 7.11</h5>
<p>Adapt Wolfram elementary CA to have the state be a float.  You could define rules such as, “If the state is greater than 0.5” or “&#8230;less than 0.2.”</p>
</div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""image processing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""image processing (cellular automata)"">&nbsp;</a></p>

<p><strong><em>4) Image Processing</em></strong>.  We briefly touched on this earlier, but many image-processing algorithms operate on CA-like rules.  Blurring an image is creating a new pixel out of the average of a neighborhood of pixels.   Simulations of ink dispersing on paper or water rippling over an image can be achieved with CA rules.</p>

<div id="chapter07_exercise12" data-type="example">
<h5>Exercise 7.12</h5>
<p>Create a CA in which a pixel is a cell and a color is its state.</p>
</div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""historical"">&nbsp;</a>
<a data-type="indexterm" data-primary=""historical (cellular automata)"">&nbsp;</a></p>

<p><strong><em>5) Historical</em></strong>.  In the Game of Life object-oriented example, we used two variables to keep track of its state: current and previous.  What if you use an array to keep track of a cell’s state history?   This relates to the idea of a “complex adaptive system,” one that has the ability to adapt and change its rules over time by learning from its history.  We’ll see an example of this in Chapter 10: Neural Networks.</p>

<div id="chapter07_exercise13" data-type="example">
<h5>Exercise 7.13</h5>
<p>Visualize the Game of Life by coloring each cell according to how long it’s been alive or dead.  Can you also use the cell’s history to inform the rules?</p>
</div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""moving cells"">&nbsp;</a>
<a data-type="indexterm" data-primary=""moving cells (cellular automata)"">&nbsp;</a></p>

<p><strong><em>6) Moving cells</em></strong>.  In these basic examples, cells have a fixed position on a grid, but you could build a CA with cells that have no fixed position and instead move about the screen.</p>

<div id="chapter07_exercise14" data-type="example">
<h5>Exercise 7.14</h5>
<p>Use CA rules in a flocking system.  What if each boid had a state (that perhaps informs its steering behaviors) and its neighborhood changed from frame to frame as it moved closer to or further from other boids?</p>
</div>

<p><a data-type="indexterm" data-primary=""cellular automaton (automata)"" data-secondary=""nesting"">&nbsp;</a>
<a data-type="indexterm" data-primary=""nesting (cellular automata)"">&nbsp;</a></p>

<p><strong><em>7) Nesting</em></strong>.  Another feature of complex systems is that they can be nested.   Our world tends to work this way: a city is a complex system of people, a person is a complex system of organs, an organ is a complex system of cells, and so on and so forth.</p>

<div id="chapter07_exercise15" data-type="example">
<h5>Exercise 7.15</h5>
<p>Design a CA in which each cell itself is a smaller CA or a system of boids.</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 7 Exercise:</p>

<p>Incorporate cellular automata into your ecosystem.  Some possibilities:</p>

<ul>
<li>
<p>Give each creature a state.  How can that state drive their behavior?  Taking inspiration from CA, how can that state change over time according to its neighbors’ states?</p></li>
<li>
<p>Consider the ecosystem’s world to be a CA.  The creatures move from tile to tile.  Each tile has a state—is it land? water?  food?</p></li>
<li>
<p>Use a CA to generate a pattern for the design of a creature in your ecosystem.</p></li>
</ul>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_8_fractals">
<h1>Chapter 8.  Fractals</h1>
<blockquote class='long-quote'>
“Pathological monsters! cried the terrified mathematician<br/>
Every one of them a splinter in my eye<br/>
I hate the Peano Space and the Koch Curve<br/>
I fear the Cantor Ternary Set<br/>
The Sierpinski Gasket makes me wanna cry<br/>
And a million miles away a butterfly flapped its wings<br/>
On a cold November day a man named Benoit Mandelbrot was born”<br/>
<span class="attribution">
— Jonathan Coulton, lyrics from “Mandelbrot Set”
</span>
</blockquote>
<p><a data-type="indexterm" data-primary=""fractals"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""fractals"">&nbsp;</a></p>

<p><a data-type="indexterm" data-primary=""Euclid"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Euclidean geometry"">&nbsp;</a></p>

<p>Once upon a time, I took a course in high school called “Geometry.”  Perhaps you did too.   You learned about shapes in one dimension, two dimensions, and maybe even three.  What is the circumference of a circle?  The area of a rectangle?   The distance between a point and a line?   Come to think of it, we’ve been studying geometry all along in this book, using vectors to describe the motion of bodies in Cartesian space.  This sort of geometry is generally referred to as Euclidean geometry, after the Greek mathematician Euclid.</p>

<figure id="chapter08_figure1">
<img src="imgs/chapter08/ch08_01.png" alt="Figure 8.1"/>
<figcaption/>
</figure>
<p>For us nature coders, we have to ask the question: Can we describe our world with Euclidean geometry?    The LCD screen I’m staring at right now sure looks like a rectangle.  And the plum I ate this morning is circular.  But what if I were to look further, and consider the trees that line the street, the leaves that hang off those trees, the lightning from last night’s thunderstorm, the cauliflower I ate for dinner, the blood vessels in my body, and the mountains and coastlines that cover land beyond New York City?   Most of the stuff you find in nature cannot be described by the idealized geometrical forms of Euclidean geometry.  So if we want to start building computational designs with patterns beyond the simple shapes <strong function>ellipse()</strong>, <strong function>rect()</strong>, and <strong function>line()</strong>, it’s time for us to learn about the concepts behind and techniques for simulating the geometry of nature: fractals.</p>




<section data-type="sect1" id="chapter08_section1">
<h1>8.1  What Is a Fractal?</h1>
<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""defined"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Mandelbrot" data-secondary="Benoit"">&nbsp;</a>
<a data-type="indexterm" data-primary=""<em>Fractal Geometry of Nature" data-secondary="The</em> (Mandelbrot)"">&nbsp;</a></p>

<p>The term <strong><em>fractal</em></strong> (from the Latin <em>fractus</em>, meaning “broken”) was coined by the mathematician Benoit Mandelbrot in 1975.  In his seminal work “The Fractal Geometry of Nature,” he defines a fractal as “a rough or fragmented geometric shape that can be split into parts, each of which is (at least approximately) a reduced-size copy of the whole.”</p>

<figure id="chapter08_figure2">
<img src="imgs/chapter08/ch08_02.png" alt="Figure 8.2: One of the most well-known and recognizable fractal patterns is named for Benoit Mandelbrot himself.   Generating the Mandelbrot set involves testing the properties of complex numbers after they are passed through an iterative function.  Do they tend to infinity?  Do they stay bounded?  While a fascinating mathematical discussion, this “escape-time” algorithm is a less practical method for generating fractals than the recursive techniques we’ll examine in this chapter.  However, an example for generating the Mandelbrot set is included in the code examples."/>
<figcaption/>
</figure>
<p>Let’s illustrate this definition with two simple examples.  First, let’s think about a tree branching structure (for which we’ll write the code later):</p>

<figure id="chapter08_figure3">
<img src="imgs/chapter08/ch08_03.png" alt="Figure 8.3"/>
<figcaption/>
</figure>
<p>Notice how the tree in Figure 8.3 has a single root with two branches connected at its end.  Each one of those branches has two branches at its end and those branches have two branches and so on and so forth.  What if we were to pluck one branch from the tree and examine it on its own?</p>

<figure id="chapter08_figure4">
<img src="imgs/chapter08/ch08_04.png" alt="Figure 8.4"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""self-replicating behavior of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""self-similarity of fractals"">&nbsp;</a></p>

<p>Looking closely at a given section of the tree, we find that the shape of this branch resembles the tree itself.   This is known as <strong><em>self-similarity</em></strong>; as Mandelbrot stated, each part is a “reduced-size copy of the whole.”</p>

<p>The above tree is perfectly symmetrical and the parts are, in fact, exact replicas of the whole.  However, fractals do not have to be perfectly self-similar.  Let’s take a look at a graph of the stock market (adapted from actual Apple stock data).</p>

<figure id="chapter08_figure5">
<img src="imgs/chapter08/ch08_05.png" alt="Figure 8.5: Graph A"/>
<figcaption/>
</figure>
<p>And one more.</p>

<figure id="chapter08_figure6">
<img src="imgs/chapter08/ch08_06.png" alt="Figure 8.6: Graph B"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""stochastic"">&nbsp;</a>
<a data-type="indexterm" data-primary=""stochastic fractals"">&nbsp;</a></p>

<p>In these graphs, the x-axis is time and the y-axis is the stock’s value.   It’s not an accident that I omitted the labels, however.   Graphs of stock market data are examples of fractals because they look the same at any scale.  Are these graphs of the stock over one year?  One day?  One hour?  There’s no way for you to know without a label.  (Incidentally, graph A shows six months’ worth of data and graph B zooms into a tiny part of graph A, showing six hours.)</p>

<figure id="chapter08_figure7">
<img src="imgs/chapter08/ch08_07.png" alt="Figure 8.7"/>
<figcaption/>
</figure>
<p>This is an example of a <strong><em>stochastic</em></strong> fractal, meaning that it is built out of probabilities and randomness.  Unlike the deterministic tree-branching structure, it is statistically self-similar.  As we go through the examples in this chapter, we will look at both deterministic and stochastic techniques for generating fractal patterns.</p>

<p><a data-type="indexterm" data-primary=""Euclidean geometry"" data-secondary=""fractals and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fractals"" data-secondary=""fine structure of"">&nbsp;</a></p>

<p>While self-similarity is a key trait of fractals, it’s important to realize that self-similarity alone does not make a fractal.  After all, a line is self-similar.  A line looks the same at any scale, and can be thought of as comprising lots of little lines.  But it’s not a fractal.  Fractals are  characterized by having a fine structure at small scales (keep zooming into the stock market graph and you’ll continue to find fluctuations) and cannot be described with Euclidean geometry.  If you can say “It’s a line!” then it’s not a fractal.</p>

<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""recursion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""recursion"">&nbsp;</a></p>

<p>Another fundamental component of fractal geometry is recursion.  Fractals all have a recursive definition.  We&#8217;ll start with recursion before developing techniques and code examples for building fractal patterns in Processing.</p>
</section>







<section data-type="sect1" id="chapter08_section2">
<h1>8.2 Recursion</h1>
<p><a data-type="indexterm" data-primary=""Cantor set"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Cantor" data-secondary="George"">&nbsp;</a></p>

<p>Let’s begin our discussion of recursion by examining the first appearance of fractals in modern mathematics.  In 1883, German mathematician George Cantor developed simple rules to generate an infinite set:</p>

<figure id="chapter08_figure8">
<img src="imgs/chapter08/ch08_08.png" alt="Figure 8.8: The Cantor set"/>
<figcaption/>
</figure>
<p>There is a feedback loop at work here.  Take a single line and break it into two.  Then return to those two lines and apply the same rule, breaking each line into two, and now we’re left with four.  Then return to those four lines and apply the rule.  Now you’ve got eight.   This process is known as <strong><em>recursion</em></strong>: the repeated application of a rule to successive results.   Cantor was interested in what happens when you apply these rules an infinite number of times.   We, however, are working in a finite pixel space and can mostly ignore the questions and paradoxes that arise from infinite recursion.  We will instead construct our code in such a way that we do not apply the rules forever (which would cause our program to freeze).</p>

<p><a data-type="indexterm" data-primary=""recursion"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Before we implement the Cantor set, let’s take a look at what it means to have recursion in code.
Here’s something we’re used to doing all the time—calling a function inside another function.</p>

<pre data-type="programlisting" data-code-language="java">void someFunction() {
  // Calling the function background()
  // in the definition of someFunction()
  background(0);
}</pre>

<p>What would happen if we called the function we are defining within the function itself?   Can <strong function>someFunction()</strong> call <strong function>someFunction()</strong>?</p>

<pre data-type="programlisting" data-code-language="java">void someFunction() {
  someFunction();
}</pre>

<p><a data-type="indexterm" data-primary=""factorial"">&nbsp;</a>
<a data-type="indexterm" data-primary=""recursion"" data-secondary=""factorial"">&nbsp;</a></p>

<p>In fact, this is not only allowed, but it’s quite common (and essential to how we will implement the Cantor set).   Functions that call themselves are <em>recursive</em> and good for solving certain problems.  For example, certain mathematical calculations are implemented recursively; the most common example is <em>factorial</em>.</p>

<p>The factorial of any number n, usually written as n!, is defined as:</p>

<p><strong formula>n! = n * n – 1 * . . . . * 3 * 2 * 1</strong><br/>
<strong formula>0! = 1</strong></p>

<p>Here we&#8217;ll write a function in Processing that uses a <strong function>for</strong> loop to calculate factorial:</p>

<pre data-type="programlisting" data-code-language="java">int factorial(int n) {
  int f = 1;
  //[full] Using a regular loop to compute factorial
  for (int i = 0; i &lt; n; i++) {
    f = f * (i+1);
  }
  //[end]
  return f;
}</pre>

<p>Upon close examination, you&#8217;ll notice something interesting about how factorial works. Let’s look at 4! and 3!</p>

<p><strong formula>4! = 4 * 3 * 2 * 1</strong><br/>
<strong formula>3! = 3 * 2 * 1</strong></p>

<p><strong><em>therefore. . .</em></strong></p>

<p><strong formula>4! = 4 * 3!</strong></p>

<p>In more general terms, for any positive integer n:</p>

<p><strong formula>n! = n * (n-1)!</strong><br/>
<strong formula>1! = 1</strong></p>

<p>Written out:</p>

<p>The <em>factorial</em> of <strong var>n</strong> is defined as <strong var>n</strong> times the <em>factorial</em> of <strong var>n-1</strong>.</p>

<p>The definition of <strong><em>factorial</em></strong> includes <strong><em>factorial</em></strong>?!  It’s kind of like defining “tired" as “the feeling you get when you are tired.”   This concept of self-reference in functions is an example of recursion.   And we can use it to write a factorial function that calls itself.</p>

<pre data-type="programlisting" data-code-language="java">int factorial(int n) {
  if (n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}</pre>

<p>It may look crazy, but it works.   Here are the steps that happen when <strong function>factorial(4)</strong> is called.</p>

<figure id="chapter08_figure9">
<img src="imgs/chapter08/ch08_09.png" alt="Figure 8.9"/>
<figcaption/>
</figure>
<p>We can apply the same principle to graphics with interesting results, as we will see in many examples throughout this chapter. Take a look at this recursive function.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_01_Recursion/_8_01_Recursion.pde">
<img src="imgs/chapter08/ch08_ex01.png" alt="ch08 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 8.1: Recursive Circles I</strong></p>

<pre data-type="programlisting" data-code-language="java">void drawCircle(int x, int y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius &gt; 2) {
    radius *= 0.75f;
    // The drawCircle() function is
    // calling itself recursively.
    drawCircle(x, y, radius);
  }
}</pre>

<p><strong function>drawCircle()</strong> draws an ellipse based on a set of parameters that it receives as arguments. It then calls itself with those same parameters, adjusting them slightly. The result is a series of circles, each of which is drawn inside the previous circle.</p>

<p><a data-type="indexterm" data-primary=""exit conditions for recursion"">&nbsp;</a>
<a data-type="indexterm" data-primary=""recursion"" data-secondary=""exit conditions"">&nbsp;</a></p>

<p>Notice that the above function only recursively calls itself if the radius is greater than 2.  This is a crucial point.  As with iteration, <em>all recursive functions must have an exit condition!</em>    You likely are already aware that all <strong function>for</strong> and <strong function>while</strong> loops must include a boolean expression that eventually evaluates to false, thus exiting the loop. Without one, the program would crash, caught inside of an infinite loop. The same can be said about recursion.  If a recursive function calls itself forever and ever, you’ll be most likely be treated to a nice frozen screen.</p>

<p>This circles example is rather trivial; it could easily be achieved through simple iteration. However, for scenarios in which a function calls itself more than once, recursion becomes wonderfully elegant.</p>

<p>Let’s make <strong function>drawCircle()</strong> a bit more complex.    For every circle displayed, draw a circle half its size to the left and right of that circle.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_02_Recursion/_8_02_Recursion.pde">
<img src="imgs/chapter08/ch08_ex02.png" alt="ch08 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 8.2: Recursion twice</strong></p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640,360);
}

void draw() {
  background(255);
  drawCircle(width/2,height/2,200);
}

void drawCircle(float x, float y, float radius) {
  stroke(0);
  noFill();
  ellipse(x, y, radius, radius);
  if(radius &gt; 2) {
    //[full] drawCircle() calls itself twice, creating
    // a branching effect.  For every circle,
    // a smaller circle is drawn to the left and the right.
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);

    //[end]
  }
}</pre>

<p>With just a little more code, we could also add a circle above and below each circle.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_03_Recursion/_8_03_Recursion.pde">
<img src="imgs/chapter08/ch08_ex03.png" alt="ch08 ex03"/>
<figcaption/>
</figure>
<p><strong example>Example 8.3: Recursion four times</strong></p>

<pre data-type="programlisting" data-code-language="java">void drawCircle(float x, float y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius &gt; 8) {
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);
    drawCircle(x, y + radius/2, radius/2);
    drawCircle(x, y - radius/2, radius/2);
  }
}</pre>

<p>Try reproducing this sketch with iteration instead of recursion—I dare you!</p>
</section>







<section data-type="sect1" id="chapter08_section3">
<h1>8.3  The Cantor Set with a Recursive Function</h1>
<p><a data-type="indexterm" data-primary=""Cantor set"" data-secondary=""recursion and"">&nbsp;</a></p>

<p>Now we’re ready to visualize the Cantor set in Processing using a recursive function.  Where do we begin?  Well, we know that the Cantor set begins with a line.  So let’s start there and write a function that draws a line.</p>

<pre data-type="programlisting" data-code-language="java">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);
}</pre>

<p>The above <strong function>cantor()</strong> function draws a line that starts at pixel coordinate <em>(x,y)</em> with a length of <strong var>len</strong>.  (The line is drawn horizontally here, but this is an arbitrary decision.)  So if we called that function, saying:</p>

<pre data-type="programlisting" data-code-language="java">cantor(10, 20, width-20);</pre>

<p>we’d get the following:</p>

<figure id="chapter08_figure10">
<img src="imgs/chapter08/ch08_10.png" alt="Figure 8.10"/>
<figcaption/>
</figure>
<figure id="chapter08_figure11" class="half-width-right">
<img src="imgs/chapter08/ch08_11.png" alt="Figure 8.11"/>
<figcaption/>
</figure>
<p>Now, the Cantor rule tells us to erase the middle third of that line, which leaves us with two lines, one from the beginning of the line to the one-third mark, and one from the two-thirds mark to the end of the line.</p>

<p>We can now add two more lines of code to draw the second pair of lines, moving the y-location down a bunch of pixels so that we can see the result below the original line.</p>

<pre data-type="programlisting" data-code-language="java">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;
  // From start to 1/3rd
  line(x,y,x+len/3,y); //[bold]
  // From 2/3rd to end
  line(x+len*2/3,y,x+len,y); //[bold]
}</pre>

<figure id="chapter08_figure12">
<img src="imgs/chapter08/ch08_12.png" alt="Figure 8.12"/>
<figcaption/>
</figure>
<p>While this is a fine start, such a manual approach of calling <strong function>line()</strong> for each line is not what we want.   It will get unwieldy very quickly, as we’d need four, then eight, then sixteen calls to <strong function>line()</strong>.  Yes, a <strong function>for</strong> loop is our usual way around such a problem, but give that a try and you’ll see that working out the math for each iteration quickly proves inordinately complicated.   Here is where recursion comes and rescues us.</p>

<p>Take a look at where we draw that first line from the start to the one-third mark.</p>

<pre data-type="programlisting" data-code-language="java">   line(x,y,x+len/3,y);</pre>

<p>Instead of calling the <strong function>line()</strong> function directly, we can simply call the <strong function>cantor()</strong> function itself.  After all, what does the <strong function>cantor()</strong> function do?  It draws a line at an <em>(x,y)</em> location with a given length!  And so:</p>

<pre data-type="programlisting" data-code-language="java">   line(x,y,x+len/3,y);         becomes -------&gt;  cantor(x,y,len/3);</pre>

<p>And for the second line:</p>

<pre data-type="programlisting" data-code-language="java">   line(x+len*2/3,y,x+len,y);   becomes -------&gt;  cantor(x+len*2/3,y,len/3);</pre>

<p>Leaving us with:</p>

<pre data-type="programlisting" data-code-language="java">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;

  cantor(x,y,len/3);
  cantor(x+len*2/3,y,len/3);
}</pre>

<p>And since the <strong function>cantor()</strong> function is called recursively, the same rule will be applied to the next lines and to the next and to the next as <strong function>cantor()</strong> calls itself again and again!  Now, don’t go and run this code yet.  We’re missing that crucial element: an exit condition.   We’ll want to make sure we stop at some point—for example, if the length of the line ever is less than 1 pixel.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_04_CantorSet/_8_04_CantorSet.pde">
<img src="imgs/chapter08/ch08_ex04.png" alt="ch08 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 8.4: Cantor set</strong></p>

<pre data-type="programlisting" data-code-language="java">void cantor(float x, float y, float len) {
  // Stop at 1 pixel!
  if (len &gt;= 1) {
    line(x,y,x+len,y);
    y += 20;
    cantor(x,y,len/3);
    cantor(x+len*2/3,y,len/3);
  }
}</pre>

<div data-type="example">
<h5>Exercise 8.1</h5>
<p>Using <strong function>drawCircle()</strong> and the Cantor set as models, generate your own pattern with recursion.  Here is a screenshot of one that uses lines.</p>

<figure class="screenshot">
<img src="imgs/chapter08/ch08_exc01.png" alt="ch08 exc01"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter08_section4">
<h1>8.4  The Koch Curve and the ArrayList Technique</h1>
<p><a data-type="indexterm" data-primary=""ArrayList class (Java)"" data-secondary=""fractals and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fractals"" data-secondary=""Koch curve"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Koch curve"">&nbsp;</a>
<a data-type="indexterm" data-primary=""recursion"" data-secondary=""ArrayList objects and"">&nbsp;</a></p>

<p>Writing a function that recursively calls itself is one technique for generating a fractal pattern on screen.  However, what if you wanted the lines in the above Cantor set to exist as individual objects that could be moved independently?   The recursive function is simple and elegant, but it does not allow you to do much besides simply generating the pattern itself.  However, there is another way we can apply recursion in combination with an <strong klass>ArrayList</strong> that will allow us to not only generate a fractal pattern, but keep track of all its individual parts as objects.</p>

<p>To demonstrate this technique, let’s look at another famous fractal pattern, discovered in 1904 by Swedish mathematician Helge von Koch.   Here are the rules.  (Note that it starts the same way as the Cantor set, with a single line.)</p>

<figure id="chapter08_figure13">
<img src="imgs/chapter08/ch08_13.png" alt="Figure 8.13"/>
<figcaption/>
</figure>
<p>The result looks like:</p>

<figure id="chapter08_figure14">
<img src="imgs/chapter08/ch08_14.png" alt="Figure 8.14"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Monster curve"">&nbsp;</a></p>

<div data-type="note">
<h1>The “Monster” Curve</h1><p>The Koch curve and other fractal patterns are often called “mathematical monsters.”   This is due to an odd paradox that emerges when you apply the recursive definition an infinite number of times.  If the length of the original starting line is one, the first iteration of the Koch curve will yield a line of length four-thirds (each segment is one-third the length of the starting line).  Do it again and you get a length of sixteen-ninths.  As you iterate towards infinity, the length of the Koch curve approaches infinity.  Yet it fits in the tiny finite space provided right here on this paper (or screen)!</p>

<p>Since we are working in the Processing land of finite pixels, this theoretical paradox won’t be a factor for us.  We’ll have to limit the number of times we recursively apply the Koch rules so that our program won’t run out of memory or crash.</p>
</div>
<p>We could proceed in the same manner as we did with the Cantor set, and write a recursive function that iteratively applies the Koch rules over and over.   Nevertheless, we are going to tackle this problem in a different manner by treating each segment of the Koch curve as an individual object.  This will open up some design possibilities.  For example, if each segment is an object, we could allow each segment to move independently from its original location and participate in a physics simulation.  In addition, we could use a random color, line thickness, etc. to display each segment differently.</p>

<p>In order to accomplish our goal of treating each segment as an individual object, we must first decide what this object should be in the first place.  What data should it store?  What functions should it have?</p>

<p>The Koch curve is a series of connected lines, and so we will think of each segment as a “KochLine.”  Each <strong klass>KochLine</strong> object has a start point (“a”) and an end point (“b”).  These points are <strong klass>PVector</strong> objects, and the line is drawn with Processing’s <strong function>line()</strong> function.</p>

<pre data-type="programlisting" data-code-language="java">class KochLine {

  //[full] A line between two points: start and end
  PVector start;
  PVector end;
  //[end]

  KochLine(PVector a, PVector b) {
    start = a.get();
    end = b.get();
  }

  void display() {
    stroke(0);
    // Draw the line from PVector start to end.
    line(start.x, start.y, end.x, end.y);
  }
}</pre>

<p>Now that we have our <strong klass>KochLine</strong> class, we can get started on the main program.  We’ll need a data structure to keep track of what will eventually become many <strong klass>KochLine</strong> objects, and an <strong klass>ArrayList</strong> (see Chapter 4 for a review of <strong klass>ArrayList</strong><code>s</code>) will do just fine.</p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;KochLine&gt; lines;</pre>

<p>In <strong function>setup()</strong>, we’ll want to create the <strong klass>ArrayList</strong> and add the first line segment to it, a line that stretches from 0 to the width of the sketch.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(600, 300);
  // Create the ArrayList.
  lines = new ArrayList&lt;KochLine&gt;();

  // Left side of window
  PVector start = new PVector(0, 200);
  // Right side of window
  PVector end   = new PVector(width, 200);

  // The first KochLine object
  lines.add(new KochLine(start, end));
}</pre>

<p>Then in <strong function>draw()</strong>, all <strong klass>KochLine</strong> objects (just one right now) can be displayed in a loop.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);
  for (KochLine l : lines) {
    l.display();
  }
}</pre>

<p>This is our foundation.  Let’s review what we have so far:</p>

<ul>
<li>
<p><strong><em>KochLine class:</em></strong> A class to keep track of a line from point A to B.</p></li>
<li>
<p><strong><em>ArrayList:</em></strong> A list of all <strong klass>KochLine</strong> objects.</p></li>
</ul>

<p>With the above elements, how and where do we apply Koch rules and principles of recursion?</p>

<p><a data-type="indexterm" data-primary=""Koch curve"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Remember the Game of Life cellular automata?  In that simulation, we always kept track of two generations: current and next.  When we were finished computing the next generation, next became current and we moved on to computing the new next generation.
 We are going to apply a similar technique here.  We have an <strong klass>ArrayList</strong> that keeps track of the current set of <strong klass>KochLine</strong> objects (at the start of the program, there is only one).  We will need a second <strong klass>ArrayList</strong> (let’s call it “next”) where we will place all the new <strong klass>KochLine</strong> objects that are generated from applying the Koch rules.   For every <strong klass>KochLine</strong> object in the current <strong klass>ArrayList</strong>, four new <strong klass>KochLine</strong> objects are added to the next <strong klass>ArrayList</strong>.  When we’re done, the next <strong klass>ArrayList</strong> becomes the current one.</p>

<figure id="chapter08_figure15">
<img src="imgs/chapter08/ch08_15.png" alt="Figure 8.15"/>
<figcaption/>
</figure>
<p>Here’s how the code will look:</p>

<pre data-type="programlisting" data-code-language="java">void generate() {
  // Create the next ArrayList...
  ArrayList next = new ArrayList&lt;KochLine&gt;();

  // ...for every current line.
  for (KochLine l : lines) {

    //[full] Add four new lines. (We need to figure out how
    // to compute the locations of these lines!)
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    //[end]
  }
  // The new ArrayList is now the
  // one we care about!
  lines = next;
}</pre>

<p>By calling <strong function>generate()</strong> over and over again (for example, each time the mouse is pressed), we recursively apply the Koch curve rules to the existing set of <strong klass>KochLine</strong> objects.
 Of course, the above omits the real “work” here, which is figuring out those rules.  How do we break one line segment into four as described by the rules?   While this can be accomplished with some simple arithmetic and trigonometry, since our <strong klass>KochLine</strong> object uses <strong klass>PVector</strong>, this is a nice opportunity for us to practice our vector math.  Let’s establish how many points we need to compute for each <strong klass>KochLine</strong> object.</p>

<figure id="chapter08_figure16">
<img src="imgs/chapter08/ch08_16.png" alt="Figure 8.16"/>
<figcaption/>
</figure>
<p>As you can see from the above figure, we need five points  (a, b, c, d, and e) to generate the new <strong klass>KochLine</strong> objects and make the new line segments (ab, cb, cd, and de).</p>

<pre data-type="programlisting" data-code-language="java">    next.add(new KochLine(a,b));
    next.add(new KochLine(b,c));
    next.add(new KochLine(c,d));
    next.add(new KochLine(d,e));</pre>

<p>Where do we get these points?  Since we have a <strong klass>KochLine</strong> object, why not ask the <strong klass>KochLine</strong> object to compute all these points for us?</p>

<pre data-type="programlisting" data-code-language="java">void generate() {
  ArrayList next = new ArrayList&lt;KochLine&gt;();
  for (KochLine l : lines) {

    //[full] The KochLine object has five functions,
    // each of which return a PVector according
    // to the Koch rules.
    PVector a = l.kochA();
    PVector b = l.kochB();
    PVector c = l.kochC();
    PVector d = l.kochD();
    PVector e = l.kochE();
    //[end]

    next.add(new KochLine(a, b));
    next.add(new KochLine(b, c));
    next.add(new KochLine(c, d));
    next.add(new KochLine(d, e));
  }

  lines = next;
}</pre>

<p>Now we just need to write five new functions in the <strong klass>KochLine</strong> class, each one returning a <strong klass>PVector</strong> according to <a href="#chapter08_figure16">Figure 8.16</a> above.  Let’s knock off <strong function>kochA()</strong> and <strong function>kochE()</strong> first, which are simply the start and end points of the original line.</p>

<pre data-type="programlisting" data-code-language="java">  PVector kochA() {
    // Note the use of get(), which returns a copy of the PVector. As was noted in
    // Chapter 6, section 14, we want to avoid making copies whenever
    // possible, but here we will need a new PVector in case we want the segments to move
    // independently of each other.
    return start.get();
  }

  PVector kochE() {
    return end.get();
  }
</pre>

<p>Now let’s move on to points B and D.  B is one-third of the way along the line segment and D is two-thirds.  Here we can make a <strong klass>PVector</strong> that points from start to end and shrink it to one-third the length for B and two-thirds the length for D to find these points.</p>

<figure id="chapter08_figure17">
<img src="imgs/chapter08/ch08_17.png" alt="Figure 8.17"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">  PVector kochB() {
    // PVector from start to end
    PVector v = PVector.sub(end, start);
    // One-third the length
    v.div(3);
    // Add that PVector to the beginning of the line
    // to find the new point.
    v.add(start);
    return v;
  }

  PVector kochD() {
    PVector v = PVector.sub(end, start);
    // Same thing here, only we need to move two-thirds
    // along the line instead of one-third.
    v.mult(2/3.0);
    v.add(start);
    return v;
  }</pre>

<p>The last point, C, is the most difficult one to find.  However, if you recall that the angles of an equilateral triangle are all sixty degrees, this makes it a little bit easier.  If we know how to find point B with a <strong klass>PVector</strong> one-third the length of the line, what if we were to rotate that same <strong klass>PVector</strong> sixty degrees and move along that vector from point B?  We’d be at point C!</p>

<figure id="chapter08_figure18">
<img src="imgs/chapter08/ch08_18.png" alt="Figure 8.18"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">  PVector kochC() {
    // Start at the beginning.
    PVector a = start.get();

    PVector v = PVector.sub(end, start);
    // Move 1/3rd of the way to point B.
    v.div(3);
    a.add(v);

    // Rotate “above” the line 60 degrees.
    v.rotate(-radians(60));
    // Move along that vector to point C.
    a.add(v);

    return a;
  }</pre>

<p>Putting it all together, if we call <strong function>generate()</strong> five times in <strong function>setup()</strong>, we’ll see the following result.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_05_Koch/_8_05_Koch.pde processingjs/chapter08/_8_05_Koch/KochFractal.pde processingjs/chapter08/_8_05_Koch/KochLine.pde">
<img src="imgs/chapter08/ch08_ex05.png" alt="ch08 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 8.5: Koch curve</strong></p>

<pre data-type="programlisting" data-code-language="java">ArrayList&lt;KochLine&gt; lines;

void setup() {
  size(600, 300);
  background(255);
  lines = new ArrayList&lt;KochLine&gt;();
  PVector start = new PVector(0, 200);
  PVector end   = new PVector(width, 200);
  lines.add(new KochLine(start, end));

  // Arbitrarily apply the Koch rules five times.
  for (int i = 0; i &lt; 5; i++) {
    generate();
  }
}</pre>

<div data-type="example">
<h5>Exercise 8.2</h5>
<figure class="half-width-right">
<img src="imgs/chapter08/ch08_exc02.png" alt="ch08 exc02"/>
<figcaption/>
</figure>
<p>Draw the Koch snowflake (or some other variation of the Koch curve).</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>

<div data-type="example">
<h5>Exercise 8.3</h5>
<p>Try animating the Koch curve.  For example, can you draw it from left to right?  Can you vary the visual design of the line segments?  Can you move the line segments using techniques from earlier chapters?  What if each line segment were made into a spring (toxiclibs) or joint (Box2D)?</p>
</div>

<div data-type="example">
<h5>Exercise 8.4</h5>
<p>Rewrite the Cantor set example using objects and an <strong klass>ArrayList</strong>.</p>
</div>

<div data-type="example">
<h5>Exercise 8.5</h5>
<p>Draw the Sierpiński triangle (as seen in Wolfram elementary CA) using recursion.</p>

<figure>
<img src="imgs/chapter08/ch08_exc05.png" alt="ch08 exc05"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter08_section5">
<h1>8.5  Trees</h1>
<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""trees and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural fractals"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""trees and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""stochastic fractals"" data-secondary=""trees as"">&nbsp;</a>
<a data-type="indexterm" data-primary=""trees"">&nbsp;</a></p>

<p>The fractals we have examined in this chapter so far are deterministic, meaning they have no randomness and will always produce the identical outcome each time they are run.   They are excellent demonstrations of classic fractals and the programming techniques behind drawing them, but are too precise to feel <em>natural</em>.  In this next part of the chapter, I want to examine some techniques behind generating a stochastic (or non-deterministic) fractal.   The example we’ll use is a branching tree.  Let’s first walk through the steps to create a deterministic version.  Here are our production rules:</p>

<figure id="chapter08_figure19">
<img src="imgs/chapter08/ch08_19.png" alt="Figure 8.19"/>
<figcaption/>
</figure>
<p>Again, we have a nice fractal with a recursive definition: A branch is a line with two branches connected to it.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_06_Tree_static/_8_06_Tree_static.pde">
<img src="imgs/chapter08/ch08_ex06.png" alt="ch08 ex06"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""Transformations tutorial (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""fractals"" data-secondary=""transformation matrix (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""popMatrix() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""pushMatrix() function (Processing)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""transformation matrix (Processing)"">&nbsp;</a></p>

<p>The part that is a bit more difficult than our previous fractals lies in the use of the word <em>rotate</em> in the fractal’s rules.   Each new branch must rotate relative to the previous branch, which is rotated relative to all its previous branches.  Luckily for us, Processing has a mechanism to keep track of rotations for us—the <strong><em>transformation matrix</em></strong>.  If you aren’t familiar with the functions <strong function>pushMatrix()</strong> and <strong function>popMatrix()</strong>, I suggest you read the online Processing tutorial <a href="http://processing.org/learning/transform2d/">2D Transformations</a>, which will cover the concepts you’ll need for this particular example.</p>

<p>Let’s begin by drawing a single branch, the trunk of the tree.    Since we are going to involve the <strong function>rotate()</strong> function, we’ll need to make sure we are continuously translating along the branches while we draw the tree.  And since the root starts at the bottom of the window (see above), the first step requires translating to that spot:</p>

<pre data-type="programlisting" data-code-language="java">translate(width/2,height);</pre>

<figure id="chapter08_figure20" class="half-width-right-border">
<img src="imgs/chapter08/ch08_20.png" alt="Figure 8.20"/>
<figcaption/>
</figure>
<p>&#8230;followed by drawing a line upwards (Figure 8.20):</p>

<pre data-type="programlisting" data-code-language="java">line(0,0,0,-100);</pre>

<p>Once we’ve finished the root, we just need to translate to the end and rotate in order to draw the next branch.  (Eventually, we’re going to need to package up what we’re doing right now into a recursive function, but let’s sort out the steps first.)</p>

<figure id="chapter08_figure21">
<img src="imgs/chapter08/ch08_21.png" alt="Figure 8.21"/>
<figcaption/>
</figure>
<p>Remember, when we rotate in Processing, we are always rotating around the point of origin, so here the point of origin must always be translated to the end of our current branch.</p>

<pre data-type="programlisting" data-code-language="java">translate(0,-100);
rotate(PI/6);
line(0,0,0,-100);</pre>

<p>Now that we have a branch going to the right, we need one going to the left.  We can use <strong function>pushMatrix()</strong> to save the transformation state before we rotate, letting us call <strong function>popMatrix()</strong> to restore that state and draw the branch to the left.  Let’s look at all the code together.</p>

<figure id="chapter08_figure22" class="two-col">
<img src="imgs/chapter08/ch08_22.png" alt="Figure 8.22"/>
<figcaption/>
</figure>
<figure id="chapter08_figure23" class="two-col">
<img src="imgs/chapter08/ch08_23.png" alt="Figure 8.23"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">translate(width/2,height);
// The root
line(0,0,0,-100);
translate(0,-100);

pushMatrix();
rotate(PI/6);
// Branch to the right
line(0,0,0,-100);
popMatrix();

rotate(-PI/6);
// Branch to the left
line(0,0,0,-100);</pre>

<p>If you think of each call to the function <strong function>line()</strong> as a “branch,” you can see from the code above that we have implemented our definition of branching as a line that has two lines connected to its end.  We could keep adding more and more calls to <strong function>line()</strong> for more and more branches, but just as with the Cantor set and Koch curve, our code would become incredibly complicated and unwieldy.   Instead, we can use the above logic as our foundation for writing a recursive function, replacing the direct calls to <strong function>line()</strong> with our own function called <strong function>branch()</strong>.  Let’s take a look.</p>

<p><strong example>Example 8.6: Recursive tree</strong></p>

<pre data-type="programlisting" data-code-language="java">void branch() {
  // Draw the branch itself.
  line(0, 0, 0, -100);
  // Translate to the end.
  translate(0, -100);

  pushMatrix();
  // Rotate to the right and branch again.
  rotate(PI/6);
  branch();
  popMatrix();

  pushMatrix();
  // Rotate to the left and branch again.
  rotate(-PI/6);
  branch();
  popMatrix();
}</pre>

<p>Notice how in the above code we use <strong function>pushMatrix()</strong> and <strong function>popMatrix()</strong> around each subsequent call to <strong function>branch()</strong>.   This is one of those elegant code solutions that feels almost like magic.  Each call to <strong function>branch()</strong> takes a moment to remember the location of that particular branch.    If you turn yourself into Processing for a moment and try to follow the recursive function with pencil and paper, you’ll notice that it draws all of the branches to the right first.   When it gets to the end, <strong function>popMatrix()</strong> will pop us back along all of the branches we’ve drawn and start sending branches out to the left.</p>

<div data-type="example">
<h5>Exercise 8.6</h5>
<figure>
<img src="imgs/chapter08/ch08_exc06.png" alt="ch08 exc06"/>
<figcaption/>
</figure>
<p>Emulate the Processing code in <a href="#chapter08_example6">Example 8.6</a> and number the branches in the above diagram in the order that Processing would actually draw each one.</p>
</div>

<p>You may have noticed that the recursive function we just wrote would not actually draw the above tree.  After all, it has no exit condition and would get stuck in infinite recursive calls to itself.   You’ll also probably notice that the branches of the tree get shorter at each level.   Let’s look at how we can shrink the length of the lines as the tree is drawn, and stop branching once the lines have become too short.</p>

<pre data-type="programlisting" data-code-language="java">// Each branch now receives
// its length as an argument.
void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  // Each branch’s length
  // shrinks by two-thirds.
  len *= 0.66;

  if (len &gt; 2) {
    pushMatrix();
    rotate(theta);
    // Subsequent calls to branch()
    // include the length argument.
    branch(len);
    popMatrix();

    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</pre>

<p>We’ve also included a variable for theta that allows us, when writing the rest of the code in <strong function>setup()</strong> and <strong function>draw()</strong>, to vary the branching angle according to, say, the <strong var>mouseX</strong> location.</p>

<figure class="three-col">
<img src="imgs/chapter08/ch08_ex06a.png" alt="ch08 ex06a"/>
<figcaption/>
</figure>
<figure class="three-col">
<img src="imgs/chapter08/ch08_ex06b.png" alt="ch08 ex06b"/>
<figcaption/>
</figure>
<figure class="three-col">
<img src="imgs/chapter08/ch08_ex06c.png" alt="ch08 ex06c"/>
<figcaption/>
</figure>
<p><strong example>Example 8.7: Recursive tree</strong></p>

<pre data-type="programlisting" data-code-language="java">float theta;

void setup() {
  size(300, 200);
}

void draw() {
  background(255);
  // Pick an angle according to
  // the mouse location.
  theta = map(mouseX,0,width,0,PI/2);

  // The first branch starts at the
  // bottom of the window.
  translate(width/2, height);
  stroke(0);
  branch(60);
}</pre>

<div data-type="example">
<h5>Exercise 8.7</h5>
<p>Vary the <strong function>strokeWeight()</strong> for each branch.  Make the root thick and each subsequent branch thinner.</p>

<figure class="screenshot">
<img src="imgs/chapter08/ch08_exc07.png" alt="ch08 exc07"/>
<figcaption/>
</figure></div>

<div data-type="example">
<h5>Exercise 8.8</h5>
<p>The tree structure can also be generated using the <strong klass>ArrayList</strong> technique demonstrated with the Koch curve.  Recreate the tree using a <strong var>Branch</strong> object and an <strong klass>ArrayList</strong> to keep track of the branches.  Hint: you’ll want to keep track of the branch directions and lengths using vector math instead of Processing transformations.</p>
</div>

<div data-type="example">
<h5>Exercise 8.9</h5>
<p>Once you have the tree built with an <strong klass>ArrayList</strong> of <strong var>Branch</strong> objects, animate the tree’s growth.  Can you draw leaves at the end of the branches?</p>
</div>

<p>The recursive tree fractal is a nice example of a scenario in which adding a little bit of randomness can make the tree look more natural.  Take a look outside and you’ll notice that branch lengths and angles vary from branch to branch, not to mention the fact that branches don’t all have exactly the same number of smaller branches.   First, let’s see what happens when we simply vary the angle and length.  This is a pretty easy one, given that we can just ask Processing for a random number each time we draw the tree.</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_07_TreeStochastic_angleonly/_8_07_TreeStochastic_angleonly.pde">
<img src="imgs/chapter08/ch08_ex07a.png" alt="ch08 ex07a"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">void branch(float len) {
  // Start by picking a random
  // angle for each branch.
  float theta = random(0,PI/3);

  line(0, 0, 0, -len);
  translate(0, -len);
  len *= 0.66;
  if (len &gt; 2) {
    pushMatrix();
    rotate(theta);
    branch(len);
    popMatrix();
    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</pre>

<p>In the above function, we always call <strong function>branch()</strong> twice.  But why not pick a random number of branches and call <strong function>branch()</strong> that number of times?</p>

<figure class="screenshot" data-pde="processingjs/chapter08/_8_07_TreeStochastic/_8_07_TreeStochastic.pde">
<img src="imgs/chapter08/ch08_ex07b.png" alt="ch08 ex07b"/>
<figcaption/>
</figure>
<p><strong example>Example 8.8: Stochastic tree</strong></p>

<pre data-type="programlisting" data-code-language="java">void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  if (len &gt; 2) {

    // Call branch() a random
    // number of times.
    int n = int(random(1,4));
    for (int i = 0; i &lt; n; i++) {

      // Each branch gets its own random angle.
      float theta = random(-PI/2, PI/2);
      pushMatrix();
      rotate(theta);
      branch(h);
      popMatrix();
    }
  }</pre>

<div data-type="example">
<h5>Exercise 8.10</h5>
<p>Set the angles of the branches of the tree according to Perlin noise values.  Adjust the noise values over time to animate the tree.  See if you can get it to appear as if it is blowing in the wind.</p>
</div>

<div data-type="example">
<h5>Exercise 8.11</h5>
<p>Use toxiclibs to simulate tree physics.  Each branch of the tree should be two particles connected with a spring.  How can you get the tree to stand up and not fall down?</p>
</div>
</section>







<section data-type="sect1" id="chapter08_section6">
<h1>8.6  L-systems</h1>
<p><a data-type="indexterm" data-primary=""fractals"" data-secondary=""L-systems and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""L-systems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Lindenmayer systems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Lindenmayer" data-secondary="Aristid"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""L-systems and"">&nbsp;</a></p>

<p>In 1968, Hungarian botanist Aristid Lindenmayer developed a grammar-based system to model the growth patterns of plants.    L-systems (short for Lindenmayer systems) can be used to generate all of the recursive fractal patterns we’ve seen so far in this chapter.   We don’t need L-systems to do the kind of work we’re doing here; however, they are incredibly useful because they provide a mechanism for keeping track of fractal structures that require complex and multi-faceted production rules.</p>

<p>In order to create an example that implements L-systems in Processing, we are going to have to be comfortable with working with (a) recursion, (b) transformation matrices, and (c) strings.    So far we’ve worked with recursion and transformations, but strings are new here.  We will assume the basics, but if that is not comfortable for you, I would suggest taking a look at the Processing tutorial <a href="http://www.processing.org/learning/text/">Strings and Drawing Text</a>.</p>

<p>An L-system involves three main components:</p>

<p><a data-type="indexterm" data-primary=""alphabet (L-system component)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""L-systems"" data-secondary=""components of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""plant growth" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""plant growth" data-secondary="modeling"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Alphabet.</em></strong>  An L-system’s alphabet is comprised of the valid characters that can be included.  For example, we could say the alphabet is “ABC,” meaning that any valid “sentence” (a string of characters) in an L-system can only include these three characters.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""axiom (L-system component)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Axiom.</em></strong>  The axiom is a sentence (made up with characters from the alphabet) that describes  the initial state of the system.  For example, with the alphabet “ABC,” some example axioms are “AAA” or “B” or “ACBAB.”</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""rules (L-system component)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Rules.</em></strong>  The rules of an L-system are applied to the axiom and then applied recursively, generating new sentences over and over again.  An L-system rule includes two sentences, a “predecessor” and a “successor.”  For example, with the Rule “A —&gt; AB”, whenever an “A” is found in a string, it is replaced with “AB.”</p></li>
</ul>

<p>Let’s begin with a very simple L-system.  (This is, in fact, Lindenmayer’s original L-system for modeling the growth of algae.)</p>

<figure id="chapter08_figure24" class="half-width-right">
<img src="imgs/chapter08/ch08_24.png" alt="Figure 8.24: And so on and so forth..."/>
<figcaption/>
</figure>
<p><strong formula>Alphabet: A B</strong><br/>
<strong formula>Axiom:  A</strong><br/>
<strong formula>Rules:  (A &#8594; AB)  (B &#8594; A)</strong></p>

<p>As with our recursive fractal shapes, we can consider each successive application of the L-system rules to be a generation.  Generation 0 is, by definition, the axiom.</p>

<p>Let’s look at how we might create these generations with code.  We’ll start by using a <strong klass>String</strong> object to store the axiom.</p>

<pre data-type="programlisting" data-code-language="java">String current = "A";</pre>

<p>And once again, just as we did with the Game of Life and the Koch curve <strong klass>ArrayList</strong> examples, we will need an entirely separate string to keep track of the “next” generation.</p>

<pre data-type="programlisting" data-code-language="java">String next = "";</pre>

<p>Now it’s time to apply the rules to the current generation and place the results in the next.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; current.length(); i++) {
  char c = current.charAt(i);
  // Production rule A --&gt; AB
  if (c == 'A') {
    next += "AB";
  // Production rule B --&gt; A
  } else if (c == 'B') {
    next += "A";
  }
}</pre>

<p>And when we’re done, current can become next.</p>

<pre data-type="programlisting" data-code-language="java">current = next;</pre>

<p>To be sure this is working, let’s package it into a function and and call it every time the mouse is pressed.</p>

<figure class="screenshot">
<img src="imgs/chapter08/ch08_ex08.png" alt="ch08 ex08"/>
<figcaption/>
</figure>
<p><strong example>Example 8.9: Simple L-system sentence generation</strong></p>

<pre data-type="programlisting" data-code-language="java">// Start with an axiom.
String current = "A";
// Let’s keep track of how many generations.
int count = 0;

void setup() {
  println("Generation " + count + ": " + current);
}

void draw() {
}

void mousePressed() {
  String next = "";
  // Traverse the current String and make the new one.
  for (int i = 0; i &lt; current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      next += "AB";
    }  else if (c == 'B') {
      next += "A";
    }
  }
  current = next;
  count++;
  println("Generation " + count + ": " + current);
}</pre>

<p>Since the rules are applied recursively to each generation, the length of the string grows exponentially.   By generation #11, the sentence is 233 characters long; by generation #22, it is over 46,000 characters long.   The Java <strong klass>String</strong> class, while convenient to use, is a grossly inefficient data structure for concatenating large strings.   A <strong klass>String</strong> object is “immutable,” which means once the object is created it can never be changed.  Whenever you add on to the end of a <strong klass>String</strong> object, Java has to make a brand new <strong klass>String</strong> object (even if you are using the same variable name).</p>

<pre data-type="programlisting" data-code-language="java">String s = "blah";
s += "add some more stuff";</pre>

<p><a data-type="indexterm" data-primary=""StringBuffer class"">&nbsp;</a>
<a data-type="indexterm" data-primary=""strings"" data-secondary=""StringBuffer class vs."">&nbsp;</a></p>

<p>In most cases, this is fine, but why duplicate a 46,000-character string if you don’t have to?   For better efficiency in our L-system examples, we’ll use the <strong klass>StringBuffer</strong> class, which is optimized for this type of task and can easily be converted into a string after concatenation is complete.</p>

<pre data-type="programlisting" data-code-language="java">  // A StringBuffer for the “next” sentence
  StringBuffer next = new StringBuffer();
  for (int i = 0; i &lt; current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      // append() instead of +=
      next.append("AB");
    } else if (c == 'B') {
      next.append("A");
    }
  }
  // StringBuffer can easily be converted
  // back to a String.
  current = next.toString();</pre>

<p>You may find yourself wondering right about now: what exactly is the point of all this?  After all, isn’t this a chapter about <em>drawing</em> fractal patterns?   Yes, the recursive nature of the L-system sentence structure seems relevant to the discussion, but how exactly does this model plant growth in a visual way?</p>

<p>What we’ve left unsaid until now is that embedded into these L-system sentences are instructions for drawing.   Let’s see how this works with another example.</p>

<p><strong formula>Alphabet: A B</strong><br/>
<strong formula>Axiom:    A</strong><br/>
<strong formula>Rules:    (A &#8594; ABA)  (B &#8594; BBB)</strong></p>

<p>To read a sentence, we’ll translate it in the following way:</p>

<p><strong formula>A:  Draw a line forward.</strong><br/>
<strong formula>B:  Move forward without drawing.</strong></p>

<p>Let’s look at the sentence of each generation and its visual output.</p>

<p><strong formula>Generation 0: A</strong><br/>
<strong formula>Generation 1: ABA</strong><br/>
<strong formula>Generation 2: ABABBBABA</strong><br/>
<strong formula>Generation 3: ABABBBABABBBBBBBBBABABBBABA</strong></p>

<p><a data-type="indexterm" data-primary=""Cantor set"" data-secondary=""L-systems and"">&nbsp;</a></p>

<p>Look familiar?  This is the Cantor set generated with an L-system.</p>

<figure id="chapter08_figure25">
<img src="imgs/chapter08/ch08_25.png" alt="Figure 8.25"/>
<figcaption/>
</figure>
<p>The following alphabet is often used with L-systems: “FG+-[]”, meaning:</p>

<p><strong formula>F:  Draw a line and move forward</strong><br/>
<strong formula>G:  Move forward (without drawing a line)</strong><br/>
<strong formula>+:  Turn right</strong><br/>
<strong formula>-:  Turn left</strong><br/>
<strong formula>[:  Save current location</strong><br/>
<strong formula>]:  Restore previous location</strong></p>

<p><a data-type="indexterm" data-primary=""Turtle graphics"">&nbsp;</a></p>

<p>This type of drawing framework is often referred to as “Turtle graphics” (from the old days of LOGO programming).   Imagine a turtle sitting on your computer screen to which you could issue a small set of commands: turn left, turn right, draw a line, etc.  Processing isn’t set up to operate this way by default, but by using <strong function>translate()</strong>, <strong function>rotate()</strong>, and <strong function>line()</strong>, we can emulate a Turtle graphics engine fairly easily.</p>

<p><a data-type="indexterm" data-primary=""L-systems"" data-secondary=""translating into code"">&nbsp;</a></p>

<p>Here’s how we would translate the above L-system alphabet into Processing code.</p>

<p><strong formula>F:  line(0,0,0,len); translate(0,len);</strong><br/>
<strong formula>G:  translate(0,len);</strong><br/>
<strong formula>+:  rotate(angle);</strong><br/>
<strong formula>-:  rotate(-angle);</strong><br/>
<strong formula>[:  pushMatrix();</strong><br/>
<strong formula>]:  popMatrix();</strong></p>

<p>Assuming we have a sentence generated from the L-system, we can walk through the sentence character by character and call the appropriate function as outlined above.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; sentence.length(); i++) {

  // Looking at each character one at a time
  char c = sentence.charAt(i);

  //[full] Performing the correct task for each character.
  // This could also be written with a “case” statement,
  // which might be nicer to look at, but leaving it as an
  // if/else if structure helps readers not familiar with case statements.
  if (c == 'F') {
    line(0,0,len,0);
    translate(len,0);
  } else if (c == 'G') {
    translate(len,0);
  } else if (c == '+') {
    rotate(theta);
  } else if (c == '-') {
    rotate(-theta);
  } else if (c == '[') {
    pushMatrix();
  } else if (c == ']') {
    popMatrix();
  }
  //[end]
}</pre>

<p>The next example will draw a more elaborate structure with the following L-system.</p>

<p><strong formula>Alphabet:   FG+-[]</strong><br/>
<strong formula>Axiom:  F</strong><br/>
<strong formula>Rules:  F -&#8594; FF+[+F-F-F]-[-F+F+F]</strong></p>

<p>The example available for download on the book’s website takes all of the L-system code provided in this section and organizes it into three classes:</p>

<ul>
<li>
<p><strong mono>Rule</strong>:  A class that stores the predecessor and successor strings for an L-system rule.</p></li>
<li>
<p><strong mono>LSystem</strong>: A class to iterate a new L-system generation (as demonstrated with the <strong klass>StringBuffer</strong> technique).</p></li>
<li>
<p><strong mono>Turtle</strong>: A class to manage reading the L-system sentence and following its instructions to draw on the screen.</p></li>
</ul>

<p>We won’t write out these classes here since they simply duplicate the code we’ve already worked out in this chapter. However, let’s see how they are put together in the main tab.</p>

<figure class="screenshot">
<img src="imgs/chapter08/ch08_ex09.png" alt="ch08 ex09"/>
<figcaption/>
</figure>
<p><strong example>Example 8.10: LSystem</strong></p>

<pre data-type="programlisting" data-code-language="java">LSystem lsys;
Turtle turtle;

void setup() {
  size(600,600);

  // A ruleset is an array of Rule objects.
  Rule[] ruleset = new Rule[1];
  ruleset[0] = new Rule('F',"FF+[+F-F-F]-[-F+F+F]");

  // The L-system is created with an axiom and a ruleset.
  lsys = new LSystem("F",ruleset);

  //[offset-down] The Turtle graphics renderer is given a sentence,
  // a starting length, and an angle for rotations.
  turtle = new Turtle(lsys.getSentence(),width/4,radians(25));
}

void draw() {
  background(255);
  // Start at the bottom of the window and draw.
  translate(width/2,height);
  turtle.render();
}

void mousePressed() {
  // Generate a new sentence when the mouse is pressed.
  lsys.generate();
  turtle.setToDo(lsys.getSentence());

  // The length shrinks each generation.
  turtle.changeLen(0.5);
}</pre>

<div data-type="example">
<h5>Exercise 8.12</h5>
<p>Use an L-system as a set of instructions for creating objects stored in an <strong klass>ArrayList</strong>.  Use trigonometry and vector math to perform the rotations instead of matrix transformations (much like we did in the Koch curve example).</p>
</div>

<p><a data-type="indexterm" data-primary=""<em>Algorithmic Beauty of Plants" data-secondary="The</em> (Prusinkiewicz/Lindenmayer)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Lindenmayer" data-secondary="Aristid"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Prusinkiewicz" data-secondary="Przemysław"">&nbsp;</a></p>

<div data-type="example">
<h5>Exercise 8.13</h5>
<p>The seminal work in L-systems and plant structures, <em>The Algorithmic Beauty of Plants</em> by Przemysław Prusinkiewicz and Aristid Lindenmayer, was published in 1990.  It is available for free in its entirety <a href="http://algorithmicbotany.org/papers/#abop">online</a>.  Chapter 1 describes many sophisticated L-systems with additional drawing rules and available alphabet characters.  In addition, it describes several methods for generating stochastic L-systems.   Expand the L-system example to include one or more additional features described by Prusinkiewicz and Lindenmayer.</p>
</div>

<div data-type="example">
<h5>Exercise 8.14</h5>
<p>In this chapter, we emphasized using fractal algorithms for generating visual patterns. However, fractals can be found in other creative mediums.  For example, fractal patterns are evident in Johann Sebastian Bach’s Cello Suite no. 3.  The structure of David Foster Wallace’s novel <em>Infinite Jest</em> was inspired by fractals.  Consider using the examples in this chapter to generate audio or text.</p>
</div>

<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 8 Exercise:</p>

<p>Incorporate fractals into your ecosystem.  Some possibilities:</p>

<ul>
<li>
<p>Add plant-like creatures to the ecosystem environment.</p></li>
<li>
<p>Let’s say one of your plants is similar to a tree.  Can you add leaves or flowers to the end of the branches?   What if the leaves can fall off the tree (depending on a wind force)?  What if you add fruit that can be picked and eaten by the creatures?</p></li>
<li>
<p>Design a creature with a fractal pattern.</p></li>
<li>
<p>Use an L-system to generate instructions for how a creature should move or behave.</p></li>
</ul>
</div>
<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="chapter" id="_chapter_9_the_evolution_of_code">
<h1>Chapter 9.  The Evolution of Code</h1>
<blockquote data-type="epigraph"><p>“The fact that life evolved out of nearly nothing, some 10 billion years after the universe evolved out of literally nothing, is a fact so staggering that I would be mad to attempt words to do it justice.”</p>
<p data-type="attribution">&#8212; — Richard Dawkins</p>
</blockquote>

<p>Let’s take a moment to think back to a simpler time, when you wrote your first Processing sketches and life was free and easy.  What is one of programming’s fundamental concepts that you likely used in those first sketches and continue to use over and over again?  <em>Variables</em>.  Variables allow you to save data and reuse that data while a program runs.   This, of course, is nothing new to us.  In fact, we have moved far beyond a sketch with just one or two variables and on to more complex data structures—variables made from custom types (objects) that include both data and functionality.  We’ve made our own little worlds of movers and particles and vehicles and cells and trees.</p>

<p><a data-type="indexterm" data-primary=""evolution"" data-secondary=""modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""evolution"">&nbsp;</a></p>

<p>In each and every example in this book, the variables of these objects have to be initialized.  Perhaps you made a whole bunch of particles with random colors and sizes or a list of vehicles all starting at the same <strong var>x</strong>,<strong var>y</strong> location on screen.   But  instead of acting as “intelligent designers” and assigning the properties of our objects through randomness or thoughtful consideration, we can let a process found in nature<code>—</code><em>evolution</em><code>—</code>decide for us.</p>

<p>Can we think of the variables of an object as its DNA?  Can objects make other objects and pass down their DNA to a new generation?  Can our simulation evolve?</p>

<p> The answer to all these questions is yes.  After all, we wouldn’t be able to face ourselves in the mirror as nature-of-coders without tackling a simulation of one of the most powerful algorithmic processes found in nature itself.  This chapter is dedicated to examining the principles behind biological evolution and finding ways to apply those principles in code.</p>




<section data-type="sect1" id="chapter09_section1">
<h1>9.1  Genetic Algorithms: Inspired by Actual Events</h1>
<p><a data-type="indexterm" data-primary=""evolution"" data-secondary=""genetic algorithms"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""genetic algorithms"">&nbsp;</a></p>

<p>It’s important for us to clarify the goals of this chapter.   We will not go into depth about the science of genetics and evolution as it happens in the real world.  We won’t be making Punnett squares (sorry to disappoint) and there will be no discussion of nucleotides, protein synthesis, RNA, and other topics related to the actual biological processes of evolution.  Instead, we are going to look at the core principles behind Darwinian evolutionary theory and develop a set of algorithms <em>inspired</em> by these principles.   We don’t care so much about an accurate simulation of evolution; rather, we care about methods for applying evolutionary strategies in software.</p>

<p>This is not to say that a project with more scientific depth wouldn’t have value, and I encourage readers with a particular interest in this topic to explore possibilities for expanding the examples provided with additional evolutionary features.  Nevertheless, for the sake of keeping things manageable, we’re going to stick to the basics, which will be plenty complex and exciting.</p>

<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""defined"">&nbsp;</a></p>

<p>The term “genetic algorithm” refers to a specific algorithm implemented in a specific way to solve specific sorts of problems.   While the formal genetic algorithm itself will serve as the foundation for the examples we create in this chapter, we needn’t worry about implementing the algorithm with perfect accuracy, given that we are looking for creative uses of evolutionary theories in our code.  This chapter will be broken down into the following three parts (with the majority of the time spent on the first).</p>

<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""traditional"">&nbsp;</a>
<a data-type="indexterm" data-primary=""traditional genetic algorithms"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>Traditional Genetic Algorithm.</em></strong>  We’ll begin with the traditional computer science genetic algorithm.  This algorithm was developed to solve problems in which the solution space is so vast that a “brute force” algorithm would simply take too long.   Here’s an example: I’m thinking of a number.  A number between one and one billion.  How long will it take for you to guess it?  Solving a problem with “brute force” refers to the process of checking every possible solution.  Is it one?  Is it two?  Is it three?  Is it four? And so and and so forth.  Though luck does play a factor here, with brute force we would often find ourselves patiently waiting for years while you count to one billion.   However, what if I could tell you if an answer you gave was good or bad?  Warm or cold?   Very warm?  Hot?  Super, super cold?  If you could evaluate how “fit” a guess is, you could pick other numbers closer to that guess and arrive at the answer more quickly.  Your answer could evolve.</p></li>
<li>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""interactive selection"">&nbsp;</a> <a data-type="indexterm" data-primary=""interactive selection genetic algorithms"">&nbsp;</a> <strong><em>Interactive Selection.</em></strong>  Once we establish the traditional computer science algorithm, we’ll look at other applications of genetic algorithms in the visual arts.  Interactive selection refers to the process of evolving something (often an computer-generated image) through user interaction.  Let’s say you walk into a museum gallery and see ten paintings.   With interactive selection, you would pick your favorites and allow an algorithmic process to generate (or “evolve”) new paintings based on your preferences.</p></li>
<li>
<p><strong><em>Ecosystem Simulation.</em></strong>  The traditional computer science genetic algorithm and interactive selection technique are what you will likely find if you search online or read a textbook about artificial intelligence.  But as we’ll soon see, they don’t really simulate the process of evolution as it happens in the real world.   In this chapter, I want to also explore techniques for simulating the process of evolution in an ecosystem of pseudo-living beings.  How can our objects that move about the screen meet each other, mate, and pass their genes on to a new generation?  This would apply directly to the Ecosystem Project outlined at the end of each chapter.</p></li>
</ol>

<p><a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"">&nbsp;</a> <a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""ecosystem simulation"">&nbsp;</a></p>
</section>







<section data-type="sect1" id="chapter09_section2">
<h1>9.2 Why Use Genetic Algorithms?</h1>
<p><a data-type="indexterm" data-primary=""<em>Adaptation in Natural and Artificial Systems</em> (Holland)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""evolutionary computing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""purpose of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Holland" data-secondary="John"">&nbsp;</a></p>

<p>While computer simulations of evolutionary processes date back to the 1950s, much of what we think of as genetic algorithms (also known as “GAs”) today was developed by John Holland, a professor at the University of Michigan, whose book <em>Adaptation in Natural and Artificial Systems</em> pioneered GA research.  Today, more genetic algorithms are part of a wider field of research, often referred to as "Evolutionary Computing."</p>

<p><a data-type="indexterm" data-primary=""brute force method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""infinite monkey theorem"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""infinite monkey theorem"">&nbsp;</a></p>

<p>To help illustrate the traditional genetic algorithm, we are going to start with monkeys.  No, not our evolutionary ancestors.  We’re going to start with some fictional monkeys that bang away on keyboards with the goal of typing out the complete works of Shakespeare.</p>

<figure id="chapter09_figure1">
<img src="imgs/chapter09/ch09_01.png" alt="Figure 9.1"/>
<figcaption/>
</figure>
<p>The “infinite monkey theorem” is stated as follows:  A monkey hitting keys randomly on a typewriter will eventually type the complete works of Shakespeare (given an infinite amount of time).   The problem with this theory is that the probability of said monkey actually typing Shakespeare is so low that even if that monkey started at the Big Bang, it’s unbelievably unlikely we’d even have <em>Hamlet</em> at this point.</p>

<p>Let’s consider a monkey named George.  George types on a reduced typewriter containing only twenty-seven characters: twenty-six letters and one space bar.  So the probability of George hitting any given key is one in twenty-seven.</p>

<p>Let’s consider the phrase “to be or not to be that is the question” (we’re simplifying it from the original “To be, or not to be: that is the question”).  The phrase is 39 characters long. If George starts typing, the chance he’ll get the first character right is 1 in 27. Since the probability he’ll get the second character right is also 1 in 27, he has a 1 in 27*27 chance of landing the first two characters in correct order—which follows directly from our discussion of  <a href="#intro_section3">"event probability" in the Introduction</a>. Therefore, the probability that George will type the full phrase is:</p>

<p>(1/27) multiplied by itself 39 times, i.e. (1/27)<sup>39</sup></p>

<p>which equals a 1 in 66,555,937,033,867,822,607,895,549,241,096,482,953,017,615,834,735,226,163 chance of getting it right!</p>

<p>Needless to say, even hitting just this one phrase, not to mention an entire play, is highly unlikely.   Even if George is a computer simulation and can type one million random phrases per second, for George to have a 99% probability of eventually getting it right, he would have to type for 9,719,096,182,010,563,073,125,591,133,903,305,625,605,017 years. (Note that the age of the universe is estimated to be a mere 13,750,000,000 years.)</p>

<p>The point of all these unfathomably large numbers is not to give you a headache, but to demonstrate that a brute force algorithm (typing every possible random phrase) is not a reasonable strategy for arriving randomly at “to be or not to be that is the question”.   Enter genetic algorithms, which will show that we can still start with random phrases and find the solution through simulated evolution.</p>

<p>Now, it’s worth noting that this problem (<em>arrive at the phrase “to be or not to be that is the question”</em>) is a ridiculous one.  Since we know the answer, all we need to do is type it.  Here’s a Processing sketch that solves the problem.</p>

<pre data-type="programlisting" data-code-language="java">String s = "to be or not to be that is the question";
println(s);</pre>

<p>Nevertheless, the point here is that solving a problem with a known answer allows us to easily test our code.   Once we’ve successfully solved the problem, we can feel more confident in using genetic algorithms to do some actual useful work: solving problems with unknown answers.   So this first example serves no real purpose other than to demonstrate how genetic algorithms work.  If we test the GA results against the known answer and get “to be or not to be”, then we’ve succeeded in writing our genetic algorithm.</p>

<div id="chapter09_exercise1" data-type="example">
<h5>Exercise 9.1</h5>
<p>Create a sketch that generates random strings.  We’ll need to know how to do this in order to implement the genetic algorithm example that will shortly follow.   How long does it take for Processing to randomly generate the string “cat”?  How could you adapt this to generate a random design using Processing’s shape-drawing functions?</p>
</div>
</section>







<section data-type="sect1" id="chapter09_section3">
<h1>9.3  Darwinian Natural Selection</h1>
<p><a data-type="indexterm" data-primary=""Darwinian natural selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""evolution"" data-secondary=""Darwinian natural selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""Darwinian natural selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""Darwinian natural selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural selection algorithms"">&nbsp;</a></p>

<p>Before we begin walking through the genetic algorithm, let’s take a moment to describe three core principles of Darwinian evolution that will be required as we implement our simulation.   In order for natural selection to occur as it does in nature, all three of these elements must be present.</p>

<p><a data-type="indexterm" data-primary=""heredity (natural selection)"">&nbsp;</a></p>

<ol>
<li>
<p><strong><em>Heredity.</em></strong>  There must be a process in place by which children receive the properties of their parents. If creatures live long enough to reproduce, then their traits are passed down to their children in the next generation of creatures.</p></li>
<li>
<p><a data-type="indexterm" data-primary=""variation (natural selection)"">&nbsp;</a> <strong><em>Variation.</em></strong>  There must be a variety of traits present in the population or a means with which to introduce variation.   For example, let’s say there is a population of beetles in which all the beetles are exactly the same: same color, same size, same wingspan, same everything.   Without any variety in the population, the children will always be identical to the parents and to each other.  New combinations of traits can never occur and nothing can evolve.</p></li>
<li>
<p><a data-type="indexterm" data-primary=""selection (natural selection algorithms)"">&nbsp;</a> <strong><em>Selection.</em></strong>  There must be a mechanism by which some members of a population have the opportunity to be parents and pass down their genetic information and some do not.  This is typically referred to as “survival of the fittest.”   For example, let’s say a population of gazelles is chased by lions every day.  The faster gazelles are more likely to escape the lions and are therefore more likely to live longer and have a chance to reproduce and pass their genes down to their children.   The term <em>fittest</em>, however, can be a bit misleading.  Generally, we think of it as meaning bigger, faster, or stronger.   While this may be the case in some instances, natural selection operates on the principle that some traits are better adapted for the creature’s environment and therefore produce a greater likelihood of surviving and reproducing.    It has nothing to do with a given creature being “better” (after all, this is a subjective term) or more “physically fit.”    In the case of our typing monkeys, for example, a more “fit” monkey is one that has typed a phrase closer to “to be or not to be”.</p></li>
</ol>

<p>Next I’d like to walk through the narrative of the genetic algorithm.  We’ll do this in the context of the typing monkey.  The algorithm itself will be divided into two parts: a set of conditions for initialization (i.e. Processing’s <strong function>setup()</strong>) and the steps that are repeated over and over again (i.e. Processing’s <strong function>draw()</strong>) until we arrive at the correct answer.</p>
</section>







<section data-type="sect1" id="chapter09_section4">
<h1>9.4 The Genetic Algorithm, Part I: Creating a Population</h1>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""populations" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural selection algorithms"" data-secondary=""populations" data-tertiary="creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""populations (genetic algorithms)"" data-secondary=""creating"">&nbsp;</a></p>

<p>In the context of the typing monkey example, we will create a population of phrases.  (Note that we are using the term “phrase” rather loosely, meaning a string of characters.)   This begs the question: How do we create this population?  Here is where the Darwinian principle of <strong><em>variation</em></strong> applies.  Let’s say, for simplicity, that we are trying to evolve the phrase “cat” and that we have a population of three phrases.</p>

<p><strong mono>hug<br/>
rid<br/>
won</strong></p>

<p>Sure, there is variety in the three phrases above, but try to mix and match the characters every which way and you will never get <em>cat</em>.  There is not <em>enough</em> variety here to evolve the optimal solution.  However, if we had a population of thousands of phrases, all generated randomly, chances are that at least one member of the population will have a <em>c</em> as the first character, one will have an <em>a</em> as the second, and one a <em>t</em> as the third.  A large population will most likely give us enough variety to generate the desired phrase (and in Part 2 of the algorithm, we’ll have another opportunity to introduce even more variation in case there isn’t enough in the first place).   So we can be more specific in describing Step 1 and say:</p>

<p><strong highlight>Create a population of randomly generated elements.</strong></p>

<p><a data-type="indexterm" data-primary=""populations (genetic algorithms)"" data-secondary=""elements of"">&nbsp;</a></p>

<p>This brings up another important question.   What is the element itself?   As we move through the examples in this chapter, we’ll see several different scenarios; we might have a population of images or a population of vehicles à la <a href="#chapter06_section13">Chapter 6</a>.   The key, and the part that is new for us in this chapter, is that each member of the population has a virtual “DNA,” a set of properties (we can call them “genes”) that describe how a given element looks or behaves.   In the case of the typing monkey, for example, the DNA is simply a string of characters.</p>

<p><a data-type="indexterm" data-primary=""genotype (natural selection algorithms)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""phenotype (natural selection algorithms)"">&nbsp;</a></p>

<p>In the field of genetics, there is an important distinction between the concepts <em>genotype</em> and <em>phenotype</em>.  The actual genetic code—in our case, the digital information itself—is an element’s <strong><em>genotype</em></strong>.   This is what gets passed down from generation to generation.  The <strong><em>phenotype</em></strong>, however, is the expression of that data.   This distinction is key to how you will use genetic algorithms in your own work.  What are the objects in your world?   How will you design the genotype for your objects (the data structure to store each object’s properties) as well as the phenotype (what are <em>you</em> using these variables to express?) We do this all the time in graphics programming.   The simplest example is probably color.</p>

<table>
<tr>
<th>Genotype</th>
<th>Phenotype</th>
</tr>
<tr>
<td>int c = 255;</td>
<td><div style="background-color: #FFFFFF; margin-left: auto; margin-right: auto; border: black thin solid; height: 20px; width: 20px"></div></td>
</tr>
<tr>
<td>int c = 127;</td>
<td><div style="background-color: #7F7F7F; margin-left: auto; margin-right: auto; border: black thin solid; height: 20px; width: 20px"></div></td>
</tr>
<tr>
<td>int c = 0;</td>
<td><div style="background-color: #000000; margin-left: auto; margin-right: auto; border: black thin solid; height: 20px; width: 20px"></div></td>
</tr>
</table>
<p>As we can see, the genotype is the digital information.  Each color is a variable that stores an integer and we choose to express that integer as a color.  But how we choose to express the data is arbitrary.   In a different approach, we could have used the integer to describe the length of a line, the weight of a force, etc.</p>

<table>
<tr>
<th>Same Genotype</th>
<th>Different Phenotype (line length)</th>
</tr>
<tr>
<td>int c = 255;</td>
<td><div style="background-color: #FFFFFF; margin-left: auto; margin-right: auto; border-top: black thin solid; height: 1px; width: 255px"></div></td>
</tr>
<tr>
<td>int c = 127;</td>
<td><div style="background-color: #FFFFFF; margin-left: auto; margin-right: auto; border-top: black thin solid; height: 1px; width: 127px"></div></td>
</tr>
<tr>
<td>int c = 0;</td>
<td><div style="background-color: #FFFFFF; margin-left: auto; margin-right: auto; border-top: black thin solid; height: 1px; width: 0px"></div></td>
</tr>
</table>
<p>The nice thing about our monkey-typing example is that there is no difference between genotype and phenotype.   The DNA data itself is a string of characters and the expression of that data is that very string.</p>

<p>So, we can finally end the discussion of this first step and be more specific with its description, saying:</p>

<p><strong highlight>Create a population of N elements, each with randomly generated DNA.</strong></p>
</section>







<section data-type="sect1" id="chapter09_section5">
<h1>9.5 The Genetic Algorithm, Part II: Selection</h1>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""selection" data-tertiary="implementing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""selection (natural selection algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Here is where we apply the Darwinian principle of <em>selection</em>.   We need to evaluate the population and determine which members are fit to be selected as parents for the next generation.  The process of selection can be divided into two steps.</p>

<p><strong><em>1) Evaluate fitness.</em></strong></p>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural selection algorithms"" data-secondary=""fitness functions"">&nbsp;</a></p>

<p>For our genetic algorithm to function properly, we will need to design what is referred to as a <strong><em>fitness function</em></strong>.  The function will produce a numeric score to describe the fitness of a given member of the population.   This, of course, is not how the real world works at all.  Creatures are not given a score; they simply survive or not.  But in the case of the traditional genetic algorithm, where we are trying to evolve an optimal solution to a problem, we need to be able to numerically evaluate any given possible solution.</p>

<p>Let’s examine our current example, the typing monkey.   Again, let’s simplify the scenario and say we are attempting to evolve the word “cat”.   We have three members of the population: <em>hut</em>, <em>car</em>, and <em>box</em>.   <em>Car</em> is obviously the most fit, given that it has two correct characters, <em>hut</em> has only one, and <em>box</em> has zero.   And there it is, our fitness function:</p>

<p><strong formula>fitness = the number of correct characters</strong></p>

<table>

<thead>
<tr>
<th>DNA</th>
<th>Fitness</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>hut</p></td>
<td><p>1</p></td>
</tr>
<tr>
<td><p>car</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>box</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>

<p>We will eventually want to look at examples with more sophisticated fitness functions, but this is a good place to start.</p>

<p><strong><em>2) Create a mating pool.</em></strong></p>

<p><a data-type="indexterm" data-primary=""mating pools (natural selection)"" data-secondary=""creating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural selection algorithms"" data-secondary=""mating pools" data-tertiary="creating"">&nbsp;</a></p>

<p>Once the fitness has been calculated for all members of the population, we can then select which members are fit to become parents and place them in a mating pool.  There are several different approaches we could take here.  For example, we could employ what is known as the <strong><em>elitist</em></strong> method and say, “Which two members of the population scored the highest?  You two will make all the children for the next generation.”  This is probably one of the easier methods to program; however, it flies in the face of the principle of variation.  If two members of the population (out of perhaps thousands) are the only ones available to reproduce, the next generation will have little variety and this may stunt the evolutionary process.   We could instead make a mating pool out of a larger number—for example, the top 50% of the population, 500 out of 1,000.   This is also just as easy to program, but it will not produce optimal results.   In this case, the high-scoring top elements would have the same chance of being selected as a parent as the ones toward the middle.  And why should element number 500 have a solid shot of reproducing, while element number 501 has no shot?</p>

<p><a data-type="indexterm" data-primary=""natural selection algorithms"" data-secondary=""probability"">&nbsp;</a>
<a data-type="indexterm" data-primary=""probability"" data-secondary=""natural selection algorithms and"">&nbsp;</a></p>

<p>A better solution for the mating pool is to use a <strong><em>probabilistic</em></strong> method, which we’ll call the “wheel of fortune” (also known as the “roulette wheel”).    To illustrate this method, let’s consider a simple example where we have a population of five elements, each with a fitness score.</p>

<table>

<thead>
<tr>
<th>Element</th>
<th>Fitness</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>A</p></td>
<td><p>3</p></td>
</tr>
<tr>
<td><p>B</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>C</p></td>
<td><p>0.5</p></td>
</tr>
<tr>
<td><p>D</p></td>
<td><p>1.5</p></td>
</tr>
<tr>
<td><p>E</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>

<p><a data-type="indexterm" data-primary=""normalization"" data-secondary=""mating pools" data-tertiary="creating with"">&nbsp;</a>
<a data-type="indexterm" data-primary=""roulette wheel probability method"">&nbsp;</a>
<a data-type="indexterm" data-primary=""wheel of fortune probability method"">&nbsp;</a></p>

<p>The first thing we’ll want to do is <strong><em>normalize</em></strong> all the scores.  Remember normalizing a vector?  That involved taking a vector and standardizing its length, setting it to 1.   When we normalize a set of fitness scores, we are standardizing their range to between 0 and 1, as a percentage of total fitness.   Let’s add up all the fitness scores.</p>

<p><strong fomrula>total fitness = 3 + 4 + 0.5 + 1.5 + 1 = 10</strong></p>

<p>Then let’s divide each score by the total fitness, giving us the normalized fitness.</p>

<table>

<thead>
<tr>
<th>Element</th>
<th>Fitness</th>
<th>Normalized Fitness</th>
<th>Expressed as a Percentage</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>A</p></td>
<td><p>3</p></td>
<td><p>0.3</p></td>
<td><p>30%</p></td>
</tr>
<tr>
<td><p>B</p></td>
<td><p>4</p></td>
<td><p>0.4</p></td>
<td><p>40%</p></td>
</tr>
<tr>
<td><p>C</p></td>
<td><p>0.5</p></td>
<td><p>0.05</p></td>
<td><p>5%</p></td>
</tr>
<tr>
<td><p>D</p></td>
<td><p>1.5</p></td>
<td><p>0.15</p></td>
<td><p>15%</p></td>
</tr>
<tr>
<td><p>E</p></td>
<td><p>1</p></td>
<td><p>0.1</p></td>
<td><p>10%</p></td>
</tr>
</tbody>
</table>

<p>Now it’s time for the wheel of fortune.</p>

<figure id="chapter09_figure2">
<img src="imgs/chapter09/ch09_02.png" alt="Figure 9.2"/>
<figcaption/>
</figure>
<p>Spin the wheel and you’ll notice that Element B has the highest chance of being selected, followed by A, then D, then E, and finally C.  This probability-based selection according to fitness is an excellent approach.  One, it guarantees that the highest-scoring elements will be most likely to reproduce.  Two, it does not entirely eliminate any variation from the population.   Unlike with the elitist method, even the lowest-scoring element (in this case C) has a chance to pass its information down to the next generation.    It’s quite possible (and often the case) that even low-scoring elements have a tiny nugget of genetic code that is truly useful and should not entirely be eliminated from the population.   For example, in the case of evolving “to be or not to be”, we might have the following elements.</p>

<p><strong mono>A:    to be or not to go<br/>
B:    to be or not to pi<br/>
C:    xxxxxxxxxxxxxxxxbe</strong></p>

<p>As you can see, elements A and B are clearly the most fit and would have the highest score.  But neither contains the correct characters for the end of the phrase.  Element C, even though it would receive a very low score, happens to have the genetic data for the end of the phrase.  And so while we would want A and B to be picked to generate the majority of the next generation, we would still want C to have a small chance to participate in the reproductive process.</p>
</section>







<section data-type="sect1" id="chapter09_section6">
<h1>9.6 The Genetic Algorithm, Part III: Reproduction</h1>
<p><a data-type="indexterm" data-primary=""heredity (natural selection)"" data-secondary=""implementing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural selection algorithms"" data-secondary=""reproduction"">&nbsp;</a>
<a data-type="indexterm" data-primary=""reproduction (natural selection algorithms)"">&nbsp;</a></p>

<p>Now that we have a strategy for picking parents, we need to figure out how to use <em>reproduction</em> to make the population’s next generation, keeping in mind the Darwinian principle of heredity—that children inherit properties from their parents.  Again, there are a number of different techniques we could employ here.  For example, one reasonable (and easy to program) strategy is asexual reproduction, meaning we pick just one parent and create a child that is an exact copy of that parent.   The standard approach with genetic algorithms, however, is to pick two parents and create a child according to the following steps.</p>

<p><strong><em>1) Crossover.</em></strong></p>

<p><a data-type="indexterm" data-primary=""crossover (natural selection algorithms)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""heredity (natural selection)"" data-secondary=""crossover"">&nbsp;</a></p>

<p>Crossover involves creating a child out of the genetic code of two parents.   In the case of the monkey-typing example, let’s assume we’ve picked two phrases from the mating pool (as outlined in our selection step).</p>

<p><strong mono>Parent A:    FORK<br/>
Parent B:    PLAY</strong></p>

<p>It’s now up to us to make a child phrase from these two.  Perhaps the most obvious way (let’s call this the 50/50 method) would be to take the first two characters from A and the second two from B, leaving us with:</p>

<figure id="chapter09_figure3">
<img src="imgs/chapter09/ch09_03.png" alt="Figure 9.3"/>
<figcaption/>
</figure>
<p>A variation of this technique is to pick a random midpoint.  In other words, we don’t have to pick exactly half of the code from each parent.  We could sometimes end up with FLAY, and sometimes with FORY.  This is preferable to the 50/50 approach, since we increase the variety of possibilities for the next generation.</p>

<figure id="chapter09_figure4">
<img src="imgs/chapter09/ch09_04.png" alt="Figure 9.4: Picking a random midpoint"/>
<figcaption/>
</figure>
<p>Another possibility is to randomly select a parent for each character in the child string.  You can think of this as flipping a coin four times: heads take from parent A, tails from parent B.  Here we could end up with many different results such as: PLRY, FLRK, FLRY, FORY, etc.</p>

<figure id="chapter09_figure5">
<img src="imgs/chapter09/ch09_05.png" alt="Figure 9.5: Coin-flipping approach"/>
<figcaption/>
</figure>
<p>This strategy will produce essentially the same results as the random midpoint method; however, if the order of the genetic information plays some role in expressing the phenotype, you may prefer one solution over the other.</p>

<p><strong><em>2) Mutation.</em></strong></p>

<p><a data-type="indexterm" data-primary=""heredity (natural selection)"" data-secondary=""mutation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""mutation (natural selection algorithms)"">&nbsp;</a></p>

<p>Once the child DNA has been created via crossover, we apply one final process before adding the child to the next generation—<strong><em>mutation</em></strong>.   Mutation is an optional step, as there are some cases in which it is unnecessary.  However, it exists because of the Darwinian principle of variation.  We created an initial population randomly, making sure that we start with a variety of elements.  However, there can only be so much variety when seeding the first generation, and mutation allows us to introduce additional variety throughout the evolutionary process itself.</p>

<figure id="chapter09_figure6" class="half-width-right">
<img src="imgs/chapter09/ch09_06.png" alt="Figure 9.6"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""mutation (natural selection algorithms)"" data-secondary=""rate of"">&nbsp;</a></p>

<p>Mutation is described in terms of a <em>rate</em>.  A given genetic algorithm might have a mutation rate of 5% or 1% or 0.1%, etc.  Let’s assume we just finished with crossover and ended up with the child FORY.  If we have a mutation rate of 1%, this means that for each character in the phrase generated from crossover, there is a 1% chance that it will mutate.  What does it mean for a character to mutate?  In this case, we define mutation as picking a new random character.    A 1% probability is fairly low, and most of the time mutation will not occur at all in a four-character string (96% of the time to be more precise).   However, when it does, the mutated character is replaced with a randomly generated one (see Figure 9.6).</p>

<p>As we’ll see in some of the examples, the mutation rate can greatly affect the behavior of the system.   Certainly, a very high mutation rate (such as, say, 80%) would negate the evolutionary process itself.  If the majority of a child’s genes are generated randomly, then we cannot guarantee that the more “fit” genes occur with greater frequency with each successive generation.</p>

<p>The process of selection (picking two parents) and reproduction (crossover and mutation) is applied over and over again <strong var>N</strong> times until we have a new population of <strong var>N</strong> elements.  At this point, the new population of children becomes the current population and we loop back to evaluate fitness and perform selection and reproduction again.</p>

<p>Now that we have described all the steps of the genetic algorithm in detail, it’s time to translate these steps into Processing code.  Because the previous description was a bit longwinded, let’s look at an overview of the algorithm first.  We’ll then cover each of the three steps in its own section, working out the code.</p>

<p><strong><em>SETUP:</em></strong></p>

<p>Step 1: <strong><em>Initialize</em></strong>. Create a population of N elements, each with randomly generated DNA.</p>

<p><strong><em>LOOP:</em></strong></p>

<p>Step 2: <strong><em>Selection</em></strong>. Evaluate the fitness of each element of the population and build a mating pool.</p>

<p>Step 3: <strong><em>Reproduction</em></strong>. Repeat N times:</p>

<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a) Pick two parents with probability according to relative fitness.<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;b) Crossover—create a “child” by combining the DNA of these two parents.<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c) Mutation—mutate the child’s DNA based on a given probability.<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d) Add the new child to a new population.</p>

<p>Step 4. Replace the old population with the new population and return to Step 2.</p>
</section>







<section data-type="sect1" id="chapter09_section7">
<h1>9.7  Code for Creating the Population</h1>




<section data-type="sect2" id="_step_1_initialize_population">
<h2>Step 1: Initialize Population</h2>
<p><a data-type="indexterm" data-primary=""populations (genetic algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>If we’re going to create a population, we need a data structure to store a list of members of the population.   In most cases (such as our typing-monkey example), the number of elements in the population can be fixed, and so we use an array.  (Later we’ll see examples that involve a growing/shrinking population and we’ll use an <strong klass>ArrayList</strong>.)   But an array of what?   We need an object that stores the genetic information for a member of the population.  Let’s call it <strong><em>DNA</em></strong>.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

}</pre>

<p>The population will then be an array of <strong klass>DNA</strong> objects.</p>

<pre data-type="programlisting" data-code-language="java">// A population of 100 DNA objects
DNA[] population = new DNA[100];</pre>

<p>But what stuff goes in the <strong klass>DNA</strong> class?   For a typing monkey, its DNA is the random phrase it types, a string of characters.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {
  String phrase;
}</pre>

<p>While this is perfectly reasonable for this particular example, we’re not going to use an actual <strong klass>String</strong> object as the genetic code.  Instead, we’ll use an array of characters.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {
  // Each "gene" is one element of the array.
  // We need 18 genes because “to be or not to be” is 18 characters long.
  char[] genes = new char[18];
}</pre>

<p>By using an array, we’ll be able to extend all the code we write into other examples.  For example, the DNA of a creature in a physics system might be an array of <strong klass>PVector</strong><code>s</code>—or for an image, an array of integers (RGB colors).   We can describe any set of properties in an array, and even though a string is convenient for this particular sketch, an array will serve as a better foundation for future evolutionary examples.</p>

<p>Our genetic algorithm dictates that we create a population of N elements, each with <em>randomly generated DNA</em>.  Therefore, in the object’s constructor, we randomly create each character of the array.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {
  char[] genes = new char[18];

  DNA() {
    for (int i = 0; i &lt; genes.length; i++) {
      // Picking randomly from a range of characters
      // with ASCII values between 32 and 128.
      // For more about ASCII:
      // http://en.wikipedia.org/wiki/ASCII[ASCII]
      genes[i] = (char) random(32,128);
    }
  }
}</pre>

<p>Now that we have the constructor, we can return to <strong function>setup()</strong> and initialize each <strong klass>DNA</strong> object in the population array.</p>

<pre data-type="programlisting" data-code-language="java">DNA[] population = new DNA[100];

void setup() {
  for (int i = 0; i &lt; population.length; i++) {
    // Initializing each member of the population
    population[i] = new DNA();
  }
}</pre>

<p>Our <strong klass>DNA</strong> class is not at all complete. We’ll need to add functions to it to perform all the other tasks in our genetic algorithm, which we’ll do as we walk through steps 2 and 3.</p>
</section>







<section data-type="sect2" id="_step_2_selection">
<h2>Step 2: Selection</h2>
<p><a data-type="indexterm" data-primary=""selection (natural selection algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Step 2 reads, <em>“Evaluate the fitness of each element of the population and build a mating pool.”</em>  Let’s first evaluate each object’s fitness.   Earlier we stated that one possible fitness function for our typed phrases is the total number of correct characters.  Let’s revise this fitness function a little bit and state it as the percentage of correct characters—i.e., the total number of correct characters divided by the total characters.</p>

<p><strong formula>Fitness = Total # Characters Correct/Total # Characters</strong></p>

<p>Where should we calculate the fitness?   Since the <strong klass>DNA</strong> class contains the genetic information (the phrase we will test against the target phrase), we can write a function inside the <strong klass>DNA</strong> class itself to score its own fitness.  Let’s assume we have a target phrase:</p>

<pre data-type="programlisting" data-code-language="java">String target = "to be or not to be";</pre>

<p>We can now compare each “gene” against the corresponding character in the target phrase, incrementing a counter each time we get a correct character.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {
  // We are adding another variable to the
  // DNA class to track fitness.
  float fitness;

  // Function to score fitness
  void fitness () {
    int score = 0;
    for (int i = 0; i &lt; genes.length; i++) {
      // Is the character correct?
      if (genes[i] == target.charAt(i)) {
        // If so, increment the score.
        score++;
      }
    }
    // Fitness is the percentage correct.
    fitness = float(score)/target.length();
  }</pre>

<p>In the main tab’s <strong function>draw()</strong>, the very first step we’ll take is to call the fitness function for each member of the population.</p>

<pre data-type="programlisting" data-code-language="java">void draw() {

  for (int i = 0; i &lt; population.length; i++) {
    population[i].fitness();
  }</pre>

<p><a data-type="indexterm" data-primary=""mating pools (natural selection)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>After we have all the fitness scores, we can build the “mating pool” that we’ll need for the reproduction step.  The mating pool is a data structure from which we’ll continuously pick two parents.  Recalling our description of the selection process, we want to pick parents with probabilities calculated according to fitness.  In other words, the members of the population that have the highest fitness scores should be most likely to be picked; those with the lowest scores, the least likely.</p>

<p>In the <a href="#intro_section3">Introduction</a>, we covered the basics of probability and generating a custom distribution of random numbers.    We’re going to use those techniques to assign a probability to each member of the population, picking parents by spinning the “wheel of fortune.”  Let&#8217;s look at Figure 9.2 again.</p>

<figure id="chapter09_figure2">
<img src="imgs/chapter09/ch09_02.png" alt="Figure 9.2 (again)"/>
<figcaption/>
</figure>
<p>It might be fun to do something ridiculous and actually program a simulation of a spinning wheel  as depicted above.  But this is quite unnecessary.</p>

<figure id="chapter09_figure7" class="half-width-right">
<img src="imgs/chapter09/ch09_07.png" alt="Figure 9.7"/>
<figcaption/>
</figure>
<p>Instead we can pick from the five options (ABCDE) according to their probabilities by filling an <strong klass>ArrayList</strong> with multiple instances of each parent.  In other words, let’s say you had a bucket of wooden letters—30 As, 40 Bs, 5 Cs, 15 Ds, and 10 Es.</p>

<p>If you pick a random letter out of that bucket, there’s a 30% chance you’ll get an A, a 5% chance you’ll get a C, and so on.  For us, that bucket is an <strong klass>ArrayList</strong>, and each wooden letter is a potential parent.  We add each parent to the <strong klass>ArrayList</strong> N number of times where N is equal to its percentage score.</p>

<pre data-type="programlisting" data-code-language="java">  // Start with an empty mating pool.
  ArrayList&lt;DNA&gt; matingPool = new ArrayList&lt;DNA&gt;();

  for (int i = 0; i &lt; population.length; i++) {

    // n is equal to fitness times 100,
    // which leaves us with an integer between 0 and 100.
    int n = int(population[i].fitness * 100);
    for (int j = 0; j &lt; n; j++) {
      // Add each member of the population
      // to the mating pool N times.
      matingPool.add(population[i]);
    }
  }</pre>

<div id="chapter09_exercise2" data-type="example">
<h5>Exercise 9.2</h5>
<p>One of the other methods we used to generate a custom distribution of random numbers is called the Monte Carlo method.  This technique involved picking two random numbers, with the second number acting as a qualifying number and determining if the first random number should be kept or thrown away.  Rewrite the above mating pool algorithm to use the Monte Carlo method instead.</p>
</div>

<div id="chapter09_exercise3" data-type="example">
<h5>Exercise 9.3</h5>
<p>In some cases, the wheel of fortune algorithm will have an extraordinarily high preference for some elements over others.  Take the following probabilities:</p>

<p><strong mono>A: 98%<br/>
B: 1%<br/>
C: 1%</strong></p>

<p>This is sometimes undesirable given how it will decrease the amount of variety in this system.  A solution to this problem is to replace the calculated fitness scores with the ordinals of scoring (meaning their rank).</p>

<p><strong mono>A: 50% (3/6)<br/>
B: 33% (2/6)<br/>
C: 17% (1/6)</strong></p>

<p>Rewrite the mating pool algorithm to use this method instead.</p>
</div>
</section>







<section data-type="sect2" id="_step_3_reproduction">
<h2>Step 3: Reproduction</h2>
<p><a data-type="indexterm" data-primary=""reproduction (natural selection algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>With the mating pool ready to go, it’s time to make some babies.  The first step is to pick two parents.  Again, it’s somewhat of an arbitrary decision to pick two parents.  It certainly mirrors human reproduction and is the standard means in the traditional GA, but in terms of your work, there really aren’t any restrictions here.  You could choose to perform “asexual” reproduction with one parent, or come up with a scheme for picking three or four parents from which to generate child DNA.   For this code demonstration, we’ll stick to two parents and call them <strong var>parentA</strong> and <strong var>parentB</strong>.</p>

<p>First thing we need are two random indices into the mating pool—random numbers between 0 and the size of the <strong klass>ArrayList</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  int a = int(random(matingPool.size()));
  int b = int(random(matingPool.size()));</pre>

<p>We can use these indices to retrieve an actual DNA instance from the mating pool.</p>

<pre data-type="programlisting" data-code-language="java">  DNA parentA = matingPool.get(a);
  DNA parentB = matingPool.get(b);</pre>

<p>Because we have multiple instances of the same <strong klass>DNA</strong> objects in the mating pool (not to mention that we could pick the same random number twice), it’s possible that <strong var>parentA</strong> and <strong var>parentB</strong> could be the same <strong klass>DNA</strong> object.  If we wanted to be strict, we could write some code to ensure that we haven’t picked the same parent twice, but we would gain very little efficiency for all that extra code.  Still, it‘s worth trying this as an exercise.</p>

<div id="chapter09_exercise4" data-type="example">
<h5>Exercise 9.4</h5>
<p>Add code to the above to guarantee that you have picked two unique “parents.”</p>
</div>

<p><a data-type="indexterm" data-primary=""crossover (natural selection algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>Once we have the two parents, we can perform <strong><em>crossover</em></strong> to generate the child DNA, followed by <strong><em>mutation</em></strong>.</p>

<pre data-type="programlisting" data-code-language="java">  // A function for crossover
  DNA child = parentA.crossover(parentB);
  // A function for mutation
  child.mutate();</pre>

<p>Of course, the functions <strong function>crossover()</strong> and <strong function>mutate()</strong> don’t magically exist in our <strong klass>DNA</strong> class; we have to write them.   The way we called <strong function>crossover()</strong> above indicates that the function receives an instance of DNA as an argument and returns a new instance of DNA, the child.</p>

<pre data-type="programlisting" data-code-language="java">  // The function receives one argument (DNA) and returns DNA.
  DNA crossover(DNA partner) {

    // The child is a new instance of DNA.
    // Note that the DNA is generated randomly in the constructor,
    // but we will overwrite it below with DNA from parents.
    DNA child = new DNA();

    // Picking a random “midpoint” in the genes array
    int midpoint = int(random(genes.length));

    for (int i = 0; i &lt; genes.length; i++) {
      //[full] Before midpoint copy genes from one parent, after midpoint copy genes from the other parent
      if (i &gt; midpoint) child.genes[i] = genes[i];
      else child.genes[i] = partner.genes[i];
      //[end]
    }

    // Return the new child DNA
    return child;
  }</pre>

<p>The above crossover function uses the “random midpoint” method of crossover, in which the first section of genes is taken from parent A and the second section from parent B.</p>

<div id="chapter09_exercise5" data-type="example">
<h5>Exercise 9.5</h5>
<p>Rewrite the crossover function to use the “coin flipping” method instead, in which each gene has a 50% chance of coming from parent A and a 50% chance of coming from parent B.</p>
</div>

<p><a data-type="indexterm" data-primary=""mutation (natural selection algorithms)"" data-secondary=""implementing"">&nbsp;</a></p>

<p>The mutate() function is even simpler to write than crossover().   All we need to do is loop through the array of genes and for each randomly pick a new character according to the mutation rate.   With a mutation rate of 1%, for example, we would pick a new character one time out of a hundred.</p>

<pre data-type="programlisting" data-code-language="java">float mutationRate = 0.01;

if (random(1) &lt; mutationRate) {
  // Any code here would be executed 1% of the time.

}</pre>

<p>The entire function therefore reads:</p>

<pre data-type="programlisting" data-code-language="java">  void mutate() {
    // Looking at each gene in the array
    for (int i = 0; i &lt; genes.length; i++) {
      if (random(1) &lt; mutationRate) {
        // Mutation, a new random character
        genes[i] = (char) random(32,128);
      }
    }
  }</pre>
</section>


</section>







<section data-type="sect1" id="chapter09_section8">
<h1>9.8  Genetic Algorithms: Putting It All Together</h1>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""building"">&nbsp;</a></p>

<p>You may have noticed that we’ve essentially walked through the steps of the genetic algorithm twice, once describing it in narrative form and another time with code snippets implementing each of the steps.    What I’d like to do in this section is condense the previous two sections into one page, with the algorithm described in just three steps and the corresponding code alongside.</p>

<figure class="screenshot">
<img src="imgs/chapter09/ch09_ex01.png" alt="ch09 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 9.1: Genetic algorithm: Evolving Shakespeare</strong></p>

<pre data-type="programlisting" data-code-language="java">// &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Variables we need for our GA&lt;/b&gt;&lt;/span&gt;

// Mutation rate
float mutationRate;
// Population total
int totalPopulation = 150;

// Population array
DNA[] population;
// Mating pool ArrayList
ArrayList&lt;DNA&gt; matingPool;
// Target phrase
String target;

void setup() {
  size(640, 360);

  // Initializing target phrase and mutation rate
  target = "to be or not to be";
  mutationRate = 0.01;

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 1: Initialize Population&lt;/b&gt;&lt;/span&gt;
  population = new DNA[totalPopulation];
  for (int i = 0; i &lt; population.length; i++) {
    population[i] = new DNA();
  }
}

void draw() {

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 2: Selection&lt;/b&gt;&lt;/span&gt;

  // Step 2a: Calculate fitness.
  for (int i = 0; i &lt; population.length; i++) {
    population[i].fitness();
  }

  // Step 2b: Build mating pool.
  ArrayList&lt;DNA&gt; matingPool = new ArrayList&lt;DNA&gt;();

  for (int i = 0; i &lt; population.length; i++) {
    //[full] Add each member n times according to its fitness score.
    int n = int(population[i].fitness * 100);
    for (int j = 0; j &lt; n; j++) {
      matingPool.add(population[i]);
    }
    //[end]
  }

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 3: Reproduction&lt;/b&gt;&lt;/span&gt;
  for (int i = 0; i &lt; population.length; i++) {
    int a = int(random(matingPool.size()));
    int b = int(random(matingPool.size()));
    DNA partnerA = matingPool.get(a);
    DNA partnerB = matingPool.get(b);
    // Step 3a: Crossover
    DNA child = partnerA.crossover(partnerB);
    // Step 3b: Mutation
    child.mutate(mutationRate);

    // Note that we are overwriting the population with the new
    // children.  When draw() loops, we will perform all the same
    // steps with the new population of children.
    population[i] = child;
  }
}</pre>

<p>The main tab precisely mirrors the steps of the genetic algorithm.  However, most of the functionality called upon is actually present in the <strong klass>DNA</strong> class itself.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {


  char[] genes;
  float fitness;

  //[full] Create DNA randomly.
  DNA() {
    genes = new char[target.length()];
    for (int i = 0; i &lt; genes.length; i++) {
      genes[i] = (char) random(32,128);
    }
  }
  //[end]

  //[full] Calculate fitness.
  void fitness() {
     int score = 0;
     for (int i = 0; i &lt; genes.length; i++) {
        if (genes[i] == target.charAt(i)) {
          score++;
        }
     }
     fitness = float(score)/target.length();
  }
  //[end]

  //[full] Crossover
  DNA crossover(DNA partner) {
    DNA child = new DNA(genes.length);
    int midpoint = int(random(genes.length));
    for (int i = 0; i &lt; genes.length; i++) {
      if (i &gt; midpoint) child.genes[i] = genes[i];
      else              child.genes[i] = partner.genes[i];
    }
    return child;
  }
  //[end]

  //[full] Mutation
  void mutate(float mutationRate) {
    for (int i = 0; i &lt; genes.length; i++) {
      if (random(1) &lt; mutationRate) {
        genes[i] = (char) random(32,128);
      }
    }
  }
  //[end]

  //[full] Convert to String—PHENOTYPE.
  String getPhrase() {
    return new String(genes);
  }
  //[end]

}</pre>

<div id="chapter09_exercise6" data-type="example">
<h5>Exercise 9.6</h5>
<p>Add features to the above example to report more information about the progress of the genetic algorithm itself.   For example, show the phrase closest to the target each generation, as well as report on the number of generations, average fitness, etc.  Stop the genetic algorithm once it has solved the phrase.  Consider writing a <strong klass>Population</strong> class to manage the GA, instead of including all the code in draw().</p>

<figure class="screenshot">
<img src="imgs/chapter09/ch09_exc01.png" alt="ch09 exc01"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter09_section9">
<h1>9.9  Genetic Algorithms: Make Them Your Own</h1>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""modifying"">&nbsp;</a></p>

<p>The nice thing about using genetic algorithms in a project is that example code can easily be ported from application to application.  The core mechanics of selection and reproduction don’t need to change.  There are, however, three key components to genetic algorithms that you, the developer, will have to customize for each use.  This is crucial to moving beyond trivial demonstrations of evolutionary simulations (as in the Shakespeare example) to creative uses in projects that you make in Processing and other creative programming environments.</p>





<section data-type="sect2" id="_key_1_varying_the_variables">
<h2>Key #1: Varying the variables</h2>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""mutation rate" data-tertiary="varying"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""population maximum" data-tertiary="varying"">&nbsp;</a></p>

<p>There aren’t a lot of variables to the genetic algorithm itself. In fact, if you look at the previous example’s code, you’ll see only two global variables (not including the arrays and <strong klass>ArrayList</strong><code>s</code> to store the population and mating pool).</p>

<pre data-type="programlisting" data-code-language="java">float mutationRate = 0.01;
int totalPopulation = 150;</pre>

<p>These two variables can greatly affect the behavior of the system, and it’s not such a good idea to arbitrarily assign them values (though tweaking them through trial and error is a perfectly reasonable way to arrive at optimal values).</p>

<p>The values I chose for the Shakespeare demonstration were picked to virtually guarantee that the genetic algorithm would solve for the phrase, but not too quickly (approximately 1,000 generations on average) so as to demonstrate the process over a reasonable period of time.    A much larger population, however, would yield faster results (if the goal were algorithmic efficiency rather than demonstration).  Here is a table of some results.</p>

<table>

<thead>
<tr>
<th>Total Population</th>
<th>Mutation Rate</th>
<th>Number of Generations until Phrase Solved</th>
<th>Total Time (in seconds) until Phrase Solved</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>150</p></td>
<td><p>1%</p></td>
<td><p>1089</p></td>
<td><p>18.8</p></td>
</tr>
<tr>
<td><p>300</p></td>
<td><p>1%</p></td>
<td><p>448</p></td>
<td><p>8.2</p></td>
</tr>
<tr>
<td><p>1,000</p></td>
<td><p>1%</p></td>
<td><p>71</p></td>
<td><p>1.8</p></td>
</tr>
<tr>
<td><p>50,000</p></td>
<td><p>1%</p></td>
<td><p>27</p></td>
<td><p>4.3</p></td>
</tr>
</tbody>
</table>

<p>Notice how increasing the population size drastically reduces the number of generations needed to solve for the phrase.  However, it doesn’t necessarily reduce the amount of time.  Once our population balloons to fifty thousand elements, the sketch runs slowly, given the amount of time required to process fitness and build a mating pool out of so many elements. (There are, of course, optimizations that could be made should you require such a large population.)</p>

<p>In addition to the population size, the mutation rate can greatly affect performance.</p>

<table>

<thead>
<tr>
<th>Total Population</th>
<th>Mutation Rate</th>
<th>Number of Generations until Phrase Solved</th>
<th>Total Time (in seconds) until Phrase Solved</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1,000</p></td>
<td><p>0%</p></td>
<td><p>37 or never?</p></td>
<td><p>1.2 or never?</p></td>
</tr>
<tr>
<td><p>1,000</p></td>
<td><p>1%</p></td>
<td><p>71</p></td>
<td><p>1.8</p></td>
</tr>
<tr>
<td><p>1,000</p></td>
<td><p>2%</p></td>
<td><p>60</p></td>
<td><p>1.6</p></td>
</tr>
<tr>
<td><p>1,000</p></td>
<td><p>10%</p></td>
<td><p>never?</p></td>
<td><p>never?</p></td>
</tr>
</tbody>
</table>

<p>Without any mutation at all (0%), you just have to get lucky.  If all the correct characters are present somewhere in some member of the initial population, you’ll evolve the phrase very quickly.  If not, there is no way for the sketch to ever reach the exact phrase.  Run it a few times and you’ll see both instances.  In addition, once the mutation rate gets high enough (10%, for example), there is so much randomness involved (1 out of every 10 letters is random in each new child) that the simulation is pretty much back to a random typing monkey.  In theory, it will eventually solve the phrase, but you may be waiting much, much longer than is reasonable.</p>
</section>







<section data-type="sect2" id="_key_2_the_fitness_function">
<h2>Key #2: The fitness function</h2>
<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""exponential vs. linear"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""fitness algorithms" data-tertiary="modifying"">&nbsp;</a></p>

<p>Playing around with the mutation rate or population total is pretty easy and involves little more than typing numbers in your sketch.  The real hard work of a developing a genetic algorithm is in writing a fitness function.  If you cannot define your problem’s goals and evaluate numerically how well those goals have been achieved, then you will not have successful evolution in your simulation.</p>

<p>Before we think about other scenarios with other fitness functions, let’s look at flaws in our Shakespearean fitness function.   Consider solving for a phrase that is not nineteen characters long, but one thousand.  Now, let’s say there are two members of the population, one with 800 characters correct and one with 801.  Here are their fitness scores:</p>

<table>

<tbody>
<tr>
<td><p>Phrase A:</p></td>
<td><p>800 characters correct</p></td>
<td><p>fitness = 80%</p></td>
</tr>
<tr>
<td><p>Phrase B:</p></td>
<td><p>801 characters correct</p></td>
<td><p>fitness = 80.1%</p></td>
</tr>
</tbody>
</table>

<p>There are a couple of problems here.  First, we are adding elements to the mating pool N numbers of times, where N equals fitness multiplied by 100.  Objects can only be added to an <strong klass>ArrayList</strong> a whole number of times, and so A and B will both be added 80 times, giving them an equal probability of being selected.  Even with an improved solution that takes floating point probabilities into account, 80.1% is only a teeny tiny bit higher than 80%.  But getting 801 characters right is a whole lot better than 800 in the evolutionary scenario.  We really want to make that additional character count.   We want the fitness score for 801 characters to be  exponentially better than the score for 800.</p>

<p>To put it another way, let’s graph the fitness function.</p>

<figure id="chapter09_figure8">
<img src="imgs/chapter09/ch09_08.png" alt="Figure 9.8"/>
<figcaption/>
</figure>
<p>This is a linear graph; as the number of characters goes up, so does the fitness score.   However, what if the fitness increased exponentially as the number of correct characters increased?  Our graph could then look something like:</p>

<figure id="chapter09_figure9">
<img src="imgs/chapter09/ch09_09.png" alt="Figure 9.9"/>
<figcaption/>
</figure>
<p>The more correct characters, the even greater the fitness.  We can achieve this type of result in a number of different ways.  For example, we could say:</p>

<p><strong formula>fitness = (number of correct characters) * (number of correct characters)</strong></p>

<p>Let’s say we have two members of the population, one with five correct characters and one with six.   The number 6 is a 20% increase over the number 5.   Let’s look at the fitness scores squared.</p>

<table>

<thead>
<tr>
<th>Characters correct</th>
<th>Fitness</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>5</p></td>
<td><p>25</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>36</p></td>
</tr>
</tbody>
</table>

<p>The fitness scores increase exponentially relative to the number of correct characters.  36 is a 44% increase over 25.</p>

<p>Here’s another formula.</p>

<p><strong formula>fitness = 2<sup>(number of correct characters)</sup></strong></p>

<table>

<thead>
<tr>
<th>Characters correct</th>
<th>Fitness</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>8</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>

<p>Here, the fitness scores increase at a faster rate, doubling with each additional correct character.</p>

<div id="chapter09_exercise7" data-type="example">
<h5>Exercise 9.7</h5>
<p>Rewrite the fitness function to increase exponentially according to the number of correct characters.  Note that you will also have to normalize the fitness values to a range between 0 and 1 so they can be added to the mating pool a reasonable number of times.</p>
</div>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""design your own"">&nbsp;</a></p>

<p>While this rather specific discussion of exponential vs. linear fitness functions is an important detail in the design of a good fitness function, I don’t want us to miss the more important point here: <em>Design your own fitness function!</em>    I seriously doubt that any project you undertake in Processing with genetic algorithms will actually involve counting the correct number of characters in a string.   In the context of this book, it’s more likely you will be looking to evolve a creature that is part of a physics system.  Perhaps you are looking to optimize the weights of steering behaviors so a creature can best escape a predator or avoid an obstacle or make it through a maze.   You have to ask yourself what you&#8217;re hoping to evaluate.</p>

<p>Let’s consider a racing simulation in which a vehicle is evolving a design optimized for speed.</p>

<p><strong formula>fitness = total number of frames required for vehicle to reach target</strong></p>

<p>How about a cannon that is evolving the optimal way to shoot a target?</p>

<p><strong formula>fitness = cannonball distance to target</strong></p>

<p>The design of computer-controlled players in a game is also a common scenario.  Let’s say you are programming a soccer game in which the user is the goalie.   The rest of the players are controlled by your program and have a set of parameters that determine how they kick a ball towards the goal.  What would the fitness score for any given player be?</p>

<p><strong formula>fitness = total goals scored</strong></p>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""robotic enslavement of humanity and"">&nbsp;</a></p>

<p>This, obviously, is a simplistic take on the game of soccer, but it illustrates the point.  The more goals a player scores, the higher its fitness, and the more likely its genetic information will appear in the next game.   Even with a fitness function as simple as the one described here, this scenario is demonstrating something very powerful—the adaptability of a system.  If the players continue to evolve from game to game to game, when a new <em>human</em> user enters the game with a completely different strategy, the system will quickly discover that the fitness scores are going down and evolve a new optimal strategy.  It will adapt.  (Don’t worry, there is very little danger in this resulting in sentient robots that will enslave all humans.)</p>

<p>In the end, if you do not have a fitness function that effectively evaluates the performance of the individual elements of your population, you will not have any evolution.  And the fitness function from one example will likely not apply to a totally different project.  So this is the part where you get to shine.  You have to design a function, sometimes from scratch, that works for your particular project.   And where do you do this?   All you have to edit are those few lines of code inside the function that computes the fitness variable.</p>

<pre data-type="programlisting" data-code-language="java">void fitness() {
  ????????????
  ????????????
  fitness = ??????????
}</pre>
</section>







<section data-type="sect2" id="_key_3_genotype_and_phenotype">
<h2>Key #3: Genotype and Phenotype</h2>
<p><a data-type="indexterm" data-primary=""genotype (natural selection algorithms)"" data-secondary=""modifying"">&nbsp;</a>
<a data-type="indexterm" data-primary=""phenotype (natural selection algorithms)"">&nbsp;</a></p>

<p>The final key to designing your own genetic algorithm relates to how you choose to encode the properties of your system.  What are you trying to express, and how can you translate that expression into a bunch of numbers?   What is the genotype and phenotype?</p>

<p>When talking about the fitness function, we happily assumed we could create computer-controlled kickers that each had a “set of parameters that determine how they kick a ball towards the goal.”   However, what those parameters are and how you choose to encode them is up to you.</p>

<p>We started with the Shakespeare example because of how easy it was to design both the genotype (an array of characters) and its expression, the phenotype (the string drawn in the window).</p>

<p>The good news is—and we hinted at this at the start of this chapter—you’ve really been doing this all along.  Anytime you write a class in Processing, you make a whole bunch of variables.</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {
  float maxspeed;
  float maxforce;
  float size;
  float separationWeight;
  [inline]// etc.</pre>

<p>All we need to do to evolve those parameters is to turn them into an array, so that the array can be used with all of the functions—<strong function>crossover()</strong>, <strong function>mutate()</strong>, etc.—found in the <strong klass>DNA</strong> class.  One common solution is to use an array of floating point numbers between 0 and 1.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  // An array of floats
  float[] genes;

  DNA(int num) {
    genes = new float[num];
    for (int i = 0; i &lt; genes.length; i++) {
      // Always pick a number between 0 and 1.
      genes[i] = float(1);
    }
  }</pre>

<p>Notice how we’ve now put the genetic data (genotype) and its expression (phenotype) into two separate classes.  The <strong klass>DNA</strong> class is the genotype and the <strong klass>Vehicle</strong> class uses a <strong klass>DNA</strong> object to drive its behaviors and express that data visually—it is the phenotype.  The two can be linked by creating a <strong klass>DNA</strong> instance inside the <strong klass>Vehicle</strong> class itself.</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {
  // A DNA object embedded into the Vehicle class
  DNA dna;

  float maxspeed;
  float maxforce;
  float size;
  float separationWeight;
  // Etc.

  Vehicle() {
    DNA = new DNA(4);
    // Using the genes to set variables
    maxspeed = dna.genes[0];
    maxforce = dna.genes[1];
    size = dna.genes[2];
    separationWeight = dna.genes[3];
    // Etc.
  }</pre>

<p>Of course, you most likely don’t want all your variables to have a range between 0 and 1.  But rather than try to remember how to adjust those ranges in the <strong klass>DNA</strong> class itself, it’s easier to pull the genetic information from the <strong klass>DNA</strong> object and use Processing’s <strong function>map()</strong> function to change the range.  For example, if you want a size variable between 10 and 72, you would say:</p>

<pre data-type="programlisting" data-code-language="java">    size = map(dna.genes[2],0,1,10,72);</pre>

<p>In other cases, you will want to design a genotype that is an array of objects.   Consider the design of a rocket with a series of “thruster” engines.   You could describe each thruster with a <strong klass>PVector</strong> that outlines its direction and relative strength.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  // The genotype is an array of PVectors.
  PVector[] genes;

  DNA(int num) {
    genes = new PVector[num];
    for (int i = 0; i &lt; genes.length; i++) {
      // A PVector pointing in a random direction
      genes[i] = PVector.random2D();
      // And scaled randomly
      genes[i].mult(random(10));
    }
  }</pre>

<p>The phenotype would be a <strong klass>Rocket</strong> class that participates in a physics system.</p>

<pre data-type="programlisting" data-code-language="java">class Rocket {
  DNA dna;
  [inline]// etc.</pre>

<p><a data-type="indexterm" data-primary=""object-oriented programming"" data-secondary=""genotype/phenotype objects and"">&nbsp;</a></p>

<p>What’s great about this technique of dividing the genotype and phenotype into separate classes (<strong klass>DNA</strong> and <strong klass>Rocket</strong> for example) is that when it comes time to build all of the code, you’ll notice that the <strong klass>DNA</strong> class we developed earlier remains intact.   The only thing that changes is the array’s data type (<strong klass>float</strong>, <strong klass>PVector</strong>, etc.) and the expression of that data in the phenotype class.</p>

<p>In the next section, we’ll follow this idea a bit further and walk through the necessary steps for an example that involves moving bodies and an array of <strong klass>PVector</strong><code>s</code> as DNA.</p>
</section>


</section>







<section data-type="sect1" id="chapter09_section10">
<h1>9.10  Evolving Forces: Smart Rockets</h1>
<p><a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""Smart Rockets (Thorp)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Smart Rockets (Thorp)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Thorp" data-secondary="Jer"">&nbsp;</a></p>

<p>We picked the rocket idea for a specific reason.  In 2009, <a href="http://blprnt.com">Jer Thorp</a> released a genetic algorithms example on his blog entitled “Smart Rockets.”  Jer points out that NASA uses evolutionary computing techniques to solve all sorts of problems, from satellite antenna design to rocket firing patterns. This inspired him to create a Flash demonstration of evolving rockets.  Here is a description of the scenario:</p>

<p>A population of rockets launches from the bottom of the screen with the goal of hitting a target at the top of the screen (with obstacles blocking a straight line path).</p>

<figure id="chapter09_figure10" class="screenshot">
<img src="imgs/chapter09/ch09_10.png" alt="Figure 9.10"/>
<figcaption/>
</figure>
<figure id="chapter09_figure11" class="half-width-right">
<img src="imgs/chapter09/ch09_11.png" alt="Figure 9.11"/>
<figcaption/>
</figure>
<p>Each rocket is equipped with five thrusters of variable strength and direction.    The thrusters don’t fire all at once and continuously; rather, they fire one at a time in a custom sequence.</p>

<p>In this section, we’re going to evolve our own simplified Smart Rockets, inspired by Jer Thorp’s.   When we get to the end of the section, we’ll leave implementing some of Jer’s additional advanced features as an exercise.</p>

<p>Our rockets will have only one thruster, and this thruster will be able to fire in any direction with any strength for every frame of animation.  This isn’t particularly realistic, but it will make building out the framework a little easier. (We can always make the rocket and its thrusters more advanced and realistic later.)</p>

<p>Let’s start by taking our basic <strong klass>Mover</strong> class from Chapter 2 examples and renaming it <strong klass>Rocket</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Rocket {

  //[full] A rocket has three vectors: location, velocity, acceleration.
  PVector location;
  PVector velocity;
  PVector acceleration;
  //[end]

  //[full] Accumulating forces into acceleration (Newton’s 2nd law)
  void applyForce(PVector f) {
    acceleration.add(f);
  }
  //[end]

  // Our simple physics model (Euler integration)
  void update() {
    // Velocity changes according to acceleration.
    velocity.add(acceleration);
    // Location changes according to velocity.
    location.add(velocity);
    acceleration.mult(0);
  }
}</pre>

<p>Using the above framework, we can implement our smart rocket by saying that for every frame of animation, we call <strong function>applyForce()</strong> with a new force.   The “thruster” applies a single force to the rocket each time through <strong function>draw()</strong>.</p>

<p>Considering this example, let’s go through the three keys to programming our own custom genetic algorithm example as outlined in the previous section.</p>

<p><strong>Key #1: Population size and mutation rate</strong></p>

<p>We can actually hold off on this first key for the moment.  Our strategy will be to pick some reasonable numbers (a population of 100 rockets, mutation rate of 1%) and build out the system, playing with these numbers once we have our sketch up and running.</p>

<p><strong>Key #2: The fitness function</strong></p>

<p>We stated the goal of a rocket reaching a target.   In other words, the closer a rocket gets to the target, the higher the fitness.    Fitness is inversely proportional to distance: the smaller the distance, the greater the fitness; the greater the distance, the smaller the fitness.</p>

<p>Let’s assume we have a <strong klass>PVector</strong> target.</p>

<pre data-type="programlisting" data-code-language="java">  void fitness() {
    // How close did we get?
    float d = PVector.dist(location,target);
    // Fitness is inversely proportional to distance.
    fitness = 1/d;
  }</pre>

<p>This is perhaps the simplest fitness function we could write.  By using one divided by distance, large distances become small numbers and small distances become large.</p>

<table>

<thead>
<tr>
<th>distance</th>
<th>1 / distance</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>300</p></td>
<td><p>1 / 300 = 0.0033</p></td>
</tr>
<tr>
<td><p>100</p></td>
<td><p>1 / 100 = 0.01</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>1 / 5   = 0.2</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>1 / 1   = 1.0</p></td>
</tr>
<tr>
<td><p>0.1</p></td>
<td><p>1 / 0.1 = 10</p></td>
</tr>
</tbody>
</table>

<p>And if we wanted to use our exponential trick from the previous section, we could use one divided by distance squared.</p>

<table>

<thead>
<tr>
<th>distance</th>
<th>1 / distance</th>
<th>(1 / distance)<sup>2</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td><p>300</p></td>
<td><p>1 / 400 = 0.0025</p></td>
<td><p>0.00000625</p></td>
</tr>
<tr>
<td><p>100</p></td>
<td><p>1 / 100 = 0.01</p></td>
<td><p>0.0001</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>1 / 5   = 0.2</p></td>
<td><p>0.04</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>1 / 1   = 1.0</p></td>
<td><p>1.0</p></td>
</tr>
<tr>
<td><p>0.1</p></td>
<td><p>1 / 0.1 = 10</p></td>
<td><p>100</p></td>
</tr>
</tbody>
</table>

<p>There are several additional improvements we’ll want to make to the fitness function, but this simple one is a good start.</p>

<pre data-type="programlisting" data-code-language="java">void fitness() {
  float d = PVector.dist(location,target);
  // Squaring 1 divided by distance
  fitness = pow(1/d,2);
}</pre>

<p><strong highlight>Key #3: Genotype and Phenotype</strong></p>

<p>We stated that each rocket has a thruster that fires in a variable direction with a variable magnitude in each frame.   And so we need a <strong klass>PVector</strong> for each frame of animation.  Our genotype, the data required to encode the rocket’s behavior, is therefore an array of <strong klass>PVector</strong><code>s</code>.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {
  PVector[] genes;</pre>

<p>The happy news here is that we don’t really have to do anything else to the <strong klass>DNA</strong> class.  All of the functionality we developed for the typing monkey (crossover and mutation) applies here.  The one difference we do have to consider is how we initialize the array of genes.  With the typing monkey, we had an array of characters and picked a random character for each element of the array.   Here we’ll do exactly the same thing and initialize a DNA sequence as an array of random <strong klass>PVector</strong><code>s</code>.   Now, your instinct in creating a random <strong klass>PVector</strong> might be as follows:</p>

<pre data-type="programlisting" data-code-language="java">PVector v = new PVector(random(-1,1),random(-1,1));</pre>

<figure id="chapter09_figure12" class="half-width-right">
<img src="imgs/chapter09/ch09_12.png" alt="Figure 9.12"/>
<figcaption/>
</figure>
<p>This is perfectly fine and will likely do the trick.  However, if we were to draw every single possible vector we might pick, the result would fill a square (see Figure 9.12).  In this case, it probably doesn’t matter, but there is a slight bias to diagonals here given that a <strong klass>PVector</strong> from the center of a square to a corner is longer than a purely vertical or horizontal one.</p>

<figure id="chapter09_figure13" class="half-width-right">
<img src="imgs/chapter09/ch09_13.png" alt="Figure 9.13"/>
<figcaption/>
</figure>
<p>What would be better here is to pick a random angle and make a <strong klass>PVector</strong> of length one from that angle, giving us a circle (see Figure 9.13). This could be easily done with a <a href="#chapter03_section5">quick polar to Cartesian conversion</a>, but a quicker path to the result is just to use <strong klass>PVector</strong>'s <strong function>random2D()</strong>.</p>

<pre data-type="programlisting" data-code-language="java">for (int i = 0; i &lt; genes.length; i++) {
  // Making a PVector from a random angle
  genes[i] = PVector.random2D();
}</pre>

<p>A <strong klass>PVector</strong> of length one is actually going to be quite a large force.  Remember, forces are applied to acceleration, which accumulates into velocity thirty times per second.   So, for this example, we can also add one more variable to the <strong klass>DNA</strong> class: a maximum force that scales all the <strong klass>PVector</strong><code>s</code>.    This will control the thruster power.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  // The genetic sequence is an array of PVectors.
  PVector[] genes;

  // How strong can the thrusters be?
  float maxforce = 0.1;

  DNA() {
    // We need a PVector for every frame of the rocket’s life.
    genes = new PVector[lifetime];
    for (int i = 0; i &lt; genes.length; i++) {
      genes[i] = PVector.random2D();
      // Scaling the PVectors randomly,
      // but no stronger than maximum force
      genes[i].mult(random(0, maxforce));
    }
  }</pre>

<p>Notice also that we created an array of <strong klass>PVector</strong><code>s</code> with length lifetime.   We need a <strong klass>PVector</strong> for each frame of the rocket’s life, and the above assumes the existence of a global variable lifetime that stores the total number of frames in each generation’s life cycle.</p>

<p>The expression of this array of <strong klass>PVector</strong><code>s</code>, the phenotype, is a <strong klass>Rocket</strong> class modeled on our basic <strong klass>PVector</strong> and forces examples from Chapter 2.   All we need to do is add an instance of a <strong klass>DNA</strong> object to the class.  The fitness variable will also live here.   Only the <strong klass>Rocket</strong> object knows how to compute its distance to the target, and therefore the fitness function will live here in the phenotype as well.</p>

<pre data-type="programlisting" data-code-language="java">class Rocket {

  // A Rocket has DNA.
  DNA dna;
  // A Rocket has fitness.
  float fitness;

  PVector location;
  PVector velocity;
  PVector acceleration;</pre>

<p>What are we using the DNA for?  We are marching through the array of <strong klass>PVector</strong><code>s</code> and applying them one at a time as a force to the rocket.  To do this, we’ll also have to add an integer that acts as a counter to walk through the array.</p>

<pre data-type="programlisting" data-code-language="java">  int geneCounter = 0;

  void run() {
    // Apply a force from the genes array.
    applyForce(dna.genes[geneCounter]);
    // Go to the next force in the genes array.
    geneCounter++;
    // Update the Rocket’s physics.
    update();
  }</pre>
</section>







<section data-type="sect1" id="chapter09_section11">
<h1>9.11 Smart Rockets: Putting It All Together</h1>
<p>We now have our <strong klass>DNA</strong> class (genotype) and our <strong klass>Rocket</strong> class (phenotype).  The last piece of the puzzle is a <strong klass>Population</strong> class, which manages an array of rockets and has the functionality for selection and reproduction.   Again, the happy news here is that we barely have to change anything from the Shakespeare monkey example.  The process for building a mating pool and generating a new array of child rockets is exactly the same as what we did with our population of strings.</p>

<pre data-type="programlisting" data-code-language="java">class Population {

  // Population has variables to keep
  // track of mutation rate, current
  // population array, mating pool, and
  // number of generations.
  float mutationRate;
  Rocket[] population;
  ArrayList&lt;Rocket&gt; matingPool;
  int generations;

  //[full] These functions haven’t changed, so
  // no need to go through the code again.
  void fitness() {}
  void selection() {}
  void reproduction() {}
  //[end]</pre>

<p>There is one fairly significant change, however.   With typing monkeys, a random phrase was evaluated as soon as it was created.  The string of characters had no lifespan; it existed purely for the purpose of calculating its fitness and then we moved on.   The rockets, however, need to live for a period of time before they can be evaluated; they need to be given a chance to make their attempt at reaching the target.   Therefore, we need to add one more function to the <strong klass>Population</strong> class that runs the physics simulation itself.   This is identical to what we did in the <strong function>run()</strong> function of a particle system—update all the particle locations and draw them.</p>

<pre data-type="programlisting" data-code-language="java">  void live () {
    for (int i = 0; i &lt; population.length; i++) {
      // The run function takes care of
      // the forces, updating the rocket’s
      // location, and displaying it.
      population[i].run();
    }
  }</pre>

<p>Finally, we’re ready for <strong function>setup()</strong> and <strong function>draw()</strong>.   Here in the main tab, our primary responsibility is to implement the steps of the genetic algorithm in the appropriate order by calling the functions in the <strong klass>Population</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">    population.fitness();
    population.selection();
    population.reproduction();</pre>

<p>However, unlike the Shakespeare example, we don’t want to do this every frame.  Rather, our steps work as follows:</p>

<ol>
<li>
<p>Create a population of rockets</p></li>
<li>
<p>Let the rockets live for N frames</p></li>
<li>
<p>Evolve the next generation</p>
<ul>
<li>
<p>Selection</p></li>
<li>
<p>Reproduction</p></li>
</ul>
</li>
<li>
<p>Return to Step #2</p></li>
</ol>

<figure class="screenshot" data-pde="processingjs/chapter09/_9_02_SmartRockets_superbasic/DNA.pde processingjs/chapter09/_9_02_SmartRockets_superbasic/Population.pde  processingjs/chapter09/_9_02_SmartRockets_superbasic/Rocket.pde processingjs/chapter09/_9_02_SmartRockets_superbasic/_9_02_SmartRockets_superbasic.pde">
<img src="imgs/chapter09/ch09_ex02.png" alt="ch09 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 9.2: Simple Smart Rockets</strong></p>

<pre data-type="programlisting" data-code-language="java">// How many frames does a generation live for?
int lifetime;

// What frame are we on?
int lifeCounter;

// The population
Population population;

void setup() {
  size(640, 480);
  lifetime = 500;
  lifeCounter = 0;

  float mutationRate = 0.01;
  // Step 1: Create the population.
  // Here is where we could play with
  // the mutation rate and population size.
  population = new Population(mutationRate, 50);
}

void draw() {
  background(255);
  // The revised genetic algorithm
  if (lifeCounter &lt; lifetime) {
    // Step 2: The rockets live their
    // life until lifeCounter reaches lifetime.
    population.live();
    lifeCounter++;
  } else {
    // When lifetime is reached, reset
    // lifeCounter and evolve the next
    // generation (Steps 3 and 4,
    // selection and reproduction).
    lifeCounter = 0;
    population.fitness();
    population.selection();
    population.reproduction();
  }
}</pre>

<p>The above example works, but it isn’t particularly interesting.  After all, the rockets simply evolve to having DNA with a bunch of vectors that point straight upwards.  In the next example, we’re going to talk through two suggested improvements for the example and provide code snippets that implement these improvements.</p>

<figure class="screenshot" data-pde="processingjs/chapter09/_9_03_SmartRockets/DNA.pde processingjs/chapter09/_9_03_SmartRockets/Obstacle.pde processingjs/chapter09/_9_03_SmartRockets/Population.pde  processingjs/chapter09/_9_03_SmartRockets/Rocket.pde processingjs/chapter09/_9_03_SmartRockets/_9_03_SmartRockets.pde">
<img src="imgs/chapter09/ch09_ex03.png" alt="ch09 ex03"/>
<figcaption/>
</figure>
<p><strong highlight>Improvement #1: Obstacles</strong></p>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""avoidance of obstacles and"">&nbsp;</a></p>

<p>Adding obstacles that the rockets must avoid will make the system more complex and demonstrate the power of the evolutionary algorithm more effectively.  We can make rectangular, stationary obstacles fairly easily by creating a class that stores a location and dimensions.</p>

<p><strong example>Example 9.3: Smart Rockets</strong></p>

<pre data-type="programlisting" data-code-language="java">class Obstacle {

  // An obstacle is a location (top left
  // corner of rectangle) with a width and height.
  PVector location;
  float w,h;</pre>

<p>We can also write a <strong function>contains()</strong> function that will <strong var>return true</strong> or <strong var>return false</strong> to determine if a rocket has hit the obstacle.</p>

<pre data-type="programlisting" data-code-language="java">  boolean contains(PVector v) {
    if (v.x &gt; location.x &amp;&amp; v.x &lt; location.x + w &amp;&amp; v.y &gt; location.y &amp;&amp; v.y &lt; location.y + h) {
      return true;
    } else {
      return false;
    }
  }</pre>

<p>Assuming we make an <strong klass>ArrayList</strong> of obstacles, we can then have each rocket check to see if it has collided with an obstacle and set a <strong klass>boolean</strong> flag to be true if it does, adding a function to the rocket class.</p>

<pre data-type="programlisting" data-code-language="java">  // This new function lives in the rocket
  // class and checks if a rocket has
  // hit an obstacle.
  void obstacles() {
    for (Obstacle obs : obstacles) {
      if (obs.contains(location)) {
        stopped = true;
      }
    }
  }</pre>

<p>If the rocket hits an obstacle, we choose to stop it from updating its location.</p>

<pre data-type="programlisting" data-code-language="java">  void run() {
    // Only run the rocket if it doesn’t hit an obstacle.
    if (!stopped) { //[bold]
      applyForce(dna.genes[geneCounter]);
      geneCounter = (geneCounter + 1) % dna.genes.length;
      update();
      obstacles(); //[bold]
    }
  }</pre>

<p>And we also have an opportunity to adjust the rocket’s fitness.  We consider it to be pretty terrible if the rocket hits an obstacle, and so its fitness should be greatly reduced.</p>

<pre data-type="programlisting" data-code-language="java">  void fitness() {
    float d = dist(location.x, location.y, target.location.x, target.location.y);
    fitness = pow(1/d, 2);
    if (stopped) fitness *= 0.1; //[bold]
  }</pre>

<p><strong highlight>Improvement #2: Evolve reaching the target faster</strong></p>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""evolving for specific attributes"">&nbsp;</a></p>

<p>If you look closely at our first Smart Rockets example, you’ll notice that the rockets are not rewarded for getting to the target faster.  The only variable in their fitness calculation is the distance to the target at the end of the generation’s life.  In fact, in the event that the rockets get very close to the target but overshoot it and fly past, they may actually be penalized for getting to the target faster.   Slow and steady wins the race in this case.</p>

<p>We could improve the algorithm to optimize for speed a number of ways.  First, instead of using the distance to the target at the end of the generation, we could use the distance that is the closest to the target at any point during the rocket’s life.  We would call this the rocket’s “record” distance.  (All of the code snippets in this section live inside the <strong klass>Rocket</strong> class.)</p>

<pre data-type="programlisting" data-code-language="java">  void checkTarget() {
    float d = dist(location.x, location.y, target.location.x, target.location.y);
    // Every frame, we check its distance and see
    // if it’s closer than the “record” distance.
    // If it is, we have a new record.
    if (d &lt; recordDist) recordDist = d;</pre>

<p>In addition, a rocket should be rewarded according to how quickly it reaches the target.  The faster it reaches the target, the higher the fitness.   The slower, the lower.  To accomplish this, we can increment a counter every cycle of the rocket’s life until it reaches the target.  At the end of its  life, the counter will equal the amount of time the rocket took to reach that target.</p>

<pre data-type="programlisting" data-code-language="java">    // If the object reaches the target,
    // set a boolean flag to true.
    if (target.contains(location)) {
      hitTarget = true;
    } else if (!hitTarget) {
      // As long as we haven’t yet reached
      // the target, keep incrementing the counter.
      finishTime++;
    }
}</pre>

<p>Fitness is also inversely proportional to <strong var>finishTime</strong>, and so we can improve our fitness function as follows:</p>

<pre data-type="programlisting" data-code-language="java">  void fitness() {

    // Finish time and record distance!
    fitness = (1/(finishTime*recordDist));
    // Make it exponential.
    fitness = pow(fitness, 2);

    // Fitness goes way down if you hit an obstacle.
    if (stopped) fitness *= 0.1;
    // You are rewarded for reaching the target.
    if (hitTarget) fitness *= 2;
  }</pre>

<p>These improvements are both incorporated into the code for Example 9.3: Smart Rockets.</p>

<div id="chapter09_exercise8" data-type="example">
<h5>Exercise 9.8</h5>
<p>Create a more complex obstacle course. As you make it more difficult for the rockets to reach the target, do you need to improve other aspects of the GA—for example, the fitness function?</p>
</div>

<div id="chapter09_exercise9" data-type="example">
<h5>Exercise 9.9</h5>
<p>Implement the rocket firing pattern of Jer Thorp’s Smart Rockets.  Each rocket only gets five thrusters (of any direction and strength) that follow a firing sequence (of arbitrary length).   <a href="http://www.blprnt.com/smartrockets/">Jer’s simulation</a> also gives the rockets a finite amount of fuel.</p>
</div>

<div id="chapter09_exercise10" data-type="example">
<h5>Exercise 9.10</h5>
<p>Visualize the rockets differently.  Can you draw a line for the shortest path to the target?  Can you add particle systems that act as smoke in the direction of the rocket thrusters?</p>
</div>

<div id="chapter09_exercise11" data-type="example">
<h5>Exercise 9.11</h5>
<p>Another way to achieve a similar result is to evolve a flow field.  Can you make the genotype of a rocket a flow field of <strong klass>PVector</strong><code>s</code>?</p>
</div>

<p><a data-type="indexterm" data-primary=""Evolved Virtual Creatures (Sims)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Sims" data-secondary="Karl"">&nbsp;</a></p>

<p>One of the more famous implementations of genetic algorithms in computer graphics is Karl Sims’s “Evolved Virtual Creatures.”   In Sims’s work, a population of digital creatures (in a simulated physics environment) is evaluated for the creatures' ability to perform tasks, such as swimming, running, jumping, following, and competing for a green cube.</p>

<p>One of the innovations in Sims’s work is a node-based genotype.  In other words, the creature’s DNA is not a linear list of <strong klass>PVector</strong><code>s</code> or numbers, but a map of nodes.  (For an example of this, take a look at <a href="#chapter05_exercise15">Exercise 5.15</a>, toxiclibs' Force Directed Graph.)  The phenotype is the creature’s design itself, a network of limbs connected with muscles.</p>

<div id="chapter09_exercise12" data-type="example">
<h5>Exercise 9.12</h5>
<figure class="half-width-right">
<img src="imgs/chapter09/ch09_exc12.png" alt="ch09 exc12"/>
<figcaption/>
</figure>
<p>Using toxiclibs or Box2D as the physics model, can you create a simplified 2D version of Sims’s creatures? For a lengthier description of Sims’s techniques, I suggest you watch the video and read Sims’s paper <a href="http://www.karlsims.com/evolved-virtual-creatures.html">
Virtual Creatures</a>.   In addition, you can find a similar example that uses Box2D to evolve a “car”: <a href="http://boxcar2d.com/">BoxCar2D</a>.</p>

<figure>
<img src="imgs/blank.png" alt="blank"/>
<figcaption/>
</figure></div>
</section>







<section data-type="sect1" id="chapter09_section12">
<h1>9.12 Interactive Selection</h1>
<p><a data-type="indexterm" data-primary=""interactive selection genetic algorithms"">&nbsp;</a></p>

<p>In addition to Evolved Virtual Creatures, Sims is also well known for his museum installation <em>Galapagos</em>.  Originally installed in the Intercommunication Center in Tokyo in 1997, the installation consists of twelve monitors displaying computer-generated images.  These images evolve over time, following the genetic algorithm steps of selection and reproduction.  The innovation here is not the use of the genetic algorithm itself, but rather the strategy behind the fitness function.    In front of each monitor is a sensor on the floor that can detect the presence of a user viewing the screen.  The fitness of an image is tied to the length of time that viewers look at the image.  This is known as <em>interactive selection</em>, a genetic algorithm with fitness values assigned by users.</p>

<p>Think of all the rating systems you’ve ever used.  Could you evolve the perfect movie by scoring all films according to your Netflix ratings?  The perfect singer according to American Idol voting?</p>

<figure id="chapter09_figure14" class="half-width-right">
<img src="imgs/chapter09/ch09_14.png" alt="Figure 9.14"/>
<figcaption/>
</figure>
<p>To illustrate this technique, we’re going to build a population of simple faces.  Each face will have a set of properties: head size, head color, eye location, eye size, mouth color, mouth location, mouth width, and mouth height.</p>

<p>The face’s DNA (genotype) is an array of floating point numbers between 0 and 1, with a single value for each property.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  float[] genes;
  // We need 20 numbers to draw the face.
  int len = 20;

  DNA() {
    genes = new float[len];
    for (int i = 0; i &lt; genes.length; i++) {
      // Each gene is a random float between 0 and 1.
      genes[i] = random(0,1);
    }
  }</pre>

<p>The phenotype is a <strong klass>Face</strong> class that includes an instance of a <strong klass>DNA</strong> object.</p>

<pre data-type="programlisting" data-code-language="java">class Face {

  DNA dna;
  float fitness;</pre>

<p>When it comes time to draw the face on screen, we can use Processing’s <strong function>map()</strong> function to convert any gene value to the appropriate range for pixel dimensions or color values. (In this case,  we are also using <strong function>colorMode()</strong> to set the RGB ranges between 0 and 1.)</p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    //[full] Using map() to convert the genes to a range for drawing the face.
    float r          = map(dna.genes[0],0,1,0,70);

    color c          = color(dna.genes[1],dna.genes[2],dna.genes[3]);
    float eye_y      = map(dna.genes[4],0,1,0,5);
    float eye_x      = map(dna.genes[5],0,1,0,10);
    float eye_size   = map(dna.genes[5],0,1,0,10);
    color eyecolor   = color(dna.genes[4],dna.genes[5],dna.genes[6]);
    color mouthColor = color(dna.genes[7],dna.genes[8],dna.genes[9]);
    float mouth_y    = map(dna.genes[5],0,1,0,25);
    float mouth_x    = map(dna.genes[5],0,1,-25,25);
    float mouthw     = map(dna.genes[5],0,1,0,50);
    float mouthh     = map(dna.genes[5],0,1,0,10);
    //[end]</pre>

<p>So far, we’re not really doing anything new.  This is what we’ve done in every GA example so far.   What’s new is that we are not going to write a <strong function>fitness()</strong> function in which the score is computed based on a math formula.   Instead, we are going to ask the user to assign the fitness.</p>

<p><a data-type="indexterm" data-primary=""interactive selection genetic algorithms"" data-secondary=""user interaction and"">&nbsp;</a></p>

<p>Now, how best to ask a user to assign fitness is really more of an interaction design problem, and it isn’t really within the scope of this book.    So we’re not going to launch into an elaborate discussion of how to program sliders or build your own hardware dials or build a Web app for users to submit online scores.  How you choose to acquire fitness scores is really up to you and the particular application you are developing.</p>

<p>For this simple demonstration, we’ll increase fitness whenever a user rolls the mouse over a face.  The next generation is created when the user presses a button with an “evolve next generation” label.</p>

<p>Let’s look at how the steps of the genetic algorithm are applied in the main tab, noting how fitness is assigned according to mouse interaction and the next generation is created on a button press.  The rest of the code for checking mouse locations, button interactions, etc. can be found in the accompanying example code.</p>

<figure class="screenshot" data-pde="processingjs/chapter09/_9_04_Faces_interactiveselection/Button.pde processingjs/chapter09/_9_04_Faces_interactiveselection/DNA.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Face.pde processingjs/chapter09/_9_04_Faces_interactiveselection/_9_04_Faces_interactiveselection.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Population.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Rectangle.pde">
<img src="imgs/chapter09/ch09_ex04.png" alt="ch09 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 9.4: Interactive selection</strong></p>

<pre data-type="programlisting" data-code-language="java">Population population;
Button button;

void setup() {
  size(780,200);
  float mutationRate = 0.05;
  population = new Population(mutationRate,10);
  button = new Button(15,150,160,20, "evolve new generation");
}

void draw() {

  population.display();
  // The mouse location is passed to
  // the population, which will score
  // each face according to rollover time.
  population.rollover(mouseX,mouseY); //[bold]
  button.display();
}

void mousePressed() {
  // When a button is pressed,
  // the new generation is created
  // via selection and reproduction.
  if (button.clicked(mouseX,mouseY)) { //[bold]
    population.selection();
    population.reproduction();
  }
}</pre>

<p>This example, it should be noted, is really just a demonstration of the idea of interactive selection and does not achieve a particularly meaningful result.  For one, we didn’t take much care in the visual design of the faces; they are just a few simple shapes with sizes and colors.  Sims, for example, used more elaborate mathematical functions as his images’ genotype.  You might also consider a vector-based approach, in which a design’s genotype is a set of points and/or paths.</p>

<p><a data-type="indexterm" data-primary=""interactive selection genetic algorithms"" data-secondary=""time lag and"">&nbsp;</a></p>

<p>The more significant problem here, however, is one of time.  In the natural world, evolution occurs over millions of years.  In the computer simulation world of our previous examples, we were able to evolve behaviors relatively quickly because we were producing new generations algorithmically.  In the Shakespeare monkey example, a new generation was born in each frame of animation (approximately sixty per second).   Since the fitness values were computed according to a math formula, we could also have had arbitrarily large populations that increased the speed of evolution.  In the case of interactive selection, however, we have to sit and wait for a user to rate each and every member of the population before we can get to the next generation.   A large population would be unreasonably tedious to deal with—not to mention, how many generations could you stand to sit through?</p>

<p>There are certainly clever solutions around this.  Sims’s Galapagos exhibit concealed the rating process from the users, as it occurred through the normal behavior of looking at artwork in a museum setting.  Building a Web application that would allow many users to rate a population in a distributed fashion is also a good strategy for achieving many ratings for large populations quickly.</p>

<p>In the end, the key to a successful interactive selection system boils down to the same keys we previously established.   What is the genotype and phenotype?  And how do you calculate fitness, which in this case we can revise to say: “What is your strategy for assigning fitness according to user interaction?”</p>

<div id="chapter09_exercise14" data-type="example">
<h5>Exercise 9.14</h5>
<p>Build your own interactive selection project.   In addition to a visual design, consider evolving sounds—for example, a short sequence of tones.  Can you devise a strategy, such as a Web application or physical sensor system, to acquire ratings from many users over time?</p>
</div>
</section>







<section data-type="sect1" id="chapter09_section13">
<h1>9.13  Ecosystem Simulation</h1>
<p><a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genetic algorithms"" data-secondary=""ecosystem simulation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""natural phenomena"" data-secondary=""ecosystems" data-tertiary="modeling"">&nbsp;</a>
<a data-type="indexterm" data-primary=""populations (genetic algorithms)"" data-secondary=""ecosystem simulations and"">&nbsp;</a></p>

<p>You may have noticed something a bit odd about every single evolutionary system we’ve built so far in this chapter.   After all, in the real world, a population of babies isn’t born all at the same time.  Those babies don’t then grow up and all reproduce at exactly the same time, then instantly die to leave the population size perfectly stable.   That would be ridiculous.  Not to mention the fact that there is certainly no one running around the forest with a calculator crunching numbers and assigning fitness values to all the creatures.</p>

<p>In the real world, we don’t really have “survival of the fittest”; we have “survival of the survivors.”  Things that happen to live longer, for whatever reason, have a greater chance of reproducing.   Babies are born, they live for a while, maybe they themselves have babies, maybe they don’t, and then they die.</p>

<p>You won’t necessarily find simulations of “real-world” evolution in artificial intelligence textbooks.  Genetic algorithms are generally used in the more formal manner we outlined in this chapter.   However, since we are reading this book to develop simulations of natural systems, it’s worth looking at some ways in which  we might use a genetic algorithm to build something that resembles a living “ecosystem,” much like the one we’ve described in the exercises at the end of each chapter.</p>

<p>Let’s begin by developing a very simple scenario.  We’ll create a creature called a "bloop," a circle that moves about the screen according to Perlin noise.  The creature will have a radius and a maximum speed.  The bigger it is, the slower it moves; the smaller, the faster.</p>

<pre data-type="programlisting" data-code-language="java">class Bloop {
  // A location
  PVector location;

  // Variables for size and speed
  float r;
  float maxspeed;

  // Some variables for Perlin noise calculations
  float xoff, yoff;

  void update() {
    float vx = map(noise(xoff),0,1,-maxspeed,maxspeed);
    float vy = map(noise(yoff),0,1,-maxspeed,maxspeed);
    // A little Perlin noise algorithm to calculate a velocity
    PVector velocity = new PVector(vx,vy);
    xoff += 0.01;
    yoff += 0.01;

    // The bloop moves.
    location.add(velocity);
  }

  // A bloop is a circle.
  void display() {
    ellipse(location.x, location.y, r, r);
  }
}</pre>

<p>The above is missing a few details (such as initializing the variables in the constructor), but you get the idea.</p>

<p>For this example, we’ll want to store the population of bloops in an <strong klass>ArrayList</strong>, rather than an array, as we expect the population to grow and shrink according to how often bloops die or are born.  We can store this <strong klass>ArrayList</strong> in a class called <strong klass>World</strong>, which will manage all the elements of the bloops’ world.</p>

<pre data-type="programlisting" data-code-language="java">class World {

  // A list of bloops
  ArrayList&lt;Bloop&gt; bloops;

  World(int num) {
    bloops = new ArrayList&lt;Bloop&gt;();

    for (int i = 0; i &lt; num; i++) {
      // Making an initial population of bloops
      bloops.add(new Bloop());
    }
  }</pre>

<p>So far, what we have is just a rehashing of our particle system example from Chapter 5.  We have an entity (<strong klass>Bloop</strong>) that moves around the window and a class (<strong klass>World</strong>) that manages a variable quantity of these entities.   To turn this into a system that evolves, we need to add two additional features to our world:</p>

<ul>
<li>
<p><strong><em>Bloops die.</em></strong></p></li>
<li>
<p><strong><em>Bloops are born.</em></strong></p></li>
</ul>

<p><a data-type="indexterm" data-primary=""fitness functions (natural selection algorithms)"" data-secondary=""ecosystem simulations and"">&nbsp;</a></p>

<p>Bloops dying is our replacement for a fitness function, the process of “selection.” If a bloop dies, it cannot be selected to be a parent, because it simply no longer exists!   One way we can build a mechanism to ensure bloop deaths in our world is by adding a <strong var>health</strong> variable to the <strong klass>Bloop</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">class Bloop {
  // A bloop is born with 100 health points.
  float health = 100;</pre>

<p>In each frame of animation, a bloop loses some health.</p>

<pre data-type="programlisting" data-code-language="java">  void update() {
    // All that other stuff for movement

    // Death is always looming!
    health -= 1;
  }</pre>

<p>If health drops below 0, the bloop dies.</p>

<pre data-type="programlisting" data-code-language="java">  //[full] We add a function to the Bloop class
  // to test if the bloop is alive or dead.
  boolean dead() {
    if (health &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }
  //[end]</pre>

<p>This is a good first step, but we haven’t really achieved anything.  After all, if all bloops start with 100 health points and lose 1 point per frame, then all bloops will live for the exact same amount of time and die together.   If every single bloop lives the same amount of time, they all have equal chances of reproducing and therefore nothing will evolve.</p>

<p><a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"" data-secondary=""lifespans" data-tertiary="varying"">&nbsp;</a></p>

<p>There are many ways we could achieve variable lifespans with a more sophisticated world.  For example, we could introduce predators that eat bloops.  Perhaps the faster bloops would be able to escape being eaten more easily, and therefore our world would evolve to have faster and faster bloops.  Another option would be to introduce food.  When a bloop eats food, it increases its health points, and therefore extends its life.</p>

<p>Let’s assume we have an <strong klass>ArrayList</strong> of <strong klass>PVector</strong> locations for food, named “food.”  We could test each bloop’s proximity to each food location.  If the bloop is close enough, it eats the food (which is then removed from the world) and increases its health.</p>

<pre data-type="programlisting" data-code-language="java">  void eat() {
    for (int i = food.size()-1; i &gt;= 0; i--) {
      PVector foodLocation = food.get(i);
      float d = PVector.dist(location, foodLocation);
      // Is the Bloop close to the food?
      if (d &lt; r/2) {

        // If so, it gets 100 more health points.
        health += 100;
        // The food is no longer available for other Bloops.
        food.remove(i);
      }
    }
  }</pre>

<p>Now we have a scenario in which bloops that eat more food live longer and have a greater likelihood of reproducing.  Therefore, we expect that our system would evolve bloops with an optimal ability to find and eat food.</p>

<p>Now that we have built our world, it’s time to add the components required for evolution.  First we should establish our genotype and phenotype.</p>





<section data-type="sect2" id="_genotype_and_phenotype">
<h2>Genotype and Phenotype</h2>
<p><a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"" data-secondary=""genotype"">&nbsp;</a>
<a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"" data-secondary=""phenotype"">&nbsp;</a>
<a data-type="indexterm" data-primary=""genotype (natural selection algorithms)"" data-secondary=""ecosystem simulation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""phenotype (natural selection algorithms)"" data-secondary=""ecosystem simulation"">&nbsp;</a></p>

<p>The ability for a bloop to find food is tied to two variables—size and speed.  Bigger bloops will find food more easily simply because their size will allow them to intersect with food locations more often. And faster bloops will find more food because they can cover more ground in a shorter period of time.</p>

<figure id="chapter09_figure15" class="half-width-right">
<img src="imgs/chapter09/ch09_15.png" alt="Figure 9.15"/>
<figcaption/>
</figure>
<p>Since size and speed are inversely related (large bloops are slow, small bloops are fast), we only need a genotype with a single number.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  float[] genes;

  DNA() {
    // It may seem absurd to use an
    // array when all we have is a single
    // value, but we stick with an array in
    // case we want to make more sophisticated bloops later.
    genes = new float[1];
    for (int i = 0; i &lt; genes.length; i++) {
      genes[i] = random(0,1);
    }
  }</pre>

<p>The phenotype then is the bloop itself, whose size and speed is assigned by adding an instance of a <strong klass>DNA</strong> object to the <strong klass>Bloop</strong> class.</p>

<pre data-type="programlisting" data-code-language="java">class Bloop {
  PVector location;
  float health;

  // A bloop now has DNA.
  DNA dna;
  float r;
  float maxspeed;

  Bloop(DNA dna_) {
    location = new PVector(width/2,height/2);
    health = 200;
    dna = dna_;

    //[full] maxspeed and r (radius) are mapped
    // to values according to the DNA.
    maxspeed = map(dna.genes[0], 0, 1, 15, 0);
    r        = map(dna.genes[0], 0, 1, 0, 50);
    //[end]
  }</pre>

<p>Notice that with <strong var>maxspeed</strong>, the range is mapped to between 15 and 0, meaning a bloop with a gene value of 0 moves at a speed of 15 and a bloop with a gene value of 1 doesn’t move at all (speed of 0).</p>
</section>







<section data-type="sect2" id="_selection_and_reproduction">
<h2>Selection and Reproduction</h2>
<p><a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"" data-secondary=""reproduction"">&nbsp;</a>
<a data-type="indexterm" data-primary=""ecosystem simulation genetic algorithms"" data-secondary=""selection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""reproduction (natural selection algorithms)"" data-secondary=""ecosystem simulation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""selection (natural selection algorithms)"" data-secondary=""ecosystem simulation"">&nbsp;</a></p>

<p>Now that we have the genotype and phenotype, we need to move on to devising a means for bloops to be selected as parents.  We stated before that the longer a bloop lives, the more chances it has to reproduce.    The length of life is the bloop’s fitness.</p>

<p>One option would be to say that whenever two bloops come into contact with each other, they make a new bloop.  The longer a bloop lives, the more likely it is to come into contact with another bloop.  (This would also affect the evolutionary outcome given that, in addition to eating food, their ability to find other bloops is a factor in the likelihood of having a baby.)</p>

<p>A simpler option would be to have “asexual” reproduction, meaning a bloop does not require a partner.  It can, at any moment, make a clone of itself, another bloop with the same genetic makeup.   If we state this selection algorithm as follows:</p>

<p><strong><em>At any given moment, a bloop has a 1% chance of reproducing.</em></strong></p>

<p>&#8230;then the longer a bloop lives, the more likely it will make at least one child.  This is equivalent to saying the more times you play the lottery, the greater the likelihood you’ll win (though I’m sorry to say your chances of that are still essentially zero).</p>

<p>To implement this selection algorithm, we can write a function in the <strong klass>Bloop</strong> class that picks a random number every frame. If the number is less than 0.01 (1%), a new bloop is born.</p>

<pre data-type="programlisting" data-code-language="java">  // This function will return a new bloop, the child.
  Bloop reproduce() {

    // A 1% chance of executing the code in
    // this conditional, i.e. a 1% chance of reproducing
    if (random(1) &lt; 0.01) {
      [inline] // Make the Bloop baby
    }
  }</pre>

<p>How does a bloop reproduce?   In our previous examples, the reproduction process involved calling the <strong function>crossover()</strong> function in the <strong klass>DNA</strong> class and making a new object from the newly made DNA.  Here, since we are making a child from a single parent, we’ll call a function called <strong function>copy()</strong> instead.</p>

<pre data-type="programlisting" data-code-language="java">  Bloop reproduce() {
    if (random(1) &lt; 0.0005) {
      // Make a copy of the DNA.
      DNA childDNA = dna.copy(); //[bold]
      // 1% mutation rate
      childDNA.mutate(0.01); //[bold]
      // Make a new bloop at the same location with the new DNA.
      return new Bloop(location, childDNA); //[bold]

    } else { //[bold]
      // If the bloop does not
      // reproduce, return null.
      return null; //[bold]
    }
  }</pre>

<p>Note also that we’ve reduced the probability of reproducing from 1% to 0.05%.  This value makes quite a difference; with a high probability of reproducing, the system will quickly tend towards overpopulation.   Too low a probability, and everything will likely quickly die out.</p>

<p>Writing the <strong function>copy()</strong> function into the <strong klass>DNA</strong> class is easy since Processing includes a function <strong function>arraycopy()</strong> that copies the contents of one array into another.</p>

<pre data-type="programlisting" data-code-language="java">class DNA {

  // This copy() function replaces
  // crossover() in this example.
  DNA copy() {

    // Make a new array the same
    // length and copy its contents.
    float[] newgenes = new float[genes.length];
    arraycopy(genes,newgenes);
    return new DNA(newgenes);
  }
}</pre>

<p>Now that we have all the pieces in place for selection and reproduction, we can finalize the <strong klass>World</strong> class that manages the list of all <strong klass>Bloop</strong> objects (as well as a <strong klass>Food</strong> object, which itself is a list of <strong klass>PVector</strong> locations for food).</p>

<p>Before you run the example, take a moment to guess what size and speed of bloops the system will evolve towards.  We’ll discuss following the code.</p>

<figure class="screenshot" data-pde="processingjs/chapter09/_9_05_EvolutionEcosystem/_9_05_EvolutionEcosystem.pde processingjs/chapter09/_9_05_EvolutionEcosystem/Bloop.pde processingjs/chapter09/_9_05_EvolutionEcosystem/DNA.pde processingjs/chapter09/_9_05_EvolutionEcosystem/Food.pde processingjs/chapter09/_9_05_EvolutionEcosystem/World.pde">
<img src="imgs/chapter09/ch09_ex05.png" alt="ch09 ex05"/>
<figcaption/>
</figure>
<p><strong example>Example 9.5: Evolution ecosystem</strong></p>

<pre data-type="programlisting" data-code-language="java">World world;

//[full] setup() and draw() do nothing more than create
// and run a World object.
void setup() {
  size(600,400);
  world = new World(20);
}

void draw() {
  background(255);
  world.run();
}
//[end]

class World {

  // The World object keeps track of the
  // population bloops as well as the food.
  ArrayList&lt;Bloop&gt; bloops;
  Food food;

  World(int num) {
    food = new Food(num);
    bloops = new ArrayList&lt;Bloop&gt;();

    // Creating the population
    for (int i = 0; i &lt; num; i++) {
      PVector location = new PVector(random(width),random(height));
      DNA dna = new DNA();
      bloops.add(new Bloop(l,dna));
    }
  }

  void run() {
    food.run();

    for (int i = bloops.size()-1; i &gt;= 0; i--) {
      // The bloops live their life.
      Bloop b = bloops.get(i);
      b.run();
      b.eat(food);
      //[full] If one dies, it is removed from the population and food is added at its location.
      if (b.dead()) {
        bloops.remove(i);
        food.add(b.location);
      }
      //[end]

      //[full] Here is where each living bloop has
      // a chance to reproduce.  As long as a
      // child is made (i.e. not null) it is
      // added to the population.
      Bloop child = b.reproduce();
      if (child != null) bloops.add(child);


      //[end]
    }
  }
}</pre>

<p>If you guessed medium-sized bloops with medium speed, you were right.   With the design of this system, bloops that are large are simply too slow to find food.  And bloops that are fast are too small to find food.   The ones that are able to live the longest tend to be in the middle, large enough and fast enough to find food (but not too large or too fast).  There are also some anomalies.     For example, if it so happens that a bunch of large bloops end up in the same location (and barely move because they are so large), they may all die out suddenly, leaving a lot of food for one large bloop who happens to be there to eat and allowing a mini-population of large bloops to sustain themselves for a period of time in one location.</p>

<p>This example is rather simplistic given its single gene and asexual reproduction.   Here are some suggestions for how you might apply the bloop example in a more elaborate ecosystem simulation.</p>

<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 9 Exercise:</p>

<p>Add evolution to your ecosystem, building from the examples in this chapter.</p>

<ul>
<li>
<p>Add a population of predators to your ecosystem.   Biological evolution between predators and prey (or parasites and hosts) is often referred to as an “arms race,” in which the creatures continuously adapt and counter-adapt to each other.   Can you achieve this behavior in a system of multiple creatures?</p></li>
<li>
<p>How would you implement crossover and mutation between two parents in an ecosystem modeled after the bloops?  Try implementing an algorithm so that two creatures meet and mate when within a certain proximity.   Can you make creatures with gender?</p></li>
<li>
<p>Try using the weights of multiple steering forces as a creature’s DNA.   Can you create a scenario in which creatures evolve to cooperate with each other?</p></li>
<li>
<p>One of the greatest challenges in ecosystem simulations is achieving a nice balance.  You will likely find that most of your attempts result in either mass overpopulation (followed by mass extinction) or simply mass extinction straight away.  What techniques can you employ to achieve balance?  Consider using the genetic algorithm itself to evolve optimal parameters for an ecosystem.</p></li>
</ul>
</div>
<div style="page-break-after:always;"> </div></section>


</section>



</section>







<section data-type="chapter" id="_chapter_10_neural_networks">
<h1>Chapter 10.  Neural Networks</h1>
<blockquote data-type="epigraph"><p>“You can&#8217;t process me with a normal brain.”</p>
<p data-type="attribution">&#8212; — Charlie Sheen</p>
</blockquote>

<p><a data-type="indexterm" data-primary=""artificial intelligence"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"">&nbsp;</a></p>

<p>We’re at the end of our story.   This is the last official chapter of this book (though I envision additional supplemental material for the website and perhaps new chapters in the future).    We began with inanimate objects living in a world of forces and gave those objects desires, autonomy, and the ability to take action according to a system of rules.  Next, we allowed those objects to live in a population and evolve over time.  Now we ask: What is each object’s decision-making process?  How can it adjust its choices by learning over time?  Can a computational entity process its environment and generate a decision?</p>

<p>The human brain can be described as a biological neural network—an interconnected web of neurons transmitting elaborate patterns of electrical signals.   Dendrites receive input signals and, based on those inputs, fire an output signal via an axon.  Or something like that.  How the human brain actually works is an elaborate and complex mystery, one that we certainly are not going to attempt to tackle in rigorous detail in this chapter.</p>

<figure id="chapter10_figure1">
<img src="imgs/chapter10/ch10_01.png" alt="Figure 10.1"/>
<figcaption/>
</figure>
<p>The good news is that developing engaging animated systems with code does not require scientific rigor or accuracy, as we’ve learned throughout this book.   We can simply be inspired by the idea of brain function.</p>

<p>In this chapter, we’ll begin with a conceptual overview of the properties and features of neural networks and build the simplest possible example of one (a network that consists of a single neuron).  Afterwards, we’ll examine strategies for creating a “Brain” object that can be inserted into our <strong klass>Vehicle</strong> class and used to determine steering.   Finally, we’ll also look at techniques for visualizing and animating a network of neurons.</p>




<section data-type="sect1" id="chapter10_section1">
<h1>10.1 Artificial Neural Networks: Introduction and Application</h1>
<p><a data-type="indexterm" data-primary=""Logical calculus of the ideas imminent in nervous activity" data-secondary="A (McCulloch/Pitts)"">&nbsp;</a></p>

<p><a data-type="indexterm" data-primary=""McCulloch" data-secondary="Warren S."">&nbsp;</a>
<a data-type="indexterm" data-primary=""Pitts" data-secondary="Walter"">&nbsp;</a></p>

<p>Computer scientists have long been inspired by the human brain.   In 1943, Warren S. McCulloch, a neuroscientist, and Walter Pitts, a logician, developed the first conceptual model of an artificial neural network.  In their paper, "A logical calculus of the ideas imminent in nervous activity,” they describe the concept of a neuron, a single cell living in a network of cells that receives inputs, processes those inputs, and generates an output.</p>

<p>Their work, and the work of many scientists and researchers that followed, was not meant to accurately describe how the biological brain works.  Rather, an artificial neural network (which we will now simply refer to as a “neural network”) was designed as a computational model based on the brain to solve certain kinds of problems.</p>

<p>It’s probably pretty obvious to you that there are problems that are incredibly simple for a computer to solve, but difficult for you.  Take the square root of 964,324, for example.  A quick line of code produces the value 982, a number Processing computed in less than a millisecond.   There are, on the other hand, problems that are incredibly simple for you or me to solve, but not so easy for a computer.   Show any toddler a picture of a kitten or puppy and they’ll be able to tell you very quickly which one is which.   Say hello and shake my hand one morning and you should be able to pick me out of a crowd of people the next day.  But need a machine to perform one of these tasks?  Scientists have already spent entire careers researching and implementing complex solutions.</p>

<p><a data-type="indexterm" data-primary=""<em>AI for Game Developers</em> (Bourg/Seemann)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""<em>Artificial Intelligence: A Modern Approach</em> (Russell/Norvig)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""artificial intelligence"" data-secondary=""pattern recognition"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Bourg" data-secondary="David M."">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""pattern recognition"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Norvig" data-secondary="Peter"">&nbsp;</a>
<a data-type="indexterm" data-primary=""pattern recognition"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Russell" data-secondary="Stuart J."">&nbsp;</a>
<a data-type="indexterm" data-primary=""Seemann" data-secondary="Glenn"">&nbsp;</a></p>

<p>The most common application of neural networks in computing today is to perform one of these “easy-for-a-human, difficult-for-a-machine” tasks, often referred to as pattern recognition.   Applications range from optical character recognition (turning printed or handwritten scans into digital text) to facial recognition.  We don’t have the time or need to use some of these more elaborate artificial intelligence algorithms here, but if you are interested in researching neural networks, I’d recommend the books <em>Artificial Intelligence: A Modern Approach</em> by Stuart J. Russell and Peter Norvig and <em>AI for Game Developers</em> by David M. Bourg and Glenn Seemann.</p>

<figure id="chapter10_figure2" class="half-width-right">
<img src="imgs/chapter10/ch10_02.png" alt="Figure 10.2"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""complex systems"" data-secondary=""connectionist computational system"">&nbsp;</a>
<a data-type="indexterm" data-primary=""connectionist computational system"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""connectionist computational system"">&nbsp;</a></p>

<p>A neural network is a “connectionist” computational system.   The computational systems we write are procedural; a program starts at the first line of code, executes it, and goes on to the next, following instructions in a linear fashion.   A true neural network does not follow a linear path.  Rather, information is processed collectively, in parallel throughout a network of nodes (the nodes, in this case, being neurons).</p>

<p>Here we have yet another example of a complex system, much like the ones we examined in Chapters 6, 7, and 8.   The individual elements of the network, the neurons, are simple.  They read an input, process it, and generate an output.   A network of many neurons, however, can exhibit incredibly rich and intelligent behaviors.</p>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""learning and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""weight"" data-secondary=""neural networks and"">&nbsp;</a></p>

<p>One of the key elements of a neural network is its ability to <em>learn</em>.  A neural network is not just a complex system, but a complex <strong><em>adaptive</em></strong> system, meaning it can change its internal structure based on the information flowing through it.  Typically, this is achieved through the adjusting of <em>weights</em>.  In the diagram above, each line represents a connection between two neurons and indicates the pathway for the flow of information.    Each connection has a <strong><em>weight</em></strong>, a number that controls the signal between the two neurons.   If the network generates a “good” output (which we’ll define later), there is no need to adjust the weights. However, if the network generates a “poor” output—an error, so to speak—then the system adapts, altering the weights in order to improve subsequent results.</p>

<p>There are several strategies for learning, and we’ll examine two of them in this chapter.</p>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""supervised learning"">&nbsp;</a>
<a data-type="indexterm" data-primary=""supervised learning (neural networks)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Supervised Learning</em></strong> —Essentially, a strategy that involves a teacher that is smarter than the network itself.  For example, let’s take the facial recognition example.  The teacher shows the network a bunch of faces, and the teacher already knows the name associated with each face.  The network makes its guesses, then the teacher provides the network with the answers.   The network can then compare its answers to the known “correct” ones and make adjustments according to its errors.  Our first neural network in the next section will follow this model.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""unsupervised learning"">&nbsp;</a>
<a data-type="indexterm" data-primary=""unsupervised learning (neural networks)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Unsupervised Learning</em></strong> —Required when there isn’t an example data set with known answers.    Imagine searching for a hidden pattern in a data set.   An application of this is clustering, i.e. dividing a set of elements into groups according to some unknown pattern.   We won’t be looking at any examples of unsupervised learning in this chapter, as this strategy is less relevant for our examples.</p></li>
</ul>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""reinforcement learning"">&nbsp;</a>
<a data-type="indexterm" data-primary=""reinforcement learning (neural networks)"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Reinforcement Learning</em></strong> —A strategy built on observation.   Think of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.)   Presumably, the mouse will learn over time to turn left.  Its neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch).   If the observation is negative, the network can adjust its weights in order to make a different decision the next time.    Reinforcement learning is common in robotics.  At time <strong var>t</strong>, the robot performs a task and observes the results.   Did it crash into a wall or fall off a table?  Or is it unharmed?  We’ll look at reinforcement learning in the context of our simulated steering vehicles.</p></li>
</ul>

<p>This ability of a neural network to learn, to make adjustments to its structure over time, is what makes it so useful in the field of artificial intelligence.  Here are some standard uses of neural networks in software today.</p>

<p><a data-type="indexterm" data-primary=""anomaly detection"">&nbsp;</a>
<a data-type="indexterm" data-primary=""control (of physical objects)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""uses of"">&nbsp;</a>
<a data-type="indexterm" data-primary=""signal processing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""soft sensors"">&nbsp;</a>
<a data-type="indexterm" data-primary=""time series prediction"">&nbsp;</a></p>

<ul>
<li>
<p><strong><em>Pattern Recognition</em></strong> —We’ve mentioned this several times already and it’s probably the most common application.   Examples are facial recognition, optical character recognition, etc.</p></li>
<li>
<p><strong><em>Time Series Prediction</em></strong> —Neural networks can be used to make predictions.  Will the stock rise or fall tomorrow?  Will it rain or be sunny?</p></li>
<li>
<p><strong><em>Signal Processing</em></strong> —Cochlear implants and hearing aids need to filter out unnecessary noise and amplify the important sounds.   Neural networks can be trained to process an audio signal and filter it appropriately.</p></li>
<li>
<p><strong><em>Control</em></strong> —You may have read about recent research advances in self-driving cars.   Neural networks are often used to manage steering decisions of physical vehicles (or simulated ones).</p></li>
<li>
<p><strong><em>Soft Sensors</em></strong> —A soft sensor refers to the process of analyzing a collection of many measurements.   A thermometer can tell you the temperature of the air, but what if you also knew the humidity, barometric pressure, dewpoint, air quality, air density, etc.?  Neural networks can be employed to process the input data from many individual sensors and evaluate them as a whole.</p></li>
<li>
<p><strong><em>Anomaly Detection</em></strong> —Because neural networks are so good at recognizing patterns, they can also be trained to generate an output when something occurs that doesn’t fit the pattern.  Think of a neural network monitoring your daily routine over a long period of time.  After learning the patterns of your behavior, it could alert you when something is amiss.</p></li>
</ul>

<p>This is by no means a comprehensive list of applications of neural networks.   But hopefully it gives you an overall sense of the features and possibilities.   The thing is, neural networks are complicated and difficult.  They involve all sorts of fancy mathematics.   While this is all fascinating (and incredibly important to scientific research), a lot of the techniques are not very practical in the world of building interactive, animated Processing sketches.   Not to mention that in order to cover all this material, we would need another book—or more likely, a series of books.</p>

<p>So instead, we’ll begin our last hurrah in the nature of code with the simplest of all neural networks, in an effort to understand how the overall concepts are applied in code.  Then we’ll look at some Processing sketches that generate visual results inspired by these concepts.</p>
</section>







<section data-type="sect1" id="chapter10_section2">
<h1>10.2  The Perceptron</h1>
<p><a data-type="indexterm" data-primary=""Cornell Aeronautical Laboratory"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""perceptron"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""implementing"">&nbsp;</a>
<a data-type="indexterm" data-primary=""Rosenblatt" data-secondary="Frank"">&nbsp;</a></p>

<p>Invented in 1957 by Frank Rosenblatt at the Cornell Aeronautical Laboratory, a perceptron is the simplest neural network possible: a computational model of a single neuron. A perceptron consists of one or more inputs, a processor, and a single output.</p>

<figure id="chapter10_figure3">
<img src="imgs/chapter10/ch10_03.png" alt="Figure 10.3: The perceptron"/>
<figcaption/>
</figure>
<p><a data-type="indexterm" data-primary=""feed-forward model (neural networks)"">&nbsp;</a></p>

<p>A perceptron follows the “feed-forward” model, meaning inputs are sent into the neuron, are processed, and result in an output.  In the diagram above, this means the network (one neuron) reads from left to right: inputs come in, output goes out.</p>

<p>Let’s follow each of these steps in more detail.</p>

<p><strong highlight>Step 1: Receive inputs.</strong></p>

<p>Say we have a perceptron with two inputs—let’s call them <em>x1</em> and <em>x2</em>.</p>

<p><strong mono>Input 0:  	x1 = 12<br/>
Input 1: 	x2 = 4</strong></p>

<p><strong highlight>Step 2: Weight inputs.</strong></p>

<p>Each input that is sent into the neuron must first be weighted, i.e. multiplied by some value (often a number between -1 and 1).   When creating a perceptron, we’ll typically begin by assigning random weights.  Here, let’s give the inputs the following weights:</p>

<p><strong mono>Weight 0: 0.5<br/>
Weight 1: -1</strong></p>

<p>We take each input and multiply it by its weight.</p>

<p><strong mono>Input 0 <code>*</code> Weight 0 &#8658; 12 <code>*</code> 0.5 = 6</strong></p>

<p><strong mono>Input 1 <code>*</code> Weight 1 &#8658; 4 <code>*</code> -1 = -4</strong></p>

<p><strong highlight>Step 3: Sum inputs.</strong></p>

<p>The weighted inputs are then summed.</p>

<p><strong mono>Sum = 6 + -4 = 2</strong></p>

<p><strong highlight>Step 4: Generate output.</strong></p>

<p><a data-type="indexterm" data-primary=""activation functions of neural networks"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""activation functions of"">&nbsp;</a></p>

<p>The output of a perceptron is generated by passing that sum through an activation function.    In the case of a simple binary output, the activation function is what tells the perceptron whether to “fire” or not.   You can envision an LED connected to the output signal: if it fires, the light goes on; if not, it stays off.</p>

<p>Activation functions can get a little bit hairy.   If you start reading one of those artificial intelligence textbooks looking for more info about activation functions, you may soon find yourself reaching for a calculus textbook.    However, with our friend the simple perceptron, we’re going to do something really easy.  Let’s make the activation function the sign of the sum.   In other words, if the sum is a positive number, the output is 1; if it is negative, the output is -1.</p>

<p><strong mono>Output = sign(sum) &#8658; sign(2) &#8658; +1</strong></p>

<p>Let’s review and condense these steps so we can implement them with a code snippet.</p>

<p><strong><em>The Perceptron Algorithm:</em></strong></p>

<ol>
<li>
<p>For every input, multiply that input by its weight.</p></li>
<li>
<p>Sum all of the weighted inputs.</p></li>
<li>
<p>Compute the output of the perceptron based on that sum passed through an activation function (the sign of the sum).</p></li>
</ol>

<p>Let’s assume we have two arrays of numbers, the inputs and the weights.   For example:</p>

<pre data-type="programlisting" data-code-language="java">float[] inputs  = {12 , 4};
float[] weights = {0.5,-1};</pre>

<p>“For every input” implies a loop that multiplies each input by its corresponding weight.  Since we need the sum, we can add up the results in that very loop.</p>

<pre data-type="programlisting" data-code-language="java">//[full] Steps 1 and 2: Add up all the weighted inputs.
float sum = 0;
for (int i = 0; i &lt; inputs.length; i++) {
  sum += inputs[i]*weights[i];
}
//[end]</pre>

<p>Once we have the sum we can compute the output.</p>

<pre data-type="programlisting" data-code-language="java">// Step 3: Passing the sum
// through an activation function
float output = activate(sum);

// The activation function
int activate(float sum) {
  //[full] Return a 1 if positive, -1 if negative.
  if (sum &gt; 0) return 1;
  else return -1;
  //[end]
}</pre>
</section>







<section data-type="sect1" id="chapter10_section3">
<h1>10.3  Simple Pattern Recognition Using a Perceptron</h1>
<p><a data-type="indexterm" data-primary=""bias input" data-secondary="perceptron"">&nbsp;</a>
<a data-type="indexterm" data-primary=""pattern recognition"" data-secondary=""perceptron and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""bias input"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""error calculations and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""pattern recognition with"">&nbsp;</a></p>

<p>Now that we understand the computational process of a perceptron, we can look at an example of one in action.   We stated that neural networks are often used for pattern recognition applications, such as facial recognition.   Even simple perceptrons can demonstrate the basics of classification, as in the following example.</p>

<figure id="chapter10_figure4" class="half-width-right">
<img src="imgs/chapter10/ch10_04.png" alt="Figure 10.4"/>
<figcaption/>
</figure>
<p>Consider a line in two-dimensional space. Points in that space can be classified as living on either one side of the line or the other. While this is a somewhat silly example (since there is clearly no need for a neural network; we can determine on which side a point lies with some simple algebra), it shows how a perceptron can be trained to recognize points on one side versus another.</p>

<p>Let’s say a perceptron has 2 inputs (the x- and y-coordinates of a point). Using a sign activation function, the output will either be  -1 or 1—i.e., the input data is classified according to the sign of the output.  In the above diagram, we can see how each point is either below the line (-1) or above (+1).</p>

<p>The perceptron itself can be diagrammed as follows:</p>

<figure id="chapter10_figure5">
<img src="imgs/chapter10/ch10_05.png" alt="Figure 10.5"/>
<figcaption/>
</figure>
<p>We can see how there are two inputs (<em>x</em> and <em>y</em>), a weight for each input (<em>weight<sub>x</sub></em> and <em>weight<sub>y</sub></em>), as well as a processing neuron that generates the output.</p>

<p>There is a pretty significant problem here, however.  Let’s consider the point (0,0).  What if we send this point into the perceptron as its input:  x = 0 and y = 0?  What will the sum of its weighted inputs be?  No matter what the weights are, the sum will always be 0!  But this can’t be right—after all, the point (0,0) could certainly be above or below various lines in our two-dimensional world.</p>

<p>To avoid this dilemma, our perceptron will require a third input, typically referred to as a <strong><em>bias</em></strong> input.   A bias input always has the value of 1 and is also weighted.  Here is our perceptron with the addition of the bias:</p>

<figure id="chapter10_figure6">
<img src="imgs/chapter10/ch10_06.png" alt="Figure 10.6"/>
<figcaption/>
</figure>
<p>Let’s go back to the point (0,0).   Here are our inputs:</p>

<p><strong mono>0 <code>*</code> weight for x = 0<br/>
0 <code>*</code> weight for y = 0<br/>
1 <code>*</code> weight for bias = weight for bias</strong></p>

<p>The output is the sum of the above three values, 0 plus 0 plus the bias’s weight.  Therefore, the bias, on its own, answers the question as to where (0,0) is in relation to the line.  If the bias’s weight is positive, (0,0) is above the line; negative, it is below.   It “biases” the perceptron’s understanding of the line’s position relative to (0,0).</p>
</section>







<section data-type="sect1" id="chapter10_section4">
<h1>10.4  Coding the Perceptron</h1>
<p>We’re now ready to assemble the code for a <strong klass>Perceptron</strong> class.  The only data the perceptron needs to track are the input weights, and we could use an array of floats to store these.</p>

<pre data-type="programlisting" data-code-language="java">class Perceptron {
  float[] weights;</pre>

<p>The constructor could receive an argument indicating the number of inputs (in this case three: x, y, and a bias) and size the array accordingly.</p>

<pre data-type="programlisting" data-code-language="java">  Perceptron(int n) {
    weights = new float[n];
    for (int i = 0; i &lt; weights.length; i++) {
      // The weights are picked randomly to start.
      weights[i] = random(-1,1);
    }
  }</pre>

<p>A perceptron needs to be able to receive inputs and generate an output.  We can package these requirements into a function called <strong function>feedforward()</strong>.   In this example, we’ll have the perceptron receive its inputs as an array (which should be the same length as the array of weights) and return the output as an integer.</p>

<pre data-type="programlisting" data-code-language="java">  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i &lt; weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    // Result is the sign of the sum, -1 or +1.
    // Here the perceptron is making a guess.
    // Is it on one side of the line or the other?
    return activate(sum);
  }</pre>

<p>Presumably, we could now create a <strong klass>Perceptron</strong> object and ask it to make a guess for any given point.</p>

<figure id="chapter10_figure7">
<img src="imgs/chapter10/ch10_07.png" alt="Figure 10.7"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">// Create the Perceptron.
Perceptron p = new Perceptron(3);
// The input is 3 values: x,y and bias.
float[] point = {50,-12,1};
// The answer!
int result = p.feedforward(point);</pre>

<p>Did the perceptron get it right?    At this point, the perceptron has no better than a 50/50 chance of arriving at the right answer.  Remember, when we created it, we gave each weight a random value.    A neural network isn’t magic.   It’s not going to be able to guess anything correctly unless we teach it how to!</p>

<p>To train a neural network to answer correctly, we’re going to employ the method of <em>supervised learning</em> that we described in <a href="#chapter10_section1">section 10.1</a>.</p>

<p>With this method, the network is provided with inputs for which there is a known answer.  This way the network can find out if it has made a correct guess.  If it’s incorrect, the network can learn from its mistake and adjust its weights.  The process is as follows:</p>

<ol>
<li>
<p>Provide the perceptron with inputs for which there is a known answer.</p></li>
<li>
<p>Ask the perceptron to guess an answer.</p></li>
<li>
<p>Compute the error.  (Did it get the answer right or wrong?)</p></li>
<li>
<p>Adjust all the weights according to the error.</p></li>
<li>
<p>Return to Step 1 and repeat!</p></li>
</ol>

<p>Steps 1 through 4 can be packaged into a function.  Before we can write the entire function, however, we need to examine Steps 3 and 4 in more detail.  How do we define the perceptron’s error?  And how should we adjust the weights according to this error?</p>

<p>The perceptron’s error can be defined as the difference between the desired answer and its guess.</p>

<p><strong formula>ERROR = DESIRED OUTPUT - GUESS OUTPUT</strong></p>

<p>The above formula may look familiar to you.  In <a href="#chapter06_section3">Chapter 6</a>, we computed a steering force as the difference between our desired velocity and our current velocity.</p>

<p><strong formula>STEERING = DESIRED VELOCITY - CURRENT VELOCITY</strong></p>

<p>This was also an error calculation.  The current velocity acts as a guess and the error (the steering force) tells us how to adjust the velocity in the right direction.   In a moment, we’ll see how adjusting the vehicle’s velocity to follow a target is just like adjusting the weights of a neural network to arrive at the right answer.</p>

<p>In the case of the perceptron, the output has only two possible values: <strong><em>+1</em></strong> or <strong><em>-1</em></strong>.   This means there are only three possible errors.</p>

<p>If the perceptron guesses the correct answer, then the guess equals the desired output and the error is 0.  If the correct answer is -1 and we’ve guessed +1, then the error is -2.  If the correct answer is +1 and we’ve guessed -1, then the error is +2.</p>

<table>

<thead>
<tr>
<th>Desired</th>
<th>Guess</th>
<th>Error</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>-1</p></td>
<td><p>-1</p></td>
<td><p>0</p></td>
</tr>
<tr>
<td><p>-1</p></td>
<td><p>+1</p></td>
<td><p>-2</p></td>
</tr>
<tr>
<td><p>+1</p></td>
<td><p>-1</p></td>
<td><p>+2</p></td>
</tr>
<tr>
<td><p>+1</p></td>
<td><p>+1</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>

<p><a data-type="indexterm" data-primary=""delta weight"">&nbsp;</a></p>

<p>The error is the determining factor in how the perceptron’s weights should be adjusted.   For any given weight, what we are looking to calculate is the change in weight, often called <em>Δweight</em> (or “delta” weight, delta being the Greek letter Δ).</p>

<p><strong formula>NEW WEIGHT = WEIGHT + ΔWEIGHT</strong></p>

<p>Δweight is calculated as the error multiplied by the input.</p>

<p><strong formula>ΔWEIGHT = ERROR <code>*</code> INPUT</strong></p>

<p>Therefore:</p>

<p><strong formula>NEW WEIGHT = WEIGHT + ERROR <code>*</code> INPUT</strong></p>

<p>To understand why this works, we can again return to <a href="#chapter06_section3">steering</a>.  A steering force is essentially an error in velocity.  If we apply that force as our acceleration (Δvelocity), then we adjust our velocity to move in the correct direction.  This is what we want to do with our neural network’s weights.  We want to adjust them in the right direction, as defined by the error.</p>

<p><a data-type="indexterm" data-primary=""learning constant"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""learning constant"">&nbsp;</a></p>

<p>With steering, however, we had an additional variable that controlled the vehicle’s ability to steer: the <em>maximum force</em>.   With a high maximum force, the vehicle was able to accelerate and turn very quickly; with a lower force, the vehicle would take longer to adjust its velocity.  The neural network will employ a similar strategy with a variable called the “learning constant.”  We’ll add in the learning constant as follows:</p>

<p><strong formula>NEW WEIGHT = WEIGHT + ERROR <code>*</code> INPUT <code>*</code> LEARNING CONSTANT</strong></p>

<p>Notice that a high learning constant means the weight will change more drastically.  This may help us arrive at a solution more quickly, but with such large changes in weight it’s possible we will overshoot the optimal weights.  With a small learning constant, the weights will be adjusted slowly, requiring more training time but allowing the network to make very small adjustments that could improve the network’s overall accuracy.</p>

<p>Assuming the addition of a variable <strong var>c</strong> for the learning constant, we can now write a training function for the perceptron following the above steps.</p>

<pre data-type="programlisting" data-code-language="java">// A new variable is introduced
// to control the learning rate.
float c = 0.01;

// Step 1: Provide the inputs and known answer.
// These are passed in as arguments to train().
void train(float[] inputs, int desired) {

  // Step 2: Guess according to those inputs.
  int guess = feedforward(inputs);

  // Step 3: Compute the error (difference
  // between answer and guess).
  float error = desired - guess;

  //[full] Step 4: Adjust all the weights according
  // to the error and learning constant.
  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c * error * inputs[i];
  }
  //[end]
}</pre>

<p>We can now see the <strong klass>Perceptron</strong> class as a whole.</p>

<pre data-type="programlisting" data-code-language="java">class Perceptron {
  //[full] The Perceptron stores its weights and learning constants.
  float[] weights;
  float c = 0.01;
  //[end]

  Perceptron(int n) {
    weights = new float[n];
    //[full] Weights start off random.
    for (int i = 0; i &lt; weights.length; i++) {
      weights[i] = random(-1,1);
    }
    //[end]
  }

  //[full] Return an output based on inputs.
  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i &lt; weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    return activate(sum);
  }
  //[end]

  //[full] Output is a +1 or -1.
  int activate(float sum) {
    if (sum &gt; 0) return 1;
    else return -1;
  }
  //[end]

  //[full] Train the network against known data.
  void train(float[] inputs, int desired) {
    int guess = feedforward(inputs);
    float error = desired - guess;
    for (int i = 0; i &lt; weights.length; i++) {
      weights[i] += c * error * inputs[i];
    }
  }
  //[end]
}</pre>

<p><a data-type="indexterm" data-primary=""perceptron"" data-secondary=""training"">&nbsp;</a></p>

<p>To train the perceptron, we need a set of inputs with a known answer.   We could package this up in a class like so:</p>

<pre data-type="programlisting" data-code-language="java">class Trainer {

  // A "Trainer" object stores the inputs and the correct answer.
  float[] inputs;
  int answer;

  Trainer(float x, float y, int a) {
    inputs = new float[3];
    inputs[0] = x;
    inputs[1] = y;
    // Note that the Trainer has the bias input built into its array.
    inputs[2] = 1;
    answer = a;
  }
}</pre>

<p>Now the question becomes, how do we pick a point and know whether it is above or below a line?   Let’s start with the formula for a line, where <strong var>y</strong> is calculated as a function of <strong var>x</strong>:</p>

<p><strong formula>y = f(x)</strong></p>

<p>In generic terms, a line can be described as:</p>

<p><strong formula>y = ax + b</strong></p>

<p>Here’s a specific example:</p>

<p><strong formula>y = 2*x + 1</strong></p>

<p>We can then write a Processing function with this in mind.</p>

<pre data-type="programlisting" data-code-language="java">//[full] A function to calculate y based on x along a line
float f(float x) {
  return 2*x+1;
}
//[end]</pre>

<p>So, if we make up a point:</p>

<pre data-type="programlisting" data-code-language="java">float x = random(width);
float y = random(height);</pre>

<p>How do we know if this point is above or below the line?   The line function <strong function>f(x)</strong> gives us the <strong var>y</strong> value on the line for that <strong var>x</strong> position.  Let’s call that <strong var>yline</strong>.</p>

<pre data-type="programlisting" data-code-language="java">// The y position on the line
float yline = f(x);</pre>

<p>If the <strong var>y</strong> value we are examining is above the line, it will be less than <strong var>yline</strong>.</p>

<figure id="chapter10_figure8">
<img src="imgs/chapter10/ch10_08.png" alt="Figure 10.8"/>
<figcaption/>
</figure>
<pre data-type="programlisting" data-code-language="java">if (y &lt; yline) {
  // The answer is -1 if y is above the line.
  answer = -1;
} else {
  answer = 1;
}</pre>

<p>We can then make a <strong klass>Trainer</strong> object with the inputs and the correct answer.</p>

<pre data-type="programlisting" data-code-language="java">Trainer t = new Trainer(x, y, answer);</pre>

<p>Assuming we had a <strong klass>Perceptron</strong> object <strong var>ptron</strong>, we could then train it by sending the inputs along with the known answer.</p>

<pre data-type="programlisting" data-code-language="java">ptron.train(t.inputs,t.answer);</pre>

<p>Now, it’s important to remember that this is just a demonstration.  Remember our <a href="#chapter09_section2">Shakespeare-typing monkeys</a>?  We asked our genetic algorithm to solve for “to be or not to be”—an answer we already knew.  We did this to make sure our genetic algorithm worked properly.  The same reasoning applies to this example.  We don’t need a perceptron to tell us whether a point is above or below a line; we can do that with simple math.   We are using this scenario, one that we can easily solve without a perceptron, to demonstrate the perceptron’s algorithm as well as easily confirm that it is working properly.</p>

<p>Let’s look at how the perceptron works with an array of many training points.</p>

<figure class="screenshot" data-pde="processingjs/chapter10/_10_01_SimplePerceptron/_10_01_SimplePerceptron.pde processingjs/chapter10/_10_01_SimplePerceptron/Perceptron.pde processingjs/chapter10/_10_01_SimplePerceptron/Trainer.pde">
<img src="imgs/chapter10/ch10_ex01.png" alt="ch10 ex01"/>
<figcaption/>
</figure>
<p><strong example>Example 10.1: The Perceptron</strong></p>

<pre data-type="programlisting" data-code-language="java">// The Perceptron
Perceptron ptron;
// 2,000 training points
Trainer[] training = new Trainer[2000];
int count = 0;

//[full] The formula for a line
float f(float x) {
  return 2*x+1;
}
//[end]

void setup() {
  size(640, 360);

  ptron = new Perceptron(3);

  // Make 2,000 training points.
  for (int i = 0; i &lt; training.length; i++) {
    float x = random(-width/2,width/2);
    float y = random(-height/2,height/2);
    //[full] Is the correct answer 1 or -1?
    int answer = 1;
    if (y &lt; f(x)) answer = -1;
    //[end]
    training[i] = new Trainer(x, y, answer);
  }
}


void draw() {
  background(255);
  translate(width/2,height/2);

  ptron.train(training[count].inputs, training[count].answer);
  // For animation, we are training one point at a time.
  count = (count + 1) % training.length;

  for (int i = 0; i &lt; count; i++) {
    stroke(0);
    int guess = ptron.feedforward(training[i].inputs);
    //[full] Show the classification—no fill for -1, black for +1.
    if (guess &gt; 0) noFill();
    else           fill(0);
    //[end]
    ellipse(training[i].inputs[0], training[i].inputs[1], 8, 8);
  }
}</pre>

<div id="chapter10_exercise1" data-type="example">
<h5>Exercise 10.1</h5>
<p>Instead of using the supervised learning model above, can you train the neural network to find the right weights by using a genetic algorithm?</p>
</div>

<div id="chapter10_exercise2" data-type="example">
<h5>Exercise 10.2</h5>
<p>Visualize the perceptron itself. Draw the inputs, the processing node, and the output.</p>
</div>
</section>







<section data-type="sect1" id="chapter10_section5">
<h1>10.5  A Steering Perceptron</h1>
<p><a data-type="indexterm" data-primary=""perceptron"" data-secondary=""steering and"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering behaviors"" data-secondary=""perceptron for"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering perceptron"">&nbsp;</a></p>

<p>While classifying points according to their position above or below a line was a useful demonstration of the perceptron in action, it doesn’t have much practical relevance to the other examples throughout this book.  In this section, we’ll take the concepts of a perceptron (array of inputs, single output), apply it to steering behaviors, and demonstrate reinforcement learning along the way.</p>

<p>We are now going to take significant creative license with the concept of a neural network. This will allow us to stick with the basics and avoid some of the highly complex algorithms associated with more sophisticated neural networks.   Here we’re not so concerned with following rules outlined in artificial intelligence textbooks—we’re just hoping to make something interesting and brain-like.</p>

<p>Remember our good friend the <strong klass>Vehicle</strong> class?  You know, that one for making objects with a location, velocity, and acceleration?  That could obey Newton’s laws with an <strong function>applyForce()</strong> function and move around the window according to a variety of steering rules?</p>

<p>What if we added one more variable to our <strong klass>Vehicle</strong> class?</p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {

  // Giving the vehicle a brain!
  Perceptron brain;

  PVector location;
  PVector velocity;
  PVector acceleration;
  [inline]//etc...</pre>

<p>Here’s our scenario.  Let’s say we have a Processing sketch with an <strong klass>ArrayList</strong> of targets and a single vehicle.</p>

<figure id="chapter10_figure09">
<img src="imgs/chapter10/ch10_09.png" alt="Figure 10.9"/>
<figcaption/>
</figure>
<p>Let’s say that the vehicle seeks all of the targets.   According to the principles of Chapter 6, we would next write a function that calculates a steering force towards each target, applying each force one at a time to the object’s acceleration.   Assuming the targets are an <strong klass>ArrayList</strong> of <strong klass>PVector</strong> objects, it would look something like:</p>

<pre data-type="programlisting" data-code-language="java">  void seek(ArrayList&lt;PVector&gt; targets) {
    for (PVector target : targets) {
      // For every target, apply a steering force towards the target.
      PVector force = seek(targets.get(i));
      applyForce(force);
    }
  }</pre>

<p>In Chapter 6, we also examined how we could create more dynamic simulations by weighting each steering force according to some rule.  For example, we could say that the farther you are from a target, the stronger the force.</p>

<pre data-type="programlisting" data-code-language="java"> void seek(ArrayList&lt;PVector&gt; targets) {
    for (PVector target : targets) {
      PVector force = seek(targets.get(i));
      float d = PVector.dist(target,location);
      float weight = map(d,0,width,0,5);
      // Weighting each steering force individually
      force.mult(weight);
      applyForce(force);
    }
  }</pre>

<p>But what if instead we could ask our brain (i.e. perceptron) to take in all the forces as an input, process them according to weights of the perceptron inputs, and generate an output steering force?   What if we could instead say:</p>

<pre data-type="programlisting" data-code-language="java">  void seek(ArrayList&lt;PVector&gt; targets) {

    // Make an array of inputs for our brain.
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i &lt; forces.length; i++) {
      // Fill the array with a steering force
      // for each target.
      forces[i] = seek(targets.get(i));
    }

    //[full] Ask our brain for a result and apply that as the force!
    PVector output = brain.process(forces);
    applyForce(output);
    //[end]
  }</pre>

<p>In other words, instead of weighting and accumulating the forces inside our vehicle, we simply pass an array of forces to the vehicle’s “brain” object and allow the brain to weight and sum the forces for us.  The output is then applied as a steering force.  This opens up a range of possibilities. A vehicle could make decisions as to how to steer on its own, learning from its mistakes and responding to stimuli in its environment.  Let’s see how this works.</p>

<p>We can use the line classification perceptron as a model, with one important difference—the inputs are not single numbers, but vectors!     Let’s look at how the <strong function>feedforward()</strong> function works in our vehicle’s perceptron, alongside the one from our previous example.</p>

<table class="codewide">
<tr>
<th>Vehicle PVector inputs</th>
<th>Line float inputs</th>
</tr>
<tr>
<td>
<pre>
PVector feedforward(PVector[] forces) {
  // Sum is a PVector.
  <b>PVector sum = new PVector();</b>
  for (int i = 0; i &lt; weights.length; i++) {
    // Vector addition and multiplication
    <b>forces[i].mult(weights[i]);</b>
    <b>sum.add(forces[i]);</b>
  }
  // No activation function
  <b>return sum;</b>
}
</pre>
</td>
<td>
<pre>
int feedforward(float[] inputs) {
  // Sum is a float.
  <b>float sum = 0;</b>
  for (int i = 0; i &lt; weights.length; i++) {
    // Scalar addition and multiplication
    <b>sum += inputs[i]*weights[i];</b>

  }
  // Activation function
  <b>return activate(sum);</b>
}
</pre>
</td>
</tr>

</table>
<p>Note how these two functions implement nearly identical algorithms, with two differences:</p>

<ol>
<li>
<p><strong><em>Summing PVectors.</em></strong>  Instead of a series of numbers added together, each input is a <strong klass>PVector</strong> and must be multiplied by the weight and added to a sum according to the mathematical <strong klass>PVector</strong> functions.</p></li>
<li>
<p><strong><em>No activation function.</em></strong>   In this case, we’re taking the result and applying it directly as a steering force for the vehicle, so we’re not asking for a simple boolean value that classifies it in one of two categories.  Rather, we’re asking for raw output itself, the resulting overall force.</p></li>
</ol>

<p><a data-type="indexterm" data-primary=""reinforcement learning(neural networks)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""steering perceptron"" data-secondary=""reinforcement learning(neural networks)"">&nbsp;</a></p>

<p>Once the resulting steering force has been applied, it’s time to give feedback to the brain, i.e. <em>reinforcement learning</em>.   Was the decision to steer in that particular direction a good one or a bad one?  Presumably if some of the targets were predators (resulting in being eaten) and some of the targets were food (resulting in greater health), the network would adjust its weights in order to steer away from the predators and towards the food.</p>

<p>Let’s take a simpler example, where the vehicle simply wants to stay close to the center of the window.    We’ll train the brain as follows:</p>

<pre data-type="programlisting" data-code-language="java">    PVector desired = new PVector(width/2,height/2);
    PVector error = PVector.sub(desired, location);
    brain.train(forces,error);</pre>

<figure id="chapter10_figure10" class="half-width-right">
<img src="imgs/chapter10/ch10_10.png" alt="Figure 10.10"/>
<figcaption/>
</figure>
<p>Here we are passing the brain a copy of all the inputs (which it will need for error correction) as well as an observation about its environment: a <strong klass>PVector</strong> that points from its current location to where it desires to be.  This <strong klass>PVector</strong> essentially serves as the error—the longer the <strong klass>PVector</strong>, the worse the vehicle is performing; the shorter, the better.</p>

<p>The brain can then apply this “error” vector (which has two error values, one for <strong var>x</strong> and one for <strong var>y</strong>) as a means for adjusting the weights, just as we did in the line classification example.</p>

<table class="codewide">
<tr>
<th>Training the Vehicle</th>
<th>Training the Line Classifier</th>
</tr>
<tr>
<td>
<pre>
void train(PVector[] forces, PVector error) {




  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c*error.x*forces[i].x;
    weights[i] += c*error.y*forces[i].y;
  }
}
</pre>
</td>
<td>
<pre>
void train(float[] inputs, int desired) {

  int guess = feedforward(inputs);
  float error = desired - guess;

  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c * error * inputs[i];

  }
}
</pre>
</td>
</tr>

</table>
<p>Because the vehicle observes its own error, there is no need to calculate one; we can simply receive the error as an argument.  Notice how the change in weight is processed twice, once for the error along the x-axis and once for the y-axis.</p>

<pre data-type="programlisting" data-code-language="java">weights[i] += c*error.x*forces[i].x;
weights[i] += c*error.y*forces[i].y;</pre>

<p>We can now look at the <strong klass>Vehicle</strong> class and see how the <strong function>steer</strong> function uses a perceptron to control the overall steering force.   The new content from this chapter is highlighted.</p>

<figure class="screenshot" data-pde="processingjs/chapter10/_10_02_SeekingNeural/_10_02_SeekingNeural.pde processingjs/chapter10/_10_02_SeekingNeural/Perceptron.pde processingjs/chapter10/_10_02_SeekingNeural/Vehicle.pde">
<img src="imgs/chapter10/ch10_ex02.png" alt="ch10 ex02"/>
<figcaption/>
</figure>
<p><strong example>Example 10.2: Perceptron steering</strong></p>

<pre data-type="programlisting" data-code-language="java">class Vehicle {

  // The Vehicle now has a brain.
  Perceptron brain; //[bold]

  //[full] Same old variables for physics
  PVector location;
  PVector velocity;
  PVector acceleration;
  float maxforce;
  float maxspeed;
  //[end]

  // The Vehicle creates a perceptron with n inputs and a learning constant.
  Vehicle(int n, float x, float y) {
    brain = new Perceptron(n,0.001); //[bold]
    acceleration = new PVector(0,0);
    velocity = new PVector(0,0);
    location = new PVector(x,y);
    maxspeed = 4;
    maxforce = 0.1;
  }

  //[full] Same old update() function
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0);
  }
  //[end]

  //[full] Same old applyForce() function
  void applyForce(PVector force) {
    acceleration.add(force);
  }
  //[end]

  void steer(ArrayList&lt;PVector&gt; targets) {
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i &lt; forces.length; i++) {
      forces[i] = seek(targets.get(i));
    }
    // All the steering forces are inputs.
    PVector result = brain.feedforward(forces); //[bold]

    // The result is applied.
    applyForce(result);

    //[offset-down] The brain is trained according to
    // the distance to the center.
    PVector desired = new PVector(width/2,height/2); //[bold]
    PVector error = PVector.sub(desired, location); //[bold]
    brain.train(forces,error); //[bold]

  }


  //[full] Same old seek() function
  PVector seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    return steer;
  }
  //[end]

}</pre>

<div id="chapter10_exercise3" data-type="example">
<h5>Exercise 10.3</h5>
<p>Visualize the weights of the network.  Try mapping each target’s corresponding weight to its brightness.</p>
</div>

<div id="chapter10_exercise4" data-type="example">
<h5>Exercise 10.4</h5>
<p>Try different rules for reinforcement learning.  What if some targets are desirable and some are undesirable?</p>
</div>
</section>







<section data-type="sect1" id="chapter10_section6">
<h1>10.6  It’s a “Network,” Remember?</h1>
<p><a data-type="indexterm" data-primary=""linearly separable problems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""linearly separable problems and"">&nbsp;</a></p>

<p>Yes, a perceptron can have multiple inputs, but it is still a lonely neuron.  The power of neural networks comes in the networking itself.   Perceptrons are, sadly, incredibly limited in their abilities.    If you read an AI textbook, it will say that a perceptron can only solve <strong><em>linearly separable</em></strong> problems.  What’s a linearly separable problem?  Let’s take a look at our first example, which determined whether points were on one side of a line or the other.</p>

<figure id="chapter10_figure11">
<img src="imgs/chapter10/ch10_11.png" alt="Figure 10.11"/>
<figcaption/>
</figure>
<p>On the left of Figure 10.11, we have classic linearly separable data.  Graph all of the possibilities; if you can classify the data with a straight line, then it is linearly separable.  On the right, however, is non-linearly separable data.  You can’t draw a straight line to separate the black dots from the gray ones.</p>

<p><a data-type="indexterm" data-primary=""exclusive or (XOR)"">&nbsp;</a>
<a data-type="indexterm" data-primary=""non-linearly separable problems"">&nbsp;</a>
<a data-type="indexterm" data-primary=""XOR (exclusive or)"">&nbsp;</a></p>

<p>One of the simplest examples of a non-linearly separable problem is <em>XOR</em>, or “exclusive or.”  We’re all familiar with <em>AND</em>.  For <em>A</em> <em>AND</em> <em>B</em> to be true, both <em>A</em> and <em>B</em> must be true.  With <em>OR</em>, either <em>A</em> or <em>B</em> can be true for <em>A</em> <em>OR</em> <em>B</em> to evaluate as true. These are both linearly separable problems.  Let’s look at the solution space, a “truth table.”</p>

<figure id="chapter10_figure12">
<img src="imgs/chapter10/ch10_12.png" alt="Figure 10.12"/>
<figcaption/>
</figure>
<p>See how you can draw a line to separate the true outputs from the false ones?</p>

<p><em>XOR</em> is the equivalent of <em>OR</em> and <em>NOT AND</em>.  In other words, <em>A</em> <em>XOR</em> <em>B</em> only evaluates to true if one of them is true.  If both are false or both are true, then we get false.  Take a look at the following truth table.</p>

<figure id="chapter10_figure13">
<img src="imgs/chapter10/ch10_13.png" alt="Figure 10.13"/>
<figcaption/>
</figure>
<p>This is not linearly separable.  Try to draw a straight line to separate the true outputs from the false ones—you can’t!</p>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""networks of perceptrons"">&nbsp;</a>
<a data-type="indexterm" data-primary=""perceptron"" data-secondary=""networks of"">&nbsp;</a></p>

<p>So perceptrons can’t even solve something as simple as <em>XOR</em>.  But what if we made a network out of two perceptrons?  If one perceptron can solve <em>OR</em> and one perceptron can solve <em>NOT AND</em>, then two perceptrons combined can solve <em>XOR</em>.</p>

<figure id="chapter10_figure14">
<img src="imgs/chapter10/ch10_14.png" alt="Figure 10.14"/>
<figcaption/>
</figure>
<p>The above diagram is known as a <em>multi-layered perceptron</em>, a network of many neurons.   Some are input neurons and receive the inputs, some are part of what’s called a “hidden” layer (as they are connected to neither the inputs nor the outputs of the network directly), and then there are the output neurons, from which we read the results.</p>

<p>Training these networks is much more complicated.  With the simple perceptron, we could easily evaluate how to change the weights according to the error. But here there are so many different connections, each in a different layer of the network. How does one know how much each neuron or connection contributed to the overall error of the network?</p>

<p><a data-type="indexterm" data-primary=""backpropagation"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""backpropagation"">&nbsp;</a></p>

<p>The solution to optimizing weights of a multi-layered network is known as <strong><em>backpropagation</em></strong>.  The output of the network is generated in the same manner as a perceptron.   The inputs multiplied by the weights are summed and fed forward through the network.  The difference here is that they pass through additional layers of neurons before reaching the output. Training the network (i.e. adjusting the weights) also involves taking the error (desired result - guess).  The error, however, must be fed backwards through the network. The final error ultimately adjusts the weights of all the connections.</p>

<p>Backpropagation is a bit beyond the scope of this book and involves a fancier activation function (called the sigmoid function) as well as some basic calculus.  If you are interested in how backpropagation works, check the book website (and GitHub repository) for an example that solves <em>XOR</em> using a multi-layered feed forward network with backpropagation.</p>

<p>Instead, here we’ll focus on a code framework for building the visual architecture of a network.  We’ll make <strong klass>Neuron</strong> objects and <strong klass>Connection</strong> objects from which a <strong klass>Network</strong> object can be created and animated to show the feed forward process.   This will closely resemble some of the force-directed graph examples we examined in Chapter 5 (toxiclibs).</p>
</section>







<section data-type="sect1" id="chapter10_section7">
<h1>10.7  Neural Network Diagrams</h1>
<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""diagramming"">&nbsp;</a></p>

<p>Our goal will be to create the following simple network diagram:</p>

<figure id="chapter10_figure15">
<img src="imgs/chapter10/ch10_15.png" alt="Figure 10.15"/>
<figcaption/>
</figure>
<p>The primary building block for this diagram is a neuron.  For the purpose of this example, the <strong klass>Neuron</strong> class describes an entity with an <em>(x,y)</em> location.</p>

<pre data-type="programlisting" data-code-language="java">// An incredibly simple Neuron class stores and displays the location of a single neuron.
class Neuron {
  PVector location;

  Neuron(float x, float y) {
    location = new PVector(x, y);
  }

  void display() {
    stroke(0);
    fill(0);
    ellipse(location.x, location.y, 16, 16);
  }
}</pre>

<p>The <strong klass>Network</strong> class can then manage an <strong klass>ArrayList</strong> of neurons, as well as have its own location (so that each neuron is drawn relative to the network’s center).  This is particle systems 101.  We have a single element (a neuron) and a network (a “system” of many neurons).</p>

<pre data-type="programlisting" data-code-language="java">//[full] A Network is a list of neurons.
class Network {
  ArrayList&lt;Neuron&gt; neurons;
  //[end]
  PVector location;

  Network(float x, float y) {
    location = new PVector(x,y);
    neurons = new ArrayList&lt;Neuron&gt;();
  }

  //[full] We can add a neuron to the network.
  void addNeuron(Neuron n) {
    neurons.add(n);
  }
  //[end]

  //[full] We can draw the entire network.
  void display() {
    pushMatrix();
    translate(location.x, location.y);
    for (Neuron n : neurons) {
      n.display();
    }
    popMatrix();
  }
  //[end]
}</pre>

<p>Now we can pretty easily make the diagram above.</p>

<pre data-type="programlisting" data-code-language="java">Network network;

void setup() {
  size(640, 360);
  // Make a Network.
  network = new Network(width/2,height/2);

  //[full] Make the Neurons.
  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);
  //[end]

  //[full] Add the Neurons to the network.
  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
  //[end]
}

void draw() {
  background(255);
  // Show the network.
  network.display();
}</pre>

<p>The above yields:</p>

<figure class="screenshot">
<img src="imgs/chapter10/ch10_ex03a.png" alt="ch10 ex03a"/>
<figcaption/>
</figure>
<p>What’s missing, of course, is the connection.   We can consider a <strong klass>Connection</strong> object to be made up of three elements, two neurons (from <strong klass>Neuron</strong> <strong var>a</strong> to <strong klass>Neuron</strong> <strong var>b</strong>) and a <strong var>weight</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Connection {
  //[full] A connection is between two neurons.
  Neuron a;
  Neuron b;
  //[end]
  // A connection has a weight.
  float weight;

  Connection(Neuron from, Neuron to,float w) {
    weight = w;
    a = from;
    b = to;
  }

  // A connection is drawn as a line.
  void display() {
    stroke(0);
    strokeWeight(weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);
  }
}</pre>

<p>Once we have the idea of a <strong klass>Connection</strong> object, we can write a function (let’s put it inside the <strong klass>Network</strong> class) that connects two neurons together—the goal being that in addition to making the neurons in <strong function>setup()</strong>, we can also connect them.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  size(640, 360);
  network = new Network(width/2,height/2);

  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);

  // Making connections between the neurons
  network.connect(a,b);
  network.connect(a,c);
  network.connect(b,d);
  network.connect(c,d);

  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
}</pre>

<p>The <strong klass>Network</strong> class therefore needs a new function called <strong function>connect()</strong>, which makes a <strong klass>Connection</strong> object between the two specified neurons.</p>

<pre data-type="programlisting" data-code-language="java">  void connect(Neuron a, Neuron b) {
    // Connection has a random weight.
    Connection c = new Connection(a, b, random(1));

    [inline]// But what do we do with the Connection object?
  }</pre>

<p>Presumably, we might think that the <strong klass>Network</strong> should store an <strong klass>ArrayList</strong> of connections, just like it stores an <strong klass>ArrayList</strong> of neurons.  While useful, in this case such an <strong klass>ArrayList</strong> is not necessary and is missing an important feature that we need.  Ultimately we plan to “feed forward" the neurons through the network, so the <strong klass>Neuron</strong> objects themselves must know to which neurons they are connected in the “forward” direction.  In other words, each neuron should have its own list of <strong klass>Connection</strong> objects.   When <strong var>a</strong> connects to <strong var>b</strong>, we want <strong var>a</strong> to store a reference of that connection so that it can pass its output to <strong var>b</strong> when the time comes.</p>

<pre data-type="programlisting" data-code-language="java">  void connect(Neuron a, Neuron b) {
    Connection c = new Connection(a, b, random(1));
    a.addConnection(c);
  }</pre>

<p>In some cases, we also might want <strong klass>Neuron</strong> <strong var>b</strong> to know about this connection, but in this particular example we are only going to pass information in one direction.</p>

<p>For this to work, we have to add an <strong klass>ArrayList</strong> of connections to the <strong klass>Neuron</strong> class. Then we implement the <strong function>addConnection()</strong> function that stores the connection in that <strong klass>ArrayList</strong>.</p>

<pre data-type="programlisting" data-code-language="java">class Neuron {
  PVector location;

  // The neuron stores its connections.
  ArrayList&lt;Connection&gt; connections;

  Neuron(float x, float y) {
    location = new PVector(x, y);
    connections = new ArrayList&lt;Connection&gt;();
  }

  //[full] Adding a connection to this neuron
  void addConnection(Connection c) {
    connections.add(c);
  }
  //[end]</pre>

<p>The neuron’s <strong function>display()</strong> function can draw the connections as well.  And finally, we have our network diagram.</p>

<figure class="screenshot" data-pde="processingjs/chapter10/_10_03_NetworkViz/_10_03_NetworkViz.pde processingjs/chapter10/_10_03_NetworkViz/Connection.pde processingjs/chapter10/_10_03_NetworkViz/Network.pde processingjs/chapter10/_10_03_NetworkViz/Neuron.pde">
<img src="imgs/chapter10/ch10_ex03.png" alt="ch10 ex03"/>
<figcaption/>
</figure>
<p><strong example>Example 10.3: Neural network diagram</strong></p>

<pre data-type="programlisting" data-code-language="java">  void display() {
    stroke(0);
    strokeWeight(1);
    fill(0);
    ellipse(location.x, location.y, 16, 16);

    //[full] Drawing all the connections
    for (Connection c : connections) {
      c.display();
    }
    //[end]
  }
}</pre>
</section>







<section data-type="sect1" id="chapter10_section8">
<h1>10.8  Animating Feed Forward</h1>
<p><a data-type="indexterm" data-primary=""feed-forward model (neural networks)"" data-secondary=""animating"">&nbsp;</a>
<a data-type="indexterm" data-primary=""neural networks"" data-secondary=""animating"">&nbsp;</a></p>

<p>An interesting problem to consider is how to visualize the flow of information as it travels throughout a neural network.    Our network is built on the feed forward model, meaning that an input arrives at the first neuron (drawn on the lefthand side of the window) and the output of that neuron flows across the connections to the right until it exits as output from the network itself.</p>

<p>Our first step is to add a function to the network to receive this input, which we’ll make a random number between 0 and 1.</p>

<pre data-type="programlisting" data-code-language="java">void setup() {
  // All our old network set up code


  // A new function to send in an input
  network.feedforward(random(1));
}</pre>

<p>The network, which manages all the neurons, can choose to which neurons it should apply that input.  In this case, we’ll do something simple and just feed a single input into the first neuron in the <strong klass>ArrayList</strong>, which happens to be the left-most one.</p>

<pre data-type="programlisting" data-code-language="java">class Network {

  //[full] A new function to feed an input into the neuron
  void feedforward(float input) {
    Neuron start = neurons.get(0);
    start.feedforward(input);
  }
  //[end]</pre>

<p>What did we do?  Well, we made it necessary to add a function called <strong function>feedforward()</strong> in the <strong klass>Neuron</strong> class that will receive the input and process it.</p>

<pre data-type="programlisting" data-code-language="java">class Neuron

  void feedforward(float input) {
     // What do we do with the input?

  }</pre>

<p>If you recall from working with our perceptron, the standard task that the processing unit performs is to sum up all of its inputs.  So if our <strong klass>Neuron</strong> class adds a variable called <strong var>sum</strong>, it can simply accumulate the inputs as they are received.</p>

<pre data-type="programlisting" data-code-language="java">class Neuron

  int sum = 0; //[bold]

  void feedforward(float input) {
    // Accumulate the sums.
    sum += input; //[bold]
  }</pre>

<p>The neuron can then decide whether it should “fire,” or pass an output through any of its connections to the next layer in the network.  Here we can create a really simple activation function: if the sum is greater than 1, fire!</p>

<pre data-type="programlisting" data-code-language="java"> void feedforward(float input) {
    sum += input;
    // Activate the neuron and fire the outputs?
    if (sum &gt; 1) {
      fire();
      // If we’ve fired off our output,
      // we can reset our sum to 0.
      sum = 0;
    }
  }</pre>

<p>Now, what do we do in the <strong function>fire()</strong> function?  If you recall, each neuron keeps track of its connections to other neurons.  So all we need to do is loop through those connections and <strong function>feedforward()</strong> the neuron’s output.  For this simple example, we’ll just take the neuron’s <strong var>sum</strong> variable and make it the output.</p>

<pre data-type="programlisting" data-code-language="java">  void fire() {
    for (Connection c : connections) {
      // The Neuron sends the sum out
      // through all of its connections
      c.feedforward(sum);
    }
  }</pre>

<p><a data-type="indexterm" data-primary=""neural networks"" data-secondary=""real vs. simulated"">&nbsp;</a></p>

<p>Here’s where things get a little tricky.  After all, our job here is not to actually make a functioning neural network, but to animate a simulation of one.  If the neural network were just continuing its work, it would instantly pass those inputs (multiplied by the connection’s weight) along to the connected neurons.  We’d say something like:</p>

<pre data-type="programlisting" data-code-language="java">class Connection {

  void feedforward(float val) {
    b.feedforward(val*weight);
  }</pre>

<p>But this is not what we want. What we want to do is draw something that we can see traveling along the connection from <strong klass>Neuron</strong> <strong var>a</strong> to <strong klass>Neuron</strong> <strong var>b</strong>.</p>

<p>Let’s first think about how we might do that. We know the location of <strong klass>Neuron</strong> <strong var>a</strong>; it’s the <strong klass>PVector</strong> <strong var>a.location</strong>.  <strong klass>Neuron</strong> <strong var>b</strong> is located at <strong var>b.location</strong>.  We need to start something moving from <strong klass>Neuron</strong> <strong var>a</strong> by creating another <strong klass>PVector</strong> that will store the path of our traveling data.</p>

<pre data-type="programlisting" data-code-language="java">  PVector sender = a.location.get();</pre>

<p>Once we have a copy of that location, we can use any of the motion algorithms that we’ve studied throughout this book to move along this path.  Here—let’s pick something very simple and just interpolate from <strong var>a</strong> to <strong var>b</strong>.</p>

<pre data-type="programlisting" data-code-language="java">  sender.x = lerp(sender.x, b.location.x, 0.1);
  sender.y = lerp(sender.y, b.location.y, 0.1);</pre>

<p>Along with the connection’s line, we can then draw a circle at that location:</p>

<pre data-type="programlisting" data-code-language="java">  stroke(0);
  line(a.location.x, a.location.y, b.location.x, b.location.y);
  fill(0);
  ellipse(sender.x, sender.y, 8, 8); //[bold]</pre>

<p>This resembles the following:</p>

<figure id="chapter10_figure16">
<img src="imgs/chapter10/ch10_16.png" alt="Figure 10.16"/>
<figcaption/>
</figure>
<p>OK, so that’s how we might move something along the connection.  But how do we know when to do so?   We start this process the moment the <strong klass>Connection</strong> object receives the “feedforward” signal.   We can keep track of this process by employing a simple <strong klass>boolean</strong> to know whether the connection is sending or not.    Before, we had:</p>

<pre data-type="programlisting" data-code-language="java">  void feedforward(float val) {
    b.feedforward(val*weight);
  }</pre>

<p>Now, instead of sending the value on straight away, we’ll trigger an animation:</p>

<pre data-type="programlisting" data-code-language="java">class Connection {

  boolean sending = false;
  PVector sender;
  float output;

  void feedforward(float val) {
    // Sending is now true.
    sending = true;
    // Start the animation at the location of Neuron A.
    sender = a.location.get();
    // Store the output for when it is actually time to feed it forward.
    output = val*weight;
  }</pre>

<p>Notice how our <strong klass>Connection</strong> class now needs three new variables.  We need a <strong klass>boolean</strong> “sending” that starts as false and that will track whether or not the connection is actively sending (i.e. animating).  We need a <strong klass>PVector</strong> “sender” for the location where we’ll draw the traveling dot.  And since we aren’t passing the output along this instant, we’ll need to store it in a variable that will do the job later.</p>

<p>The <strong function>feedforward()</strong> function is called the moment the connection becomes active.  Once it’s active, we’ll need to call another function continuously (each time through <strong function>draw()</strong>), one that will update the location of the traveling data.</p>

<pre data-type="programlisting" data-code-language="java"> void update() {
    if (sending) {
      //[full] As long as we’re sending, interpolate our points.
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
      //[end]
    }
  }</pre>

<p>We’re missing a key element, however.  We need to check if the sender has arrived at location b, and if it has, feed forward that output to the next neuron.</p>

<pre data-type="programlisting" data-code-language="java">  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);

      // How far are we from neuron b?
      float d = PVector.dist(sender, b.location); //[bold]

      // If we’re close enough (within one pixel) pass on the output. Turn off sending.
      if (d &lt; 1) { //[bold]
        b.feedforward(output); //[bold]
        sending = false; //[bold]
      }
    }
  }</pre>

<p>Let’s look at the <strong klass>Connection</strong> class all together, as well as our new <strong function>draw()</strong> function.</p>

<figure class="screenshot" data-pde="processingjs/chapter10/_10_04_NetworkAnimation/_10_04_NetworkAnimation.pde processingjs/chapter10/_10_04_NetworkAnimation/Connection.pde processingjs/chapter10/_10_04_NetworkAnimation/Network.pde processingjs/chapter10/_10_04_NetworkAnimation/Neuron.pde">
<img src="imgs/chapter10/ch10_ex04.png" alt="ch10 ex04"/>
<figcaption/>
</figure>
<p><strong example>Example 10.4: Animating a neural network diagram</strong></p>

<pre data-type="programlisting" data-code-language="java">void draw() {
  background(255);
  // The Network now has a new update() method that updates all of the Connection objects.
  network.update(); //[bold]
  network.display();

  if (frameCount % 30 == 0) { //[bold]
    // We are choosing to send in an input every 30 frames.
    network.feedforward(random(1)); //[bold]
  } //[bold]
}

class Connection {
  // The Connection’s data
  float weight;
  Neuron a;
  Neuron b;

  // Variables to track the animation
  boolean sending = false;
  PVector sender;
  float output = 0;

  Connection(Neuron from, Neuron to, float w) {
    weight = w;
    a = from;
    b = to;
  }

  // The Connection is active with data traveling from a to b.
  void feedforward(float val) {
    output = val*weight;
    sender = a.location.get();
    sending = true;
  }

  // Update the animation if it is sending.
  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
      float d = PVector.dist(sender, b.location);
      if (d &lt; 1) {
        b.feedforward(output);
        sending = false;
      }
    }
  }

  // Draw the connection as a line and traveling circle.
  void display() {
    stroke(0);
    strokeWeight(1+weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);

    if (sending) {
      fill(0);
      strokeWeight(1);
      ellipse(sender.x, sender.y, 16, 16);
    }
  }
}</pre>

<div id="chapter10_exercise5" data-type="example">
<h5>Exercise 10.5</h5>
<p>The network in the above example was manually configured by setting the location of each neuron and its connections with hard-coded values.  Rewrite this example to generate the network’s layout via an algorithm.  Can you make a circular network diagram? A random one? An example of a multi-layered network is below.</p>

<figure class="screenshot" data-pde="processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Ex_10_5_LayeredNetworkAnimation.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Connection.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Network.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Neuron.pde">
<img src="imgs/chapter10/ch10_exc05.png" alt="ch10 exc05"/>
<figcaption/>
</figure></div>

<div id="chapter10_exercise6" data-type="example">
<h5>Exercise 10.6</h5>
<p>Rewrite the example so that each neuron keeps track of its forward and backward connections.  Can you feed inputs through the network in any direction?</p>
</div>

<div id="chapter10_exercise7" data-type="example">
<h5>Exercise 10.7</h5>
<p>Instead of <strong function>lerp()</strong>, use moving bodies with steering forces to visualize the flow of information in the network.</p>
</div>

<div style="page-break-after:always;"> </div>
<div data-type="tip">
<h1>The Ecosystem Project</h1><p>Step 10 Exercise:</p>

<p>Try incorporating the concept of a “brain” into your creatures.</p>

<ul>
<li>
<p>Use reinforcement learning in the creatures’ decision-making process.</p></li>
<li>
<p>Create a creature that features a visualization of its brain as part of its design (even if the brain itself is not functional).</p></li>
<li>
<p>Can the ecosystem as a whole emulate the brain?  Can elements of the environment be neurons and the creatures act as inputs and outputs?</p></li>
</ul>
</div>





<section data-type="sect3" id="_the_end">
<h3>The end</h3>
<p>If you&#8217;re still reading, thank you!  You&#8217;ve reached the end of the book.  But for as much material as this book contains, we&#8217;ve barely scratched the surface of the world we inhabit and of techniques for simulating it.  It&#8217;s my intention for this book to live as an ongoing project, and I hope to continue adding new tutorials and examples to the <a href="http://natureofcode.com">book&#8217;s website</a> as well as expand and update the printed material.  Your feedback is truly appreciated, so please get in touch via email at <code>(daniel@shiffman.net)</code> or by contributing to the <a href="http://github.com/shiffman/The-Nature-of-Code/">GitHub repository</a>, in keeping with the open-source spirit of the project.  Share your work. Keep in touch.  Let&#8217;s be two with nature.</p>

<div style="page-break-after:always;"> </div></section>

</section>



</section>







<section data-type="chapter" id="_further_reading">
<h1>Further Reading</h1>



<section data-type="sect1" id="_books">
<h1>Books</h1>
<ul>
<li>
<p>Alexander, R. McNeill. <code>&lt;a href="http://t.co/IQ0iranE"&gt;&lt;em&gt;Principles of Animal Locomotion&lt;/em&gt;&lt;/a&gt;.</code> Princeton, NJ: Princeton University Press, 2002.</p></li>
<li>
<p>Bentley, Peter. <code>&lt;a href="http://t.co/XIp7b1zw"&gt;&lt;em&gt;Evolutionary Design by Computers&lt;/em&gt;&lt;/a&gt;.</code> San Francisco: Morgan Kaufmann Publishers, 1999.</p></li>
<li>
<p>Bohnacker, Hartmut, Benedikt Gross, Julia Laub, and Claudius Lazzeroni. <code>&lt;a href="http://t.co/8yekmakL"&gt;&lt;em&gt;Generative Design: Visualize, Program, and Create with Processing&lt;/em&gt;&lt;/a&gt;.</code> New York: Princeton Architectural Press, 2012.</p></li>
<li>
<p>Flake, Gary William. <code>&lt;a href="http://t.co/KdbTo1ZX"&gt;&lt;em&gt;The Computational Beauty of Nature: Computer Explorations of Fractals, Chaos, Complex Systems, and Adaptation&lt;/em&gt;&lt;/a&gt;.</code> Cambridge, MA: MIT Press, 1998.</p></li>
<li>
<p>Hale, Nathan Cabot. <code>&lt;a href="http://t.co/ztbQ1zCL"&gt;&lt;em&gt;Abstraction in Art and Nature&lt;/em&gt;&lt;/a&gt;.</code> New York: Dover, 1993.</p></li>
<li>
<p>Hildebrandt, Stefan, and Anthony J. Tromba. <code>&lt;a href="http://t.co/IQ0iranE"&gt;&lt;em&gt;Mathematics and Optimal Form&lt;/em&gt;&lt;/a&gt;.</code> New York: Scientific American Library, 1985. Distributed by <code>&lt;br /&gt;</code>W. H. Freeman.</p></li>
<li>
<p>Kline, Morris. <code>&lt;a href="http://t.co/v84SZnGx"&gt;&lt;em&gt;Mathematics and the Physical World&lt;/em&gt;&lt;/a&gt;.</code> New York: Crowell, [1959].</p></li>
<li>
<p>Kodicek, Danny. <code>&lt;a href="http://t.co/ygDdHMak"&gt;&lt;em&gt;Mathematics and Physics for Programmers&lt;/em&gt;&lt;/a&gt;.</code> Hingham, MA: Charles River Media, 2005.</p></li>
<li>
<p>McMahon, Thomas A., and John Tyler Bonner. <code>&lt;a href="http://t.co/EhX3KwZB"&gt;&lt;em&gt;On Size and Life&lt;/em&gt;&lt;/a&gt;.</code> New York: Scientific American Library, 1983. Distributed by W. H. Freeman.</p></li>
<li>
<p>Mandelbrot, Benoit B. <code>&lt;a href="http://t.co/jHRQ5sQC"&gt;&lt;em&gt;The Fractal Geometry of Nature&lt;/em&gt;&lt;/a&gt;.</code> San Francisco: W. H. Freeman, 1982.</p></li>
<li>
<p>Pearce, Peter. <code>&lt;a href="http://t.co/zaGQMOMc"&gt;&lt;em&gt;Structure in Nature Is a Strategy for Design&lt;/em&gt;&lt;/a&gt;.</code> Cambridge, MA: MIT Press, 1980.</p></li>
<li>
<p>Pearson, Matt. <code>&lt;a href="http://t.co/bXCWfgOC"&gt;&lt;em&gt;Generative Art&lt;/em&gt;&lt;/a&gt;.</code> Greenwich, CT: Manning Publications, 2011. Distributed by Pearson Education.</p></li>
<li>
<p>Prusinkiewicz, Przemysław, and Aristid Lindenmayer. <code>&lt;a href="http://t.co/koD7FhJQ"&gt;&lt;em&gt;The Algorithmic Beauty of Plants&lt;/em&gt;&lt;/a&gt;.</code> New York: Springer-Verlag, 1990.</p></li>
<li>
<p>Reas, Casey, and Chandler McWilliams. <code>&lt;a href="http://t.co/1jGgwhvU"&gt;&lt;em&gt;Form+Code in Design, Art, and Architecture&lt;/em&gt;&lt;/a&gt;.</code> Design Briefs. New York: Princeton Architectural Press, 2010.</p></li>
<li>
<p>Reas, Casey, and Ben Fry. <code>&lt;a href="http://t.co/dtODdOQp"&gt;&lt;em&gt;Processing: A Programming Handbook for Visual Designers and Artists&lt;/em&gt;&lt;/a&gt;.</code> Cambridge, MA: MIT Press, 2007.</p></li>
<li>
<p>Thompson, D&#8217;Arcy Wentworth. <code>&lt;a href="http://t.co/vncWa1uW"&gt;&lt;em&gt;On Growth and Form: The Complete Revised Edition&lt;/em&gt;&lt;/a&gt;.</code> New York: Dover, 1992.</p></li>
<li>
<p>Vogel., Steven. <code>&lt;a href="http://t.co/fyTbVta1"&gt;&lt;em&gt;Life in Moving Fluids&lt;/em&gt;&lt;/a&gt;.</code> Princeton, NJ: Princeton University Press, 1994.</p></li>
<li>
<p>Wade, David. <code>&lt;a href="http://t.co/1QYDlsDH"&gt;&lt;em&gt;Li: Dynamic Form in Nature&lt;/em&gt;&lt;/a&gt;.</code> Wooden Books. New York: Walker &amp; Co., 2003.</p></li>
<li>
<p>Waterman, Talbot H. <code>&lt;a href="http://t.co/c2otv8LZ"&gt;&lt;em&gt;Animal Navigation&lt;/em&gt;&lt;/a&gt;.</code> New York: Scientific American Library, 1989. Distributed by W. H. Freeman.</p></li>
<li>
<p>Whyte, Lancelot Law. <code>&lt;a href="http://t.co/f7UkVLQM"&gt;&lt;em&gt;Aspects of Form: A Symposium on Form in Nature and Art&lt;/em&gt;&lt;/a&gt;.</code> Midland Books, MB 31. Bloomington: Indiana University Press, 1966.</p></li>
</ul>

<p>For other books that use Processing, see <a href="http://www.processing.org/learning/books">Processing Books</a>.</p>
</section>







<section data-type="sect1" id="_papers_and_articles">
<h1>Papers and Articles</h1>
<ul>
<li>
<p>Galanter, Philip. <a href="http://bit.ly/S7dhnq">"The Problem with Evolutionary Art Is…"</a> Paper presented at EvoCOMNET&#8217;10: The 7th European Event on the Application of Nature-inspired Techniques for Telecommunication Networks and other Parallel and Distributed Systems, April 7-9, 2010.</p></li>
<li>
<p>Gardner, Martin. <a href="http://www.ibiblio.org/lifepatterns/october1970.html">"Mathematical Games: The Fantastic Combinations of John Conway&#8217;s New Solitaire Game <em>Life.</em>"</a> <em>Scientific American</em> 229 (October 1970): 120-23.</p></li>
<li>
<p>Reeves, William T. <a href="http://dl.acm.org/citation.cfm?id=357320">"Particle Systems—A Technique for Modeling a Class of Fuzzy Objects."</a> <em>ACM Transactions on Graphics</em> 2:2 (April 1983): 91-108.</p></li>
<li>
<p>Sims, Karl. <a href="http://www.karlsims.com/papers/siggraph91.html">"Artificial Evolution for Computer Graphics."</a> Paper presented at SIGGRAPH '91: The 18th Annual Conference on Computer Graphics and Interactive Techniques, Las Vegas, NV, July 28-August 2, 1991.</p></li>
<li>
<p>---. <a href="http://www.karlsims.com/papers/siggraph94.pdf">"Evolving Virtual Creatures."</a> Paper presented at SIGGRAPH '94: The 21st Annual Conference on Computer Graphics and Interactive Techniques, Orlando, FL, July 24-29, 1994.</p></li>
<li>
<p>---. <a href="http://www.karlsims.com/papers/ParticlesSiggraph90.pdf">"Particle Animation and Rendering Using Data Parallel Computation."</a> Paper presented at SIGGRAPH '90: The 17th Annual Conference on Computer Graphics and Interactive Techniques, Dallas, TX, August 6-10, 1990.</p></li>
</ul>

<div style="page-break-after:always;"> </div></section>



</section>







<section data-type="index" id="_index">
<h1>Index</h1>
<p>Coming Soon!!</p>

</div></section>





